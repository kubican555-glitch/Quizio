diff --git a/replit.md b/replit.md
index 6ba962b..ac11ecd 100644
--- a/replit.md
+++ b/replit.md
@@ -1,212 +1,212 @@
-# SPS Quiz Application - Complete
-
-## Overview
-
-This is a professional quiz application built with React and Vite for Czech technical certification training (SPS - mechanical engineering and compressor systems). The app provides multiple learning modes with a modern, responsive design optimized for both desktop and mobile devices.
-
-## User Preferences
-
-- Preferred communication style: Simple, everyday language
-- Design philosophy: Modern, clean, and intuitive UI with gradient accents
-- Color scheme: Blue and purple gradients on dark background
-
-## Application Modes
-
-### 1. **Flashcards Mode** (Random Mode)
-- Present questions in random order
-- Instant feedback on answers (green for correct, red for incorrect)
-- Unlimited questions - users can cycle through repeatedly
-- Score tracking: correct answers / total attempts
-
-### 2. **Mock Test** (Timed Mode)
-- 40 random questions from the full question bank
-- 30-minute time limit with visual timer
-- Timer warnings at 5 minutes (yellow) and 1 minute (red)
-- All questions must be answered before submission
-- Detailed results with percentage score
-
-### 3. **Training Mode** (Progressive Mode)
-- All questions presented in sequence
-- Unlimited time for each question
-- Progressive unlock: can only navigate to questions already seen
-- Tracks time spent on training
-- Results show only reviewed questions
-- Useful for systematic learning
-
-### 4. **Review Mode** (Reference Mode)
-- View all questions in a searchable grid layout
-- No interaction required
-- Displays correct answers for reference
-- Hover effects reveal additional details
-
-## System Architecture
-
-### Frontend Stack
-- **React 18.2.0** - Component-based UI with hooks
-- **Vite 5.0.0** - Fast build tool with HMR
-- **Pure CSS** - No CSS framework; custom design system
-- **No external dependencies** - Minimal attack surface, maximum control
-
-### Design System
-
-**Color Palette:**
-- Background: Dark blue gradient (#0f172a ├ö─ç─║ #1e293b ├ö─ç─║ #334155)
-- Primary: Blue (#3b82f6, #60a5fa)
-- Secondary: Purple (#8b5cf6, #a78bfa)
-- Success: Green (#22c55e)
-- Error: Red (#ef4444)
-- Warning: Amber (#fbbf24)
-- Neutral: Slate grays (#cbd5e1, #94a3b8)
-
-**Typography:**
-- Font: Inter, Segoe UI, Roboto sans-serif
-- Titles: 2.8rem, weight 800, gradient text
-- Body: 1rem-1.1rem, weight 400-600
-
-**Components:**
-- Gradient buttons with hover animations
-- Glassmorphism cards with backdrop blur
-- Smooth fade/slide animations
-- Responsive grid layouts (mobile-first)
-- Custom scrollbars matching theme
-
-### State Management
-
-All state is managed locally with React hooks:
-```javascript
-- mode: Current quiz mode
-- questionSet: Shuffled/ordered questions for session
-- currentIndex: User's position in question set
-- selectedAnswer: Currently selected answer index
-- score: Correct answers / total questions
-- timeLeft: Remaining time in mock test
-- trainingTime: Elapsed time in training mode
-- finished: Session completion state
-- maxSeenIndex: Furthest question seen (training mode)
-```
-
-### Data Flow
-
-1. **Question Loading**: QUESTIONS constant imported from src/questions.js
-2. **Mode Start**: Questions shuffled or ordered based on selected mode
-3. **Answer Handling**: User selections stored in question objects
-4. **Scoring**: Calculated at session end or in real-time
-5. **Results**: Filtered/displayed based on mode
-
-### Keyboard Support
-
-Full keyboard navigation for accessibility and power users:
-- **W/S or ├ö─ç─╣├ö─ç├┤**: Cycle through answers
-- **A/D or ├ö─ç├ë├ö─ç─║**: Navigate questions
-- **Space**: Next question / submit test
-- **Backspace**: Clear answer / return to menu
-- **Enter**: Confirm actions
-- **Escape**: Cancel dialogs / clear results
-
-## Recent Improvements (Session 3)
-
-### Answer Shuffling System
-- Answer options shuffle dynamically when questions display
-- Fisher-Yates algorithm ensures fair randomization
-- Mock/real tests: answers shuffle once at test start, remain fixed throughout
-- Smart learning mode: re-shuffles answers when same question reappears
-- Answers remain stable during single question interaction
-
-### Keyboard Navigation Improvements
-- Visual selection tracking (`visualSelection` state) syncs with shuffled answers
-- `shuffledMapping` array communicates between QuestionCard and App
-- W/S and arrow keys navigate through visual positions correctly
-- State properly resets when returning to menu
-
-### Bug Fixes
-- Fixed duplicate "border" key warning in ScheduledTestsList.jsx
-- Added `visualSelection` prop to QuestionCard component
-- Fixed state cleanup when exiting modes (visualSelection, shuffledMapping reset)
-
-## Previous Improvements (Session 2)
-
-### Design Enhancements
-- Complete visual redesign with modern gradient theme
-- Blue/purple color scheme replacing basic grays
-- Smooth animations and transitions throughout
-- Glassmorphism effects on cards and modals
-- Responsive typography using CSS clamp()
-- Mobile-optimized responsive design
-
-### Bug Fixes
-- Fixed timer in mock mode (separated timer logic from submission)
-- Added proper auto-submit when time reaches 0
-- Fixed answered question button color (blue instead of confusing green)
-- Added mobile viewport height fix (--vh CSS variable)
-- Smooth navigator auto-scrolling to current question
-
-### Feature Completeness
-- Added keyboard shortcut help text in menu
-- Fullscreen image viewing with zoom
-- Confirmation dialogs for test submission
-- Progress indicators showing answered vs unanswered questions
-- Time display for training mode (informational)
-- Results review showing which questions were missed
-- Responsive grid layout for review mode
-
-### Code Quality
-- Removed unused App.css file
-- Organized CSS into logical sections with comments
-- Added media queries for responsive design
-- Implemented smooth animations with @keyframes
-- Added accessibility labels (aria-label)
-- Proper component composition (small helper components)
-
-## File Structure
-
-```
-/
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç src/
-├ö├Â├ę   ├ö├Â┼ą├ö├Â├ç├ö├Â├ç App.jsx              (Main app component - modes, state, logic)
-├ö├Â├ę   ├ö├Â┼ą├ö├Â├ç├ö├Â├ç questions.js         (Question data - generated from CSV)
-├ö├Â├ę   ├ö├Â┼ą├ö├Â├ç├ö├Â├ç index.jsx            (React entry point)
-├ö├Â├ę   ├ö├Â┼ą├ö├Â├ç├ö├Â├ç images/              (Question images - 1.png to 504.png)
-├ö├Â├ę   ├ö├Â├Â├ö├Â├ç├ö├Â├ç styles/
-├ö├Â├ę       ├ö├Â├Â├ö├Â├ç├ö├Â├ç globals.css      (Complete design system - 444 lines)
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç convert.js               (CSV ├ö─ç─║ JavaScript converter)
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç questions.csv            (Source question data)
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç vite.config.js           (Vite build configuration)
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç package.json             (Dependencies: React, Vite)
-├ö├Â┼ą├ö├Â├ç├ö├Â├ç index.html               (HTML entry point)
-├ö├Â├Â├ö├Â├ç├ö├Â├ç replit.md               (This file)
-```
-
-## Performance Optimizations
-
-- Images loaded with Vite glob for static analysis
-- Efficient state updates with functional setters
-- Refs for keyboard focus management
-- Smooth scrolling with native browser API
-- CSS animations instead of JS animations
-- Minimal re-renders with proper dependencies
-
-## Browser Compatibility
-
-- Modern browsers (Chrome, Firefox, Safari, Edge)
-- Mobile browsers (iOS Safari, Chrome Mobile)
-- Fallback for images using transparent PNG
-- Touch-friendly button sizing (min 48px Ôöť┼Ü 48px)
-- Responsive design from 320px to 2560px
-
-## Deployment
-
-- Configured for Replit platform
-- Vite dev server on 0.0.0.0:5000
-- Hot module reloading enabled
-- Ready for static hosting (npm run build)
-
-## Future Enhancements (Optional)
-
-- Backend API for question storage
-- User authentication and progress tracking
-- Analytics and performance metrics
-- Question filtering by category/difficulty
-- Leaderboard system
-- Multi-language support
-- Dark/light theme toggle
-- Export results to PDF
+# SPS Quiz Application - Complete

+

+## Overview

+

+This is a professional quiz application built with React and Vite for Czech technical certification training (SPS - mechanical engineering and compressor systems). The app provides multiple learning modes with a modern, responsive design optimized for both desktop and mobile devices.

+

+## User Preferences

+

+- Preferred communication style: Simple, everyday language

+- Design philosophy: Modern, clean, and intuitive UI with gradient accents

+- Color scheme: Blue and purple gradients on dark background

+

+## Application Modes

+

+### 1. **Flashcards Mode** (Random Mode)

+- Present questions in random order

+- Instant feedback on answers (green for correct, red for incorrect)

+- Unlimited questions - users can cycle through repeatedly

+- Score tracking: correct answers / total attempts

+

+### 2. **Mock Test** (Timed Mode)

+- 40 random questions from the full question bank

+- 30-minute time limit with visual timer

+- Timer warnings at 5 minutes (yellow) and 1 minute (red)

+- All questions must be answered before submission

+- Detailed results with percentage score

+

+### 3. **Training Mode** (Progressive Mode)

+- All questions presented in sequence

+- Unlimited time for each question

+- Progressive unlock: can only navigate to questions already seen

+- Tracks time spent on training

+- Results show only reviewed questions

+- Useful for systematic learning

+

+### 4. **Review Mode** (Reference Mode)

+- View all questions in a searchable grid layout

+- No interaction required

+- Displays correct answers for reference

+- Hover effects reveal additional details

+

+## System Architecture

+

+### Frontend Stack

+- **React 18.2.0** - Component-based UI with hooks

+- **Vite 5.0.0** - Fast build tool with HMR

+- **Pure CSS** - No CSS framework; custom design system

+- **No external dependencies** - Minimal attack surface, maximum control

+

+### Design System

+

+**Color Palette:**

+- Background: Dark blue gradient (#0f172a Ôöť├ÂÔöÇ #1e293b 3b  #334155)

+- Primary: Blue (#3b82f6, #60a5fa)

+- Secondary: Purple (#8b5cf6, #a78bfa)

+- Success: Green (#22c55e)

+- Error: Red (#ef4444)

+- Warning: Amber (#fbbf24)

+- Neutral: Slate grays (#cbd5e1, #94a3b8)

+

+**Typography:**

+- Font: Inter, Segoe UI, Roboto sans-serif

+- Titles: 2.8rem, weight 800, gradient text

+- Body: 1rem-1.1rem, weight 400-600

+

+**Components:**

+- Gradient buttons with hover animations

+- Glassmorphism cards with backdrop blur

+- Smooth fade/slide animations

+- Responsive grid layouts (mobile-first)

+- Custom scrollbars matching theme

+

+### State Management

+

+All state is managed locally with React hooks:

+```javascript

+- mode: Current quiz mode

+- questionSet: Shuffled/ordered questions for session

+- currentIndex: User's position in question set

+- selectedAnswer: Currently selected answer index

+- score: Correct answers / total questions

+- timeLeft: Remaining time in mock test

+- trainingTime: Elapsed time in training mode

+- finished: Session completion state

+- maxSeenIndex: Furthest question seen (training mode)

+```

+

+### Data Flow

+

+1. **Question Loading**: QUESTIONS constant imported from src/questions.js

+2. **Mode Start**: Questions shuffled or ordered based on selected mode

+3. **Answer Handling**: User selections stored in question objects

+4. **Scoring**: Calculated at session end or in real-time

+5. **Results**: Filtered/displayed based on mode

+

+### Keyboard Support

+

+Full keyboard navigation for accessibility and power users:

+- **W/S or Ôöť├ÂÔöÇ├žÔöÇÔĽú**: Cycle through answers

+- **A/D or Ôöť├ÂÔöÇ├žÔöť├ź**: Navigate questions

+- **Space**: Next question / submit test

+- **Backspace**: Clear answer / return to menu

+- **Enter**: Confirm actions

+- **Escape**: Cancel dialogs / clear results

+

+## Recent Improvements (Session 3)

+

+### Answer Shuffling System

+- Answer options shuffle dynamically when questions display

+- Fisher-Yates algorithm ensures fair randomization

+- Mock/real tests: answers shuffle once at test start, remain fixed throughout

+- Smart learning mode: re-shuffles answers when same question reappears

+- Answers remain stable during single question interaction

+

+### Keyboard Navigation Improvements

+- Visual selection tracking (`visualSelection` state) syncs with shuffled answers

+- `shuffledMapping` array communicates between QuestionCard and App

+- W/S and arrow keys navigate through visual positions correctly

+- State properly resets when returning to menu

+

+### Bug Fixes

+- Fixed duplicate "border" key warning in ScheduledTestsList.jsx

+- Added `visualSelection` prop to QuestionCard component

+- Fixed state cleanup when exiting modes (visualSelection, shuffledMapping reset)

+

+## Previous Improvements (Session 2)

+

+### Design Enhancements

+- Complete visual redesign with modern gradient theme

+- Blue/purple color scheme replacing basic grays

+- Smooth animations and transitions throughout

+- Glassmorphism effects on cards and modals

+- Responsive typography using CSS clamp()

+- Mobile-optimized responsive design

+

+### Bug Fixes

+- Fixed timer in mock mode (separated timer logic from submission)

+- Added proper auto-submit when time reaches 0

+- Fixed answered question button color (blue instead of confusing green)

+- Added mobile viewport height fix (--vh CSS variable)

+- Smooth navigator auto-scrolling to current question

+

+### Feature Completeness

+- Added keyboard shortcut help text in menu

+- Fullscreen image viewing with zoom

+- Confirmation dialogs for test submission

+- Progress indicators showing answered vs unanswered questions

+- Time display for training mode (informational)

+- Results review showing which questions were missed

+- Responsive grid layout for review mode

+

+### Code Quality

+- Removed unused App.css file

+- Organized CSS into logical sections with comments

+- Added media queries for responsive design

+- Implemented smooth animations with @keyframes

+- Added accessibility labels (aria-label)

+- Proper component composition (small helper components)

+

+## File Structure

+

+```

+/

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť src/

+Ôöť├ÂÔöť      Ôöť├ÂÔöť├éÔö╝─ů App.jsx              (Main app component - modes, state, logic)

+Ôöť├ÂÔöť      Ôöť├ÂÔöť├éÔö╝─ů questions.js         (Question data - generated from CSV)

+Ôöť├ÂÔöť      Ôöť├ÂÔöť├éÔö╝─ů index.jsx            (React entry point)

+Ôöť├ÂÔöť      Ôöť├ÂÔöť├éÔö╝─ů images/              (Question images - 1.png to 504.png)

+Ôöť├ÂÔöť      Ôöť├ÂÔöť├éÔöť├é styles/

+Ôöť├ÂÔöť          Ôöť├ÂÔöť├éÔöť├é globals.css      (Complete design system - 444 lines)

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť convert.js               (CSV     JavaScript converter)

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť questions.csv            (Source question data)

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť vite.config.js           (Vite build configuration)

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť package.json             (Dependencies: React, Vite)

+Ôöť├ÂÔöť├éÔö╝─ůÔöť├ÂÔöť index.html               (HTML entry point)

+Ôöť├ÂÔöť├éÔöť├éÔöť├ÂÔöť replit.md               (This file)

+```

+

+## Performance Optimizations

+

+- Images loaded with Vite glob for static analysis

+- Efficient state updates with functional setters

+- Refs for keyboard focus management

+- Smooth scrolling with native browser API

+- CSS animations instead of JS animations

+- Minimal re-renders with proper dependencies

+

+## Browser Compatibility

+

+- Modern browsers (Chrome, Firefox, Safari, Edge)

+- Mobile browsers (iOS Safari, Chrome Mobile)

+- Fallback for images using transparent PNG

+- Touch-friendly button sizing (min 48px +├Â 48px)

+- Responsive design from 320px to 2560px

+

+## Deployment

+

+- Configured for Replit platform

+- Vite dev server on 0.0.0.0:5000

+- Hot module reloading enabled

+- Ready for static hosting (npm run build)

+

+## Future Enhancements (Optional)

+

+- Backend API for question storage

+- User authentication and progress tracking

+- Analytics and performance metrics

+- Question filtering by category/difficulty

+- Leaderboard system

+- Multi-language support

+- Dark/light theme toggle

+- Export results to PDF

diff --git a/src/App.jsx b/src/App.jsx
index ea6d71d..43d0294 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -1,4034 +1,4868 @@
-import React, { useState, useEffect, useRef } from "react";
-import { supabase } from "./supabaseClient";
-import { useUserProfile } from "./hooks/useUserProfile";
-import { useActivityDetection } from "./hooks/useActivityDetection";
-import { useGlobalKeyboard } from "./hooks/useGlobalKeyboard";
-
-import { SubjectSelector } from "./components/SubjectSelector.jsx";
-import { AdminPanel } from "./components/AdminPanel.jsx";
-import { TestManager } from "./components/TestManager.jsx";
-
-import { SessionBlockedScreen } from "./components/SessionBlockedScreen.jsx";
-import { CloudLoginScreen } from "./components/CloudLoginScreen.jsx";
-import { CustomImageModal } from "./components/CustomImageModal.jsx";
-import { HighlightedText } from "./components/HighlightedText.jsx";
-import { MainMenu } from "./components/MainMenu.jsx";
-import { ScheduledTestsList } from "./components/ScheduledTestsList.jsx";
-import { RealTestMode } from "./components/RealTestMode.jsx";
-
-import {
-    formatTime,
-    removeAccents,
-    getSmartRegex,
-    isFlashcardStyle,
-} from "./utils/formatting.js";
-import { getImageUrl } from "./utils/images.js";
-import {
-    fetchQuestionsLightweight,
-    clearImageCache,
-    getCachedImage,
-    fetchQuestionImage,
-    preloadTestImages,
-} from "./utils/dataManager.js";
-
-import { SubjectBadge } from "./components/SubjectBadge.jsx";
-import { UserBadgeDisplay } from "./components/UserBadgeDisplay.jsx";
-import { HistoryView } from "./components/HistoryView.jsx";
-import { ResultScreen } from "./components/ResultScreen.jsx";
-import { QuestionCard } from "./components/QuestionCard.jsx";
-import { Navigator } from "./components/Navigator.jsx";
-import { ThemeToggle } from "./components/ThemeToggle.jsx";
-import { HiddenPreloader } from "./components/HiddenPreloader.jsx";
-import { ConfirmModal } from "./components/Modals.jsx";
-import { NoMistakesScreen } from "./components/NoMistakesScreen.jsx";
-import { ReportModal } from "./components/ReportModal.jsx";
-import { SmartSettingsModal } from "./components/Modals.jsx";
-
-import { CustomImportGuide } from "./components/CustomImportGuide.jsx";
-import { LeaderboardPanel } from "./components/LeaderboardPanel.jsx";
-
-/* ---------- Review Navigator Component ---------- */
-const ReviewNavigator = ({ currentPage, totalPages, onPageChange }) => {
-    const getPageNumbers = () => {
-        const current = currentPage + 1;
-        const delta = 2;
-        const range = [];
-        const rangeWithDots = [];
-        let l;
-
-        for (let i = 1; i <= totalPages; i++) {
-            if (
-                i === 1 ||
-                i === totalPages ||
-                (i >= current - delta && i <= current + delta)
-            ) {
-                range.push(i);
-            }
-        }
-
-        for (let i of range) {
-            if (l) {
-                if (i - l === 2) {
-                    rangeWithDots.push(l + 1);
-                } else if (i - l !== 1) {
-                    rangeWithDots.push("...");
-                }
-            }
-            rangeWithDots.push(i);
-            l = i;
-        }
-
-        return rangeWithDots;
-    };
-
-    if (totalPages <= 1) return null;
-
-    return (
-        <div
-            className="reviewPagination"
-            style={{
-                flexWrap: "wrap",
-                gap: "0.5rem",
-                justifyContent: "center",
-                marginTop: "2rem",
-            }}
-        >
-            <button
-                className="reviewPaginationBtn"
-                disabled={currentPage === 0}
-                onClick={() => onPageChange(currentPage - 1)}
-                style={{
-                    padding: "0 1rem",
-                    minHeight: "40px",
-                    display: "flex",
-                    alignItems: "center",
-                    justifyContent: "center",
-                }}
-            >
-                ÔćÉ
-            </button>
-
-            {getPageNumbers().map((page, index) => {
-                const isDots = page === "...";
-                const isCurrent = page === currentPage + 1;
-
-                return (
-                    <button
-                        key={index}
-                        className="reviewPaginationBtn"
-                        onClick={() =>
-                            typeof page === "number"
-                                ? onPageChange(page - 1)
-                                : null
-                        }
-                        disabled={isDots}
-                        style={{
-                            width: "40px",
-                            height: "40px",
-                            padding: 0,
-                            minHeight: "40px",
-                            display: "flex",
-                            alignItems: "center",
-                            justifyContent: "center",
-                            cursor: isDots ? "default" : "pointer",
-                            opacity: isDots ? 0.5 : 1,
-                            background: isDots
-                                ? "transparent"
-                                : isCurrent
-                                  ? "var(--color-primary)"
-                                  : undefined,
-                            borderColor: isDots
-                                ? "transparent"
-                                : isCurrent
-                                  ? "var(--color-primary)"
-                                  : undefined,
-                            color: isCurrent ? "#fff" : undefined,
-                            fontWeight: isCurrent ? "bold" : "normal",
-                            boxShadow: isCurrent
-                                ? "0 4px 12px rgba(59, 130, 246, 0.4)"
-                                : "none",
-                        }}
-                    >
-                        {page}
-                    </button>
-                );
-            })}
-
-            <button
-                className="reviewPaginationBtn"
-                disabled={currentPage === totalPages - 1}
-                onClick={() => onPageChange(currentPage + 1)}
-                style={{
-                    padding: "0 1rem",
-                    minHeight: "40px",
-                    display: "flex",
-                    alignItems: "center",
-                    justifyContent: "center",
-                }}
-            >
-                Ôćĺ
-            </button>
-        </div>
-    );
-};
-
-/* ---------- Review Image Component ---------- */
-
-const ReviewImage = ({ q, subject, setFullscreenImage }) => {
-    const [imgUrl, setImgUrl] = useState(() => {
-        return (
-            q.image_base64 ||
-            (q.id ? getCachedImage(q.id) : null) ||
-            getImageUrl(subject, q.number) ||
-            (q.image && q.image.length > 5 ? q.image : null)
-        );
-    });
-
-    useEffect(() => {
-        if (q.id && !imgUrl) {
-            fetchQuestionImage(q.id).then((url) => {
-                if (url) setImgUrl(url);
-            });
-        }
-    }, [q.id, imgUrl]);
-
-    if (!imgUrl) return null;
-
-    return (
-        <div
-            className="reviewImageWrapper"
-            onClick={() => setFullscreenImage(imgUrl)}
-        >
-            <img
-                src={imgUrl}
-                alt=""
-                className="reviewImage"
-                onError={(e) => (e.target.style.display = "none")}
-            />
-        </div>
-    );
-};
-
-/* ---------- Main App Component ---------- */
-
-export default function App() {
-    const {
-        user,
-        dbId,
-        loading,
-        syncing,
-        isSessionBlocked,
-        profileData,
-        mistakes,
-        history,
-        testPracticeStats,
-        totalTimeMap,
-        totalQuestionsMap,
-        login,
-        logout,
-        takeOverSession,
-        saveData,
-        refreshData,
-        triggerFakeSync,
-        setMistakes,
-        setHistory,
-    } = useUserProfile();
-
-    // --- KONSTANTA PRO LIMIT ---
-    const SMART_SAVE_LIMIT = 100;
-
-    const [subject, setSubject] = useState(null);
-    const [customQuestions, setCustomQuestions] = useState(null);
-
-    const [theme, setTheme] = useState(
-        () => localStorage.getItem("quizio_theme") || "dark",
-    );
-    const [activeQuestionsCache, setActiveQuestionsCache] = useState([]);
-    const [isLoadingQuestions, setIsLoadingQuestions] = useState(false);
-    const [isTransitioningSubject, setIsTransitioningSubject] = useState(false);
-    const [menuSelection, setMenuSelection] = useState(-1);
-    const [mode, setMode] = useState(null);
-    const [leaderboardEntries, setLeaderboardEntries] = useState([]);
-    const [leaderboardLoading, setLeaderboardLoading] = useState(false);
-    const [leaderboardError, setLeaderboardError] = useState(null);
-
-    const DUEL_ANSWER_SECONDS = 45;
-    const DUEL_RUSH_SECONDS = 10;
-    const DUEL_RESULT_SECONDS = 3;
-
-    const [duelOnlineUsers, setDuelOnlineUsers] = useState([]);
-    const [duelInvites, setDuelInvites] = useState([]);
-    const [duelInviteToShow, setDuelInviteToShow] = useState(null);
-    const [duelOutgoingMatch, setDuelOutgoingMatch] = useState(null);
-    const [duelActiveMatch, setDuelActiveMatch] = useState(null);
-    const [duelQuestionSet, setDuelQuestionSet] = useState([]);
-    const [duelAnswers, setDuelAnswers] = useState([]);
-    const [duelLocalAnswers, setDuelLocalAnswers] = useState({});
-    const [duelClock, setDuelClock] = useState(Date.now());
-    const [duelClockOffsetMs, setDuelClockOffsetMs] = useState(0);
-    const [duelStats, setDuelStats] = useState(null);
-    const [duelSettings, setDuelSettings] = useState({
-        questionCount: 10,
-        rangeMode: "all",
-        rangeStart: "",
-        rangeEnd: "",
-    });
-    const [duelError, setDuelError] = useState("");
-    const duelPresenceRef = useRef(null);
-    const duelFinalizeRef = useRef(false);
-
-    useEffect(() => {
-        const syncStateFromUrl = () => {
-            const params = new URLSearchParams(window.location.search);
-            const s = params.get("s");
-            const m = params.get("m");
-
-            if (s) setSubject(s.toUpperCase());
-            else setSubject(null);
-
-            if (m) setMode(m);
-            else setMode(null);
-        };
-
-        window.addEventListener("popstate", syncStateFromUrl);
-        syncStateFromUrl();
-        return () => window.removeEventListener("popstate", syncStateFromUrl);
-    }, []);
-
-    useEffect(() => {
-        if (!profileData?.class) {
-            setLeaderboardEntries([]);
-            return;
-        }
-
-        let isActive = true;
-
-        const fetchLeaderboard = async () => {
-            setLeaderboardLoading(true);
-            setLeaderboardError(null);
-
-            const { data, error } = await supabase
-                .from("profiles")
-                .select("id, username, subject_times, question_counts, class")
-                .eq("class", profileData.class);
-
-            if (!isActive) return;
-
-            if (error) {
-                setLeaderboardError(error.message);
-                setLeaderboardEntries([]);
-            } else {
-                const mapped = (data || [])
-                    .map((profile) => {
-                        const subjectTimes = profile.subject_times || {};
-                        const questionCounts = profile.question_counts || {};
-                        const totalTime = Object.values(subjectTimes).reduce(
-                            (sum, value) => sum + (value || 0),
-                            0,
-                        );
-                        const totalQuestions = Object.values(
-                            questionCounts,
-                        ).reduce((sum, value) => sum + (value || 0), 0);
-                        return {
-                            id: profile.id,
-                            username: profile.username,
-                            subjectTimes,
-                            questionCounts,
-                            totalTime,
-                            totalQuestions,
-                        };
-                    })
-                    .sort((a, b) => b.totalTime - a.totalTime);
-
-                setLeaderboardEntries(mapped);
-            }
-
-            setLeaderboardLoading(false);
-        };
-
-        fetchLeaderboard();
-
-        return () => {
-            isActive = false;
-        };
-    }, [profileData?.class]);
-
-    useEffect(() => {
-        if (!dbId || !user || !profileData?.class) return;
-
-        const channel = supabase.channel(
-            `duel_presence_${profileData.class}`,
-            {
-                config: { presence: { key: dbId } },
-            },
-        );
-
-        channel.on("presence", { event: "sync" }, () => {
-            const state = channel.presenceState();
-            const users = [];
-            Object.values(state).forEach((entries) => {
-                entries.forEach((entry) => {
-                    if (entry.user_id !== dbId) {
-                        users.push({
-                            id: entry.user_id,
-                            username: entry.username,
-                            class: entry.class,
-                        });
-                    }
-                });
-            });
-            setDuelOnlineUsers(users);
-        });
-
-        channel.subscribe((status) => {
-            if (status === "SUBSCRIBED") {
-                channel.track({
-                    user_id: dbId,
-                    username: user,
-                    class: profileData.class,
-                });
-            }
-        });
-
-        duelPresenceRef.current = channel;
-
-        return () => {
-            supabase.removeChannel(channel);
-            duelPresenceRef.current = null;
-        };
-    }, [dbId, user, profileData?.class]);
-
-    useEffect(() => {
-        if (!dbId) return;
-
-        const fetchStats = async () => {
-            const { data } = await supabase
-                .from("duel_stats")
-                .select("*")
-                .eq("user_id", dbId)
-                .maybeSingle();
-            if (data) setDuelStats(data);
-            else
-                setDuelStats({
-                    trophies: 0,
-                    wins: 0,
-                    losses: 0,
-                    draws: 0,
-                });
-        };
-
-        fetchStats();
-    }, [dbId]);
-
-    useEffect(() => {
-        if (!dbId) return;
-
-        let isActive = true;
-
-        const fetchInvites = async () => {
-            const { data: incoming } = await supabase
-                .from("duel_matches")
-                .select("*")
-                .eq("opponent_id", dbId)
-                .eq("status", "pending");
-
-            const { data: outgoing } = await supabase
-                .from("duel_matches")
-                .select("*")
-                .eq("challenger_id", dbId)
-                .in("status", ["pending", "active"]);
-
-            if (!isActive) return;
-            setDuelInvites(incoming || []);
-            setDuelOutgoingMatch(outgoing?.[0] || null);
-            if (outgoing?.[0]?.status === "active") {
-                setDuelActiveMatch(outgoing[0]);
-                setMode("duel_match");
-            }
-        };
-
-        fetchInvites();
-
-        const channel = supabase
-            .channel(`duel_matches_${dbId}`)
-            .on(
-                "postgres_changes",
-                {
-                    event: "*",
-                    schema: "public",
-                    table: "duel_matches",
-                    filter: `opponent_id=eq.${dbId}`,
-                },
-                (payload) => {
-                    const match = payload.new;
-                    if (!match) return;
-
-                    if (match.status === "pending") {
-                        setDuelInvites((prev) => {
-                            const exists = prev.find((i) => i.id === match.id);
-                            if (exists) return prev;
-                            return [...prev, match];
-                        });
-                    } else {
-                        setDuelInvites((prev) =>
-                            prev.filter((i) => i.id !== match.id),
-                        );
-                    }
-
-                    if (match.status === "active") {
-                        setDuelActiveMatch(match);
-                        duelFinalizeRef.current = false;
-                        if (subject !== match.subject) setSubject(match.subject);
-                        setMode("duel_match");
-                    }
-                },
-            )
-            .on(
-                "postgres_changes",
-                {
-                    event: "*",
-                    schema: "public",
-                    table: "duel_matches",
-                    filter: `challenger_id=eq.${dbId}`,
-                },
-                (payload) => {
-                    const match = payload.new;
-                    if (!match) return;
-
-                    if (match.status === "pending") {
-                        setDuelOutgoingMatch(match);
-                    } else if (match.status === "active") {
-                        setDuelOutgoingMatch(null);
-                        setDuelActiveMatch(match);
-                        duelFinalizeRef.current = false;
-                        if (subject !== match.subject) setSubject(match.subject);
-                        setMode("duel_match");
-                    } else if (
-                        match.status === "declined" ||
-                        match.status === "cancelled"
-                    ) {
-                        setDuelOutgoingMatch(null);
-                    }
-                },
-            )
-            .subscribe();
-
-        return () => {
-            isActive = false;
-            supabase.removeChannel(channel);
-        };
-    }, [dbId, subject]);
-
-    useEffect(() => {
-        if (mode === "real_test") return;
-        if (!duelInviteToShow && duelInvites.length > 0) {
-            setDuelInviteToShow(duelInvites[0]);
-        }
-    }, [duelInvites, duelInviteToShow, mode]);
-
-    useEffect(() => {
-        if (!duelActiveMatch?.id) return;
-
-        const channel = supabase
-            .channel(`duel_match_${duelActiveMatch.id}`)
-            .on(
-                "postgres_changes",
-                {
-                    event: "UPDATE",
-                    schema: "public",
-                    table: "duel_matches",
-                    filter: `id=eq.${duelActiveMatch.id}`,
-                },
-                (payload) => {
-                    if (payload.new) setDuelActiveMatch(payload.new);
-                },
-            )
-            .subscribe();
-
-        return () => {
-            supabase.removeChannel(channel);
-        };
-    }, [duelActiveMatch?.id]);
-
-    useEffect(() => {
-        if (!duelAnswers.length) return;
-        const confirmed = new Set(
-            duelAnswers
-                .filter((answer) => answer.user_id === dbId)
-                .map((answer) => answer.question_index),
-        );
-        if (confirmed.size === 0) return;
-        setDuelLocalAnswers((prev) => {
-            const next = { ...prev };
-            confirmed.forEach((idx) => {
-                delete next[idx];
-            });
-            return next;
-        });
-    }, [duelAnswers, dbId]);
-
-    useEffect(() => {
-        if (!duelActiveMatch?.id) return;
-
-        const fetchAnswers = async () => {
-            const { data } = await supabase
-                .from("duel_answers")
-                .select("*")
-                .eq("match_id", duelActiveMatch.id);
-            setDuelAnswers(data || []);
-        };
-
-        fetchAnswers();
-
-        const channel = supabase
-            .channel(`duel_answers_${duelActiveMatch.id}`)
-            .on(
-                "postgres_changes",
-                {
-                    event: "*",
-                    schema: "public",
-                    table: "duel_answers",
-                    filter: `match_id=eq.${duelActiveMatch.id}`,
-                },
-                (payload) => {
-                    if (payload.eventType === "DELETE") {
-                        setDuelAnswers((prev) =>
-                            prev.filter((a) => a.id !== payload.old.id),
-                        );
-                        return;
-                    }
-                    const answer = payload.new;
-                    if (!answer) return;
-                    setDuelAnswers((prev) => {
-                        const idx = prev.findIndex((a) => a.id === answer.id);
-                        if (idx === -1) return [...prev, answer];
-                        const next = [...prev];
-                        next[idx] = answer;
-                        return next;
-                    });
-                },
-            )
-            .subscribe();
-
-        return () => {
-            supabase.removeChannel(channel);
-        };
-    }, [duelActiveMatch?.id]);
-
-    useEffect(() => {
-        if (!duelActiveMatch) return;
-        const ids = duelActiveMatch.question_ids || [];
-        if (ids.length === 0) {
-            setDuelQuestionSet([]);
-            return;
-        }
-
-        const syncQuestions = async () => {
-            const localMap = new Map(
-                activeQuestionsCache.map((q) => [q.id, q]),
-            );
-            const missing = ids.filter((id) => !localMap.has(id));
-            let fetched = [];
-
-            if (missing.length > 0) {
-                const { data } = await supabase
-                    .from("questions")
-                    .select(
-                        "id, number, subject, question, options, correct_index, is_active, updated_at",
-                    )
-                    .in("id", missing);
-
-                fetched =
-                    data?.map((item) => ({
-                        ...item,
-                        correctIndex: item.correct_index,
-                        options: Array.isArray(item.options) ? item.options : [],
-                    })) || [];
-            }
-
-            fetched.forEach((item) => localMap.set(item.id, item));
-            const ordered = ids.map((id) => localMap.get(id)).filter(Boolean);
-            setDuelQuestionSet(ordered);
-        };
-
-        syncQuestions();
-    }, [duelActiveMatch, activeQuestionsCache]);
-
-    useEffect(() => {
-        if (!duelActiveMatch?.id) return;
-        calibrateDuelClock(duelActiveMatch.id);
-    }, [duelActiveMatch?.id]);
-
-    useEffect(() => {
-        if (!duelActiveMatch?.id) return;
-        const timer = setInterval(() => {
-            setDuelClock(Date.now() + duelClockOffsetMs);
-        }, 500);
-        return () => clearInterval(timer);
-    }, [duelActiveMatch?.id, duelClockOffsetMs]);
-
-    useEffect(() => {
-        if (!duelActiveMatch?.started_at) return;
-        const progress = getDuelProgress(duelActiveMatch, duelClock);
-        if (progress.phase === "finished") finalizeDuelMatch();
-    }, [duelClock, duelActiveMatch, duelAnswers, duelQuestionSet]);
-
-    useEffect(() => {
-        if (mode === "loading") return;
-        const params = new URLSearchParams();
-        if (subject) params.set("s", subject.toLowerCase());
-        if (mode) params.set("m", mode);
-
-        const newUrl =
-            window.location.pathname +
-            (params.toString() ? "?" + params.toString() : "");
-        if (
-            window.location.search !== "?" + params.toString() &&
-            !(window.location.search === "" && params.toString() === "")
-        ) {
-            window.history.pushState({ subject, mode }, "", newUrl);
-        }
-    }, [subject, mode]);
-
-    const [showSmartSettings, setShowSmartSettings] = useState(false);
-    const [showResumePrompt, setShowResumePrompt] = useState(false);
-    const [showSaveProgressPrompt, setShowSaveProgressPrompt] = useState(false);
-
-    const [showClearMistakesConfirm, setShowClearMistakesConfirm] =
-        useState(false);
-    const [searchTerm, setSearchTerm] = useState("");
-    const [reviewPage, setReviewPage] = useState(0);
-    const [questionSet, setQuestionSet] = useState([]);
-    const [currentIndex, setCurrentIndex] = useState(0);
-    const [selectedAnswer, setSelectedAnswer] = useState(null);
-    const [showResult, setShowResult] = useState(false);
-    const [score, setScore] = useState({ correct: 0, total: 0 });
-    const [combo, setCombo] = useState(0);
-    const [shake, setShake] = useState(false);
-    const [timeLeft, setTimeLeft] = useState(0);
-    const [finished, setFinished] = useState(false);
-
-    // --- CENTR├üLN├Ź FUNKCE PRO ULO┼ŻEN├Ź SMART SESSION ---
-    const persistSmartSession = async (currentSet, idx, currentScore) => {
-        if (!subject || !dbId || isSessionBlocked) return;
-        if (currentSet.length > SMART_SAVE_LIMIT) return; // Limit
-
-        // 1. Z├şsk├íme aktu├íln├ş data z profilu (pro zachov├ín├ş ostatn├şch p┼Öedm─Ťt┼»)
-        const existingSessions = profileData?.smart_session || {};
-
-        // 2. Data pro aktu├íln├ş p┼Öedm─Ťt
-        const questionIds = currentSet.map((q) => q.number);
-        const sessionData = {
-            ids: questionIds,
-            index: idx,
-            score: currentScore,
-            timestamp: Date.now(),
-        };
-
-        // 3. Merge: Existuj├şc├ş + Aktu├íln├ş
-        const updatedSessions = {
-            ...existingSessions,
-            [subject]: sessionData,
-        };
-
-        // 4. Odesl├ín├ş
-        await saveData({ smart_session: updatedSessions });
-    };
-
-    // Funkce pro smaz├ín├ş ulo┼żen├ęho postupu (vol├í se p┼Öi dokon─Źen├ş)
-    const clearSmartSession = async () => {
-        if (!subject) return;
-        const currentSessions = profileData?.smart_session || {};
-
-        // Vytvo┼Ö├şme kopii a sma┼żeme kl├ş─Ź aktu├íln├şho p┼Öedm─Ťtu
-        const updatedSessions = { ...currentSessions };
-        delete updatedSessions[subject];
-
-        await saveData({ smart_session: updatedSessions });
-        // console.log("Smart session vy─Źi┼ít─Ťna manu├íln─Ť.");
-    };
-
-    // --- AUTOMATICK├ë UKL├üD├üN├Ź (Backup p┼Öes useEffect) ---
-    // Ukl├íd├í p┼Öi zm─Ťn─Ť indexu (nap┼Ö. posun ┼íipkou)
-    useEffect(() => {
-        if (
-            mode === "smart" &&
-            !finished &&
-            questionSet.length > 0 &&
-            subject &&
-            questionSet.length <= SMART_SAVE_LIMIT
-        ) {
-            const timer = setTimeout(() => {
-                persistSmartSession(questionSet, currentIndex, score);
-            }, 500); // Debounce pro navigaci
-            return () => clearTimeout(timer);
-        }
-    }, [
-        mode,
-        currentIndex,
-        score,
-        finished,
-        subject,
-        questionSet,
-        profileData,
-    ]);
-
-    // --- ZAJI┼áT─ÜN├Ź SCROLLU NAHORU P┼śI ZM─ÜN─Ü OT├üZKY (UNIVERZ├üLN├Ź) ---
-    // Toto zajist├ş, ┼że p┼Öi ka┼żd├ę zm─Ťn─Ť indexu nebo re┼żimu se str├ínka posune nahoru.
-    useEffect(() => {
-        if (containerRef.current) {
-            containerRef.current.scrollTop = 0;
-        }
-        window.scrollTo({ top: 0, behavior: "instant" });
-    }, [currentIndex, mode, subject]); // Spust├ş se p┼Öi zm─Ťn─Ť indexu, m├│du nebo p┼Öedm─Ťtu
-    // -----------------------------------------------------------------
-
-    useEffect(() => {
-        window.currentTestIndex = currentIndex;
-        window.totalTestQuestions = questionSet.length;
-        return () => {
-            window.currentTestIndex = undefined;
-            window.totalTestQuestions = undefined;
-        };
-    }, [currentIndex, questionSet.length]);
-
-    const [maxSeenIndex, setMaxSeenIndex] = useState(0);
-    const [trainingTime, setTrainingTime] = useState(0);
-
-    const [showConfirmSubmit, setShowConfirmSubmit] = useState(false);
-    const [showConfirmExit, setShowConfirmExit] = useState(false);
-    const [recordToDelete, setRecordToDelete] = useState(null);
-    const [fullscreenImage, setFullscreenImage] = useState(null);
-    const [timeLeftAtSubmit, setTimeLeftAtSubmit] = useState(0);
-
-    const { isKeyboardMode, setIsKeyboardMode } = useGlobalKeyboard();
-    const { sessionTime, setSessionTime, isAfk } = useActivityDetection(
-        mode,
-        isSessionBlocked,
-    );
-
-    const [direction, setDirection] = useState("right");
-    const [exitDirection, setExitDirection] = useState(null);
-
-    const [reportModalOpen, setReportModalOpen] = useState(false);
-    const [questionToReport, setQuestionToReport] = useState(null);
-
-    const [scheduledTests, setScheduledTests] = useState([]);
-    const [activeTest, setActiveTest] = useState(null);
-    const [completedTestIds, setCompletedTestIds] = useState([]);
-    const [testToStart, setTestToStart] = useState(null);
-
-    const optionRefsForCurrent = useRef({});
-    const cardRef = useRef(null);
-    const containerRef = useRef(null);
-
-    const [sessionQuestionsCount, setSessionQuestionsCount] = useState(0);
-    const [readyQuestionId, setReadyQuestionId] = useState(null);
-    const [loadingProgress, setLoadingProgress] = useState(0);
-
-    const currentQuestion = questionSet[currentIndex] || {
-        question: "",
-        options: [],
-        correctIndex: 0,
-        number: 0,
-        _localIndex: currentIndex,
-    };
-    const currentQuestionId =
-        currentQuestion.id || currentQuestion.number || currentIndex;
-    const isContentReady = readyQuestionId === currentQuestionId;
-    const isTeacher = user === "admin" || user === "U─Źitel";
-
-    useEffect(() => {
-        const savedCode = localStorage.getItem("quizio_user_code");
-        if (savedCode && !user && !loading) {
-            login(savedCode);
-        }
-    }, []);
-
-    const saveDataToCloud = async (
-        newMistakes,
-        newHistory,
-        timeToAdd = 0,
-        questionsToAdd = 0,
-        newTestStats = null,
-    ) => {
-        const updates = {};
-        if (newMistakes !== undefined) updates.mistakes = newMistakes;
-        if (newHistory !== undefined) updates.history = newHistory;
-        if (newTestStats !== null) updates.test_practice_stats = newTestStats;
-        if (timeToAdd > 0 && subject) {
-            const currentSubjectTime = totalTimeMap[subject] || 0;
-            updates.subject_times = {
-                ...totalTimeMap,
-                [subject]: currentSubjectTime + timeToAdd,
-            };
-            setSessionTime(0);
-        }
-        if (questionsToAdd > 0 && subject) {
-            const currentCount = totalQuestionsMap[subject] || 0;
-            updates.question_counts = {
-                ...totalQuestionsMap,
-                [subject]: currentCount + questionsToAdd,
-            };
-            setSessionQuestionsCount(0);
-        }
-        if (Object.keys(updates).length > 0) await saveData(updates);
-    };
-
-    const flushSessionStats = () => {
-        if (sessionTime > 0 || sessionQuestionsCount > 0) {
-            saveDataToCloud(
-                undefined,
-                undefined,
-                sessionTime,
-                sessionQuestionsCount,
-            );
-        }
-    };
-
-    const fetchScheduledTests = async () => {
-        if (!subject || subject === "CUSTOM") return;
-        const { data } = await supabase
-            .from("scheduled_tests")
-            .select("*")
-            .eq("subject", subject)
-            .order("close_at", { ascending: true });
-        if (data) setScheduledTests(data);
-    };
-
-    const fetchCompletedTests = async () => {
-        if (!user || !dbId) {
-            setCompletedTestIds([]);
-            return;
-        }
-        const { data } = await supabase
-            .from("test_results")
-            .select("test_id")
-            .eq("user_id", dbId);
-        if (data) {
-            const ids = [...new Set(data.map((item) => item.test_id))];
-            setCompletedTestIds(ids);
-        }
-    };
-
-    useEffect(() => {
-        if (!subject || subject === "CUSTOM") return;
-        fetchScheduledTests();
-        const sub = supabase
-            .channel("tests_update")
-            .on(
-                "postgres_changes",
-                { event: "*", schema: "public", table: "scheduled_tests" },
-                fetchScheduledTests,
-            )
-            .subscribe();
-        return () => supabase.removeChannel(sub);
-    }, [subject]);
-
-    useEffect(() => {
-        if (!user || !dbId) {
-            setCompletedTestIds([]);
-            return;
-        }
-        fetchCompletedTests();
-        const sub = supabase
-            .channel("my_results_update")
-            .on(
-                "postgres_changes",
-                {
-                    event: "INSERT",
-                    schema: "public",
-                    table: "test_results",
-                    filter: `user_id=eq.${dbId}`,
-                },
-                (payload) =>
-                    setCompletedTestIds((prev) => [
-                        ...prev,
-                        payload.new.test_id,
-                    ]),
-            )
-            .on(
-                "postgres_changes",
-                { event: "DELETE", schema: "public", table: "test_results" },
-                fetchCompletedTests,
-            )
-            .subscribe();
-        return () => supabase.removeChannel(sub);
-    }, [user, dbId]);
-
-    const handleManualRefresh = async () => {
-        await Promise.all([
-            fetchScheduledTests(),
-            fetchCompletedTests(),
-            refreshData(),
-        ]);
-    };
-
-    const handleTestCompletion = (testId) => {
-        setCompletedTestIds((prev) =>
-            prev.includes(testId) ? prev : [...prev, testId],
-        );
-    };
-
-    const triggerHaptic = (type) => {
-        if (typeof navigator !== "undefined" && navigator.vibrate) {
-            if (type === "success") navigator.vibrate(50);
-            else if (type === "error") navigator.vibrate([50, 100, 50]);
-            else if (type === "light") navigator.vibrate(10);
-        }
-    };
-
-    const updateMistakes = (newValOrFn) => {
-        const next =
-            typeof newValOrFn === "function"
-                ? newValOrFn(mistakes)
-                : newValOrFn;
-        setMistakes(next);
-        saveDataToCloud(next, undefined);
-    };
-
-    const updateHistory = (newValOrFn) => {
-        const next =
-            typeof newValOrFn === "function" ? newValOrFn(history) : newValOrFn;
-        setHistory(next);
-        saveDataToCloud(undefined, next);
-    };
-
-    const handleLogout = () => {
-        flushSessionStats();
-        setSubject(null);
-        setMode(null);
-        logout();
-    };
-
-    const openHistoryWithRefresh = async () => {
-        flushSessionStats();
-        setMode("history");
-        await refreshData();
-    };
-
-    useEffect(() => {
-        if (sessionTime >= 60 || sessionQuestionsCount >= 10)
-            saveDataToCloud(
-                undefined,
-                undefined,
-                sessionTime,
-                sessionQuestionsCount,
-            );
-    }, [sessionTime, sessionQuestionsCount]);
-
-    useEffect(() => {
-        localStorage.setItem("quizio_theme", theme);
-        document.body.className = theme === "light" ? "light-mode" : "";
-        document.documentElement.setAttribute("data-theme", theme);
-        window.dispatchEvent(new Event("storage"));
-
-        if (theme === "light")
-            document.documentElement.style.backgroundColor = "#f8fafc";
-        else document.documentElement.style.backgroundColor = "#0a0e27";
-    }, [theme]);
-
-    const toggleTheme = () => {
-        setTheme((prev) => {
-            const next = prev === "dark" ? "light" : "dark";
-            return next;
-        });
-    };
-
-    const prepareQuestionSet = (
-        baseQuestions,
-        shouldShuffleOptions = false,
-    ) => {
-        if (!Array.isArray(baseQuestions)) return [];
-        return baseQuestions.map((q, idx) => {
-            let options = [...(q.options || [])];
-            let correctIndex = q.correctIndex;
-
-            if (shouldShuffleOptions) {
-                const optionsWithMeta = options.map((opt, i) => ({
-                    text: opt,
-                    isCorrect: i === correctIndex,
-                }));
-                // Fisher-Yates shuffle
-                for (let i = optionsWithMeta.length - 1; i > 0; i--) {
-                    const j = Math.floor(Math.random() * (i + 1));
-                    [optionsWithMeta[i], optionsWithMeta[j]] = [
-                        optionsWithMeta[j],
-                        optionsWithMeta[i],
-                    ];
-                }
-                options = optionsWithMeta.map((o) => o.text);
-                correctIndex = optionsWithMeta.findIndex((o) => o.isCorrect);
-            }
-
-            return {
-                ...q,
-                options,
-                correctIndex,
-                userAnswer: undefined,
-                _localIndex: idx,
-                _instanceId: Math.random(),
-            };
-        });
-    };
-
-    useEffect(() => {
-        const fetchQuestions = async () => {
-            if (!subject) {
-                setActiveQuestionsCache([]);
-                return;
-            }
-            if (subject === "CUSTOM") {
-                setActiveQuestionsCache(
-                    prepareQuestionSet(customQuestions || []),
-                );
-                return;
-            }
-
-            setIsLoadingQuestions(true);
-            const minDelay = new Promise((resolve) => setTimeout(resolve, 500));
-
-            try {
-                const { data, error } =
-                    await fetchQuestionsLightweight(subject);
-                await minDelay;
-                if (error) throw error;
-                if (data && data.length > 0) {
-                    const mappedData = data.map((item) => ({
-                        ...item,
-                        correctIndex: item.correct_index,
-                        options: Array.isArray(item.options)
-                            ? item.options
-                            : [],
-                    }));
-                    setActiveQuestionsCache(prepareQuestionSet(mappedData));
-                } else {
-                    setActiveQuestionsCache([]);
-                }
-            } catch (err) {
-                console.error("Chyba p┼Öi stahov├ín├ş ot├ízek:", err);
-                alert("Nepoda┼Öilo se st├íhnout ot├ízky z cloudu.");
-                setActiveQuestionsCache([]);
-            } finally {
-                setIsLoadingQuestions(false);
-                setIsTransitioningSubject(false);
-            }
-        };
-        fetchQuestions();
-    }, [subject, customQuestions]);
-
-    // --- LOGIKA PRO OBNOVEN├Ź SMART RELACE ---
-    const checkSmartSession = () => {
-        const savedSession = profileData?.smart_session?.[subject];
-        if (savedSession && savedSession.ids && savedSession.ids.length > 0) {
-            // M├íme ulo┼żenou relaci, zept├íme se u┼żivatele
-            setShowResumePrompt(true);
-        } else {
-            // ┼Ż├ídn├í relace, otev┼Öeme nastaven├ş pro novou
-            setShowSmartSettings(true);
-        }
-    };
-
-    const resumeSmartSession = async () => {
-        setShowResumePrompt(false);
-        const savedSession = profileData?.smart_session?.[subject];
-        if (!savedSession) return;
-
-        setMode("loading");
-        setLoadingProgress(0);
-
-        const sessionIds = savedSession.ids;
-        const reorderedQuestions = [];
-
-        sessionIds.forEach((id) => {
-            const found = activeQuestionsCache.find((q) => q.number === id);
-            if (found) {
-                reorderedQuestions.push({
-                    ...found,
-                    _instanceId: Math.random(),
-                    userAnswer: undefined,
-                });
-            }
-        });
-
-        const startIndex = savedSession.index || 0;
-        const subsetToPreload = reorderedQuestions.slice(
-            startIndex,
-            startIndex + 5,
-        );
-        await preloadTestImages(subsetToPreload, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setQuestionSet(reorderedQuestions);
-        setCurrentIndex(startIndex);
-        setScore(savedSession.score || { correct: 0, total: 0 });
-
-        setReadyQuestionId(null);
-        setMode("smart");
-        setFinished(false);
-        setSelectedAnswer(null);
-        setShowResult(false);
-        setIsKeyboardMode(false);
-        setTrainingTime(0);
-        setCombo(0);
-    };
-
-    const startNewSmartSession = async (count) => {
-        setShowResumePrompt(false);
-        setShowSmartSettings(false);
-
-        // Pokud startujeme novou, sma┼żeme tu starou z cloudu
-        const currentSmartSessions = profileData?.smart_session || {};
-        const updatedSessions = { ...currentSmartSessions };
-        delete updatedSessions[subject];
-        saveData({ smart_session: updatedSessions });
-
-        let pool = activeQuestionsCache;
-        if (!pool || pool.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky nejsou k dispozici.");
-            return;
-        }
-
-        let shuffled = [...pool]
-            .sort(() => Math.random() - 0.5)
-            .map((q, idx) => ({
-                ...q,
-                _localIndex: idx,
-                _instanceId: Math.random(),
-            }));
-        if (count !== "all" && typeof count === "number")
-            shuffled = shuffled.slice(0, count);
-
-        // P┼Öedna─Ź├şt├ín├ş
-        setMode("loading");
-        setLoadingProgress(0);
-
-        const subsetToPreload = shuffled.slice(0, 5);
-        await preloadTestImages(subsetToPreload, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setReadyQuestionId(null);
-        setQuestionSet(shuffled);
-        setMode("smart");
-        setCurrentIndex(0);
-        setScore({ correct: 0, total: 0 });
-        setFinished(false);
-        setSelectedAnswer(null);
-        setShowResult(false);
-        setIsKeyboardMode(false);
-        setTrainingTime(0);
-        setCombo(0);
-
-        // Hned ulo┼ż├şme po─Ź├íte─Źn├ş stav
-        if (shuffled.length <= SMART_SAVE_LIMIT) {
-            persistSmartSession(shuffled, 0, { correct: 0, total: 0 });
-        }
-    };
-
-    // --- END SMART LOGIC ---
-
-    const startTestPractice = async (test) => {
-        const pool = activeQuestionsCache.filter(
-            (q) =>
-                q.number >= test.topic_range_start &&
-                q.number <= test.topic_range_end,
-        );
-        if (pool.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky v rozsahu.");
-            return;
-        }
-        const shuffled = [...pool]
-            .sort(() => Math.random() - 0.5)
-            .map((q, idx) => ({
-                ...q,
-                _localIndex: idx,
-                _instanceId: Math.random(),
-            }));
-
-        setMode("loading");
-        setLoadingProgress(0);
-
-        const subsetToPreload = shuffled.slice(0, 5);
-        await preloadTestImages(subsetToPreload, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setReadyQuestionId(null);
-        setQuestionSet(shuffled);
-        setMode("test_practice");
-        setActiveTest(test);
-        setCurrentIndex(0);
-        setScore({ correct: 0, total: 0 });
-        setFinished(false);
-        setSelectedAnswer(null);
-        setShowResult(false);
-        setCombo(0);
-    };
-
-    const confirmStartTest = async () => {
-        if (!testToStart) return;
-        setTestToStart(null);
-
-        const test = testToStart;
-        const pool = activeQuestionsCache.filter(
-            (q) =>
-                q.number >= test.topic_range_start &&
-                q.number <= test.topic_range_end,
-        );
-        const selected = [...pool]
-            .sort(() => Math.random() - 0.5)
-            .slice(0, test.question_count);
-        const prepared = prepareQuestionSet(selected, true);
-
-        setMode("loading");
-        setLoadingProgress(0);
-        await preloadTestImages(prepared, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setQuestionSet(prepared);
-        setActiveTest(test);
-        setReadyQuestionId(null);
-        setMode("real_test");
-    };
-
-    const startGradedTest = async (test) => {
-        const now = new Date();
-        if (!test.open_at || !test.close_at) {
-            alert("Tento test nem├í stanoven├Ż term├şn.");
-            return;
-        }
-        if (now < new Date(test.open_at)) {
-            alert("Test je┼ít─Ť nen├ş otev┼Öen.");
-            return;
-        }
-        if (now > new Date(test.close_at)) {
-            alert("Test je ji┼ż uzav┼Öen.");
-            return;
-        }
-        if (completedTestIds.includes(test.id)) {
-            alert("Tento test jste ji┼ż vypracovali.");
-            return;
-        }
-        setTestToStart(test);
-    };
-
-    const startRandomMode = async () => {
-        const pool = activeQuestionsCache;
-        if (!pool || pool.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky nejsou k dispozici.");
-            return;
-        }
-
-        setScore({ correct: 0, total: 0 });
-        setFinished(false);
-        setShowResult(false);
-        setSelectedAnswer(null);
-        setCurrentIndex(0);
-        setCombo(0);
-        setIsKeyboardMode(false);
-        setReadyQuestionId(null);
-
-        const shuffled = [...pool]
-            .sort(() => Math.random() - 0.5)
-            .map((q, idx) => ({
-                ...q,
-                _localIndex: idx,
-                _instanceId: Math.random(),
-            }));
-
-        setMode("loading");
-        setLoadingProgress(0);
-
-        const subsetToPreload = shuffled.slice(0, 5);
-        await preloadTestImages(subsetToPreload, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setQuestionSet(shuffled);
-        setMode("random");
-    };
-    const startMockTest = async () => {
-        const pool = activeQuestionsCache;
-        if (!pool || pool.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky nejsou k dispozici.");
-            return;
-        }
-
-        setScore({ correct: 0, total: 0 });
-        setFinished(false);
-        setShowResult(false);
-        setSelectedAnswer(null);
-        setCurrentIndex(0);
-        setMaxSeenIndex(0);
-        setCombo(0);
-        setIsKeyboardMode(false);
-        setReadyQuestionId(null);
-
-        const sel = [...pool]
-            .sort(() => Math.random() - 0.5)
-            .slice(0, Math.min(40, pool.length));
-        const prepared = prepareQuestionSet(sel, true);
-
-        setMode("loading");
-        setLoadingProgress(0);
-        await preloadTestImages(prepared, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setQuestionSet(prepared);
-        setTimeLeft(1800);
-        setMode("mock");
-    };
-    const startMistakesMode = async () => {
-        const all = activeQuestionsCache;
-        if (!all || all.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky nejsou k dispozici.");
-            return;
-        }
-        const userMistakes = mistakes[subject] || [];
-        const filtered = all.filter((q) => userMistakes.includes(q.number));
-        if (filtered.length === 0) {
-            setMode("no_mistakes");
-            return;
-        }
-
-        const shuffled = [...filtered]
-            .sort(() => Math.random() - 0.5)
-            .map((q, idx) => ({
-                ...q,
-                _localIndex: idx,
-                _instanceId: Math.random(),
-            }));
-
-        setMode("loading");
-        setLoadingProgress(0);
-
-        const subsetToPreload = shuffled.slice(0, 5);
-        await preloadTestImages(subsetToPreload, (progress) => {
-            setLoadingProgress(progress);
-        });
-
-        setReadyQuestionId(null);
-        setQuestionSet(shuffled);
-        setMode("mistakes");
-        setCurrentIndex(0);
-        setScore({ correct: 0, total: 0 });
-        setFinished(false);
-        setSelectedAnswer(null);
-        setShowResult(false);
-        setIsKeyboardMode(false);
-        setTrainingTime(0);
-        setCombo(0);
-    };
-
-    const startReviewMode = () => {
-        const all = activeQuestionsCache;
-        if (!all || all.length === 0) {
-            alert("┼Ż├ídn├ę ot├ízky nejsou k dispozici.");
-            return;
-        }
-        setQuestionSet(all);
-        setMode("review");
-        setCombo(0);
-        setReviewPage(0);
-        setSearchTerm("");
-    };
-
-    const addMistake = (qNumber) =>
-        updateMistakes((prev) => {
-            const cur = prev[subject] || [];
-            return !cur.includes(qNumber)
-                ? { ...prev, [subject]: [...cur, qNumber] }
-                : prev;
-        });
-    const removeMistake = (qNumber) =>
-        updateMistakes((prev) => {
-            const cur = prev[subject] || [];
-            return cur.includes(qNumber)
-                ? { ...prev, [subject]: cur.filter((n) => n !== qNumber) }
-                : prev;
-        });
-    const clearMistakes = () => {
-        updateMistakes((prev) => ({ ...prev, [subject]: [] }));
-        setShowClearMistakesConfirm(false);
-    };
-    const handleSelectSubject = (subj) => {
-        if (subj === "CUSTOM") {
-            setShowCustomImport(true);
-            return;
-        }
-        setIsTransitioningSubject(true);
-        setSubject(subj.toUpperCase());
-        setMenuSelection(0);
-        setMode(null);
-    };
-    const handleStartMode = (startFn, modeName) => {
-        if (modeName === "smart") {
-            checkSmartSession();
-            return;
-        }
-        startFn();
-    };
-
-    const shuffleArray = (list) => {
-        const arr = [...list];
-        for (let i = arr.length - 1; i > 0; i -= 1) {
-            const j = Math.floor(Math.random() * (i + 1));
-            [arr[i], arr[j]] = [arr[j], arr[i]];
-        }
-        return arr;
-    };
-
-    const getDuelOpponent = (match) => {
-        if (!match) return null;
-        const isChallenger = match.challenger_id === dbId;
-        return {
-            id: isChallenger ? match.opponent_id : match.challenger_id,
-            username: isChallenger ? match.opponent_name : match.challenger_name,
-        };
-    };
-
-    const getDuelEligibleQuestions = () => {
-        if (!activeQuestionsCache || activeQuestionsCache.length === 0)
-            return [];
-        if (duelSettings.rangeMode === "all") return activeQuestionsCache;
-
-        const start = Number.parseInt(duelSettings.rangeStart, 10);
-        const end = Number.parseInt(duelSettings.rangeEnd, 10);
-        if (!Number.isFinite(start) || !Number.isFinite(end)) return [];
-        const from = Math.min(start, end);
-        const to = Math.max(start, end);
-        return activeQuestionsCache.filter(
-            (q) => q.number >= from && q.number <= to,
-        );
-    };
-
-    const validateDuelSettings = () => {
-        if (!subject) return "Nejdriv vyber predmet.";
-        const eligible = getDuelEligibleQuestions();
-        const allowedCounts = [2, 10, 20, 50];
-        if (!allowedCounts.includes(duelSettings.questionCount)) {
-            return "Vyber povoleny pocet otazek.";
-        }
-        if (eligible.length < duelSettings.questionCount) {
-            return "V rozsahu neni dost otazek pro zvoleny pocet.";
-        }
-        return "";
-    };
-
-    const createDuelMatch = async (opponent) => {
-        const validation = validateDuelSettings();
-        if (validation) {
-            setDuelError(validation);
-            return;
-        }
-
-        const eligible = getDuelEligibleQuestions();
-        const selectedQuestions = shuffleArray(eligible).slice(
-            0,
-            duelSettings.questionCount,
-        );
-        const questionIds = selectedQuestions.map((q) => q.id);
-
-        const payload = {
-            challenger_id: dbId,
-            opponent_id: opponent.id,
-            challenger_name: user,
-            opponent_name: opponent.username,
-            subject,
-            question_count: duelSettings.questionCount,
-            range_mode: duelSettings.rangeMode,
-            range_start:
-                duelSettings.rangeMode === "range"
-                    ? Number.parseInt(duelSettings.rangeStart, 10)
-                    : null,
-            range_end:
-                duelSettings.rangeMode === "range"
-                    ? Number.parseInt(duelSettings.rangeEnd, 10)
-                    : null,
-            question_ids: questionIds,
-            status: "pending",
-        };
-
-        const { data, error } = await supabase
-            .from("duel_matches")
-            .insert([payload])
-            .select()
-            .single();
-
-        if (error) {
-            console.error("Chyba pri vytvoreni duelu:", error);
-            setDuelError("Nepodarilo se vytvorit duel.");
-            return;
-        }
-
-        setDuelOutgoingMatch(data);
-        setDuelError("");
-        setMode("duel");
-    };
-
-    const acceptDuelInvite = async (invite) => {
-        const startAt = new Date().toISOString();
-        const { data, error } = await supabase
-            .from("duel_matches")
-            .update({
-                status: "active",
-                accepted_at: startAt,
-                started_at: startAt,
-            })
-            .eq("id", invite.id)
-            .eq("status", "pending")
-            .select()
-            .single();
-
-        if (error || !data) {
-            console.error("Chyba pri prijeti duelu:", error);
-            return;
-        }
-
-        setDuelInviteToShow(null);
-        setDuelInvites((prev) => prev.filter((i) => i.id !== invite.id));
-        setDuelOutgoingMatch(null);
-        setDuelActiveMatch(data);
-        duelFinalizeRef.current = false;
-        if (subject !== data.subject) setSubject(data.subject);
-        setMode("duel_match");
-    };
-
-    const declineDuelInvite = async (invite) => {
-        await supabase
-            .from("duel_matches")
-            .update({ status: "declined" })
-            .eq("id", invite.id);
-        setDuelInvites((prev) => prev.filter((i) => i.id !== invite.id));
-        setDuelInviteToShow(null);
-    };
-
-    const cancelOutgoingDuel = async () => {
-        if (!duelOutgoingMatch) return;
-        await supabase
-            .from("duel_matches")
-            .update({ status: "cancelled" })
-            .eq("id", duelOutgoingMatch.id);
-        setDuelOutgoingMatch(null);
-    };
-
-    const calibrateDuelClock = async (matchId) => {
-        const clientStart = Date.now();
-        const { data, error } = await supabase
-            .from("duel_matches")
-            .select("created_at")
-            .eq("id", matchId)
-            .single();
-
-        if (error || !data?.created_at) {
-            setDuelClockOffsetMs(0);
-            return;
-        }
-
-        const clientEnd = Date.now();
-        const serverTime = new Date(data.created_at).getTime();
-        const latency = (clientEnd - clientStart) / 2;
-        const approxServerNow = serverTime + latency;
-        setDuelClockOffsetMs(approxServerNow - clientEnd);
-    };
-
-    const getDuelProgress = (match, now) => {
-        if (!match?.started_at) {
-            return { index: 0, phase: "waiting", timeLeft: 0 };
-        }
-
-        const questionCount = match.question_count || 0;
-        let questionStart = new Date(match.started_at).getTime();
-
-        for (let i = 0; i < questionCount; i += 1) {
-            const answersForQuestion = duelAnswers
-                .filter((answer) => answer.question_index === i)
-                .map((answer) => new Date(answer.answered_at).getTime())
-                .filter(Number.isFinite)
-                .sort((a, b) => a - b);
-
-            const firstAnswerAt = answersForQuestion[0] ?? null;
-            const secondAnswerAt = answersForQuestion[1] ?? null;
-
-            let answerDeadline =
-                questionStart + DUEL_ANSWER_SECONDS * 1000;
-            if (
-                firstAnswerAt &&
-                firstAnswerAt + DUEL_RUSH_SECONDS * 1000 < answerDeadline
-            ) {
-                answerDeadline = firstAnswerAt + DUEL_RUSH_SECONDS * 1000;
-            }
-
-            let answerPhaseEnd = answerDeadline;
-            if (secondAnswerAt && secondAnswerAt < answerPhaseEnd) {
-                answerPhaseEnd = secondAnswerAt;
-            }
-
-            if (now < answerPhaseEnd) {
-                return {
-                    index: i,
-                    phase: "answer",
-                    timeLeft: Math.max(
-                        0,
-                        Math.ceil((answerPhaseEnd - now) / 1000),
-                    ),
-                    answerEndsAt: answerPhaseEnd,
-                    questionStartsAt: questionStart,
-                };
-            }
-
-            const resultEndsAt =
-                answerPhaseEnd + DUEL_RESULT_SECONDS * 1000;
-            if (now < resultEndsAt) {
-                return {
-                    index: i,
-                    phase: "result",
-                    timeLeft: Math.max(
-                        0,
-                        Math.ceil((resultEndsAt - now) / 1000),
-                    ),
-                    answerEndsAt: answerPhaseEnd,
-                    resultEndsAt,
-                    questionStartsAt: questionStart,
-                };
-            }
-
-            questionStart = resultEndsAt;
-        }
-
-        return { index: questionCount, phase: "finished", timeLeft: 0 };
-    };
-
-    const getAnswerFor = (userId, questionIndex) =>
-        duelAnswers.find(
-            (answer) =>
-                answer.user_id === userId &&
-                answer.question_index === questionIndex,
-        );
-
-    const submitDuelAnswer = async (answerIndex) => {
-        if (!duelActiveMatch || !dbId) return;
-        const progress = getDuelProgress(duelActiveMatch, duelClock);
-        if (progress.phase !== "answer") return;
-        const questionIndex = progress.index;
-        const existing = getAnswerFor(dbId, questionIndex);
-        if (existing) return;
-
-        setDuelLocalAnswers((prev) => ({
-            ...prev,
-            [questionIndex]: answerIndex,
-        }));
-
-        const { error } = await supabase.from("duel_answers").insert([
-            {
-                match_id: duelActiveMatch.id,
-                user_id: dbId,
-                question_index: questionIndex,
-                answer_index: answerIndex,
-            },
-        ]);
-
-        if (error) {
-            console.error("Chyba pri ukladani odpovedi:", error);
-            setDuelLocalAnswers((prev) => {
-                const next = { ...prev };
-                delete next[questionIndex];
-                return next;
-            });
-        }
-    };
-
-    const computeDuelScore = () => {
-        if (!duelActiveMatch) return { myScore: 0, opponentScore: 0 };
-        const opponent = getDuelOpponent(duelActiveMatch);
-        if (!opponent) return { myScore: 0, opponentScore: 0 };
-        let myScore = 0;
-        let opponentScore = 0;
-
-        for (let i = 0; i < duelActiveMatch.question_count; i += 1) {
-            const question = duelQuestionSet[i];
-            if (!question) continue;
-
-            const myAnswer = getAnswerFor(dbId, i);
-            const opponentAnswer = getAnswerFor(opponent.id, i);
-
-            const myCorrect =
-                myAnswer && myAnswer.answer_index === question.correctIndex;
-            const opponentCorrect =
-                opponentAnswer &&
-                opponentAnswer.answer_index === question.correctIndex;
-
-            if (myCorrect && opponentCorrect) {
-                const myTime = new Date(myAnswer.answered_at).getTime();
-                const opponentTime = new Date(
-                    opponentAnswer.answered_at,
-                ).getTime();
-                if (myTime < opponentTime) myScore += 1;
-                else if (opponentTime < myTime) opponentScore += 1;
-                else {
-                    myScore += 1;
-                    opponentScore += 1;
-                }
-            } else if (myCorrect) {
-                myScore += 1;
-            } else if (opponentCorrect) {
-                opponentScore += 1;
-            }
-        }
-
-        return { myScore, opponentScore };
-    };
-
-    const applyDuelTrophies = async (
-        myScore,
-        opponentScore,
-        questionCount,
-        opponentId,
-    ) => {
-        const multiplier = Math.max(1, questionCount / 5);
-        const isDraw = myScore === opponentScore;
-        const myWin = myScore > opponentScore;
-        const opponentWin = opponentScore > myScore;
-
-        let myDelta = 0;
-        let opponentDelta = 0;
-        let myWins = 0;
-        let myLosses = 0;
-        let myDraws = 0;
-        let opponentWins = 0;
-        let opponentLosses = 0;
-        let opponentDraws = 0;
-
-        if (isDraw) {
-            myDelta = 3 * multiplier;
-            opponentDelta = 3 * multiplier;
-            myDraws = 1;
-            opponentDraws = 1;
-        } else if (myWin) {
-            myDelta = 5 * multiplier;
-            opponentDelta = -2 * multiplier;
-            myWins = 1;
-            opponentLosses = 1;
-        } else if (opponentWin) {
-            myDelta = -2 * multiplier;
-            opponentDelta = 5 * multiplier;
-            myLosses = 1;
-            opponentWins = 1;
-        }
-
-        const { data: stats } = await supabase
-            .from("duel_stats")
-            .select("*")
-            .in("user_id", [dbId, opponentId]);
-
-        const statsById = new Map(
-            (stats || []).map((entry) => [entry.user_id, entry]),
-        );
-
-        const myStats = statsById.get(dbId) || {};
-        const opponentStats = statsById.get(opponentId) || {};
-
-        const payload = [
-            {
-                user_id: dbId,
-                trophies: (myStats.trophies || 0) + myDelta,
-                wins: (myStats.wins || 0) + myWins,
-                losses: (myStats.losses || 0) + myLosses,
-                draws: (myStats.draws || 0) + myDraws,
-                updated_at: new Date().toISOString(),
-            },
-            {
-                user_id: opponentId,
-                trophies: (opponentStats.trophies || 0) + opponentDelta,
-                wins: (opponentStats.wins || 0) + opponentWins,
-                losses: (opponentStats.losses || 0) + opponentLosses,
-                draws: (opponentStats.draws || 0) + opponentDraws,
-                updated_at: new Date().toISOString(),
-            },
-        ];
-
-        await supabase.from("duel_stats").upsert(payload, {
-            onConflict: "user_id",
-        });
-
-        const { data: refreshed } = await supabase
-            .from("duel_stats")
-            .select("*")
-            .eq("user_id", dbId)
-            .maybeSingle();
-        if (refreshed) setDuelStats(refreshed);
-    };
-
-    const finalizeDuelMatch = async () => {
-        if (!duelActiveMatch || duelFinalizeRef.current) return;
-        duelFinalizeRef.current = true;
-
-        const opponent = getDuelOpponent(duelActiveMatch);
-        if (!opponent) return;
-
-        const { myScore, opponentScore } = computeDuelScore();
-        const challengerScore =
-            duelActiveMatch.challenger_id === dbId
-                ? myScore
-                : opponentScore;
-        const opponentScoreValue =
-            duelActiveMatch.challenger_id === dbId
-                ? opponentScore
-                : myScore;
-
-        let winnerId = null;
-        if (myScore > opponentScore) winnerId = dbId;
-        if (opponentScore > myScore) winnerId = opponent.id;
-
-        const { data } = await supabase
-            .from("duel_matches")
-            .update({
-                status: "completed",
-                completed_at: new Date().toISOString(),
-                challenger_score: challengerScore,
-                opponent_score: opponentScoreValue,
-                winner_id: winnerId,
-                result_finalized: true,
-            })
-            .eq("id", duelActiveMatch.id)
-            .eq("result_finalized", false)
-            .select("id");
-
-        if (data && data.length > 0) {
-            await applyDuelTrophies(
-                myScore,
-                opponentScore,
-                duelActiveMatch.question_count,
-                opponent.id,
-            );
-        }
-    };
-
-    const handleReportClick = (questionNumber) => {
-        setQuestionToReport(questionNumber);
-        setReportModalOpen(true);
-    };
-
-    const [visualSelection, setVisualSelection] = useState(null);
-    const [shuffledMapping, setShuffledMapping] = useState([]);
-
-    useEffect(() => {
-        const updateHeight = () => {
-            const vh = window.innerHeight * 0.01;
-            document.documentElement.style.setProperty("--vh", `${vh}px`);
-        };
-        updateHeight();
-        window.addEventListener("resize", updateHeight);
-        window.addEventListener("orientationchange", updateHeight);
-        return () => {
-            window.removeEventListener("resize", updateHeight);
-            window.removeEventListener("orientationchange", updateHeight);
-        };
-    }, []);
-
-    useEffect(() => {
-        window.setShuffledMappingForKeyboard = (mapping) => {
-            setShuffledMapping(mapping);
-            setVisualSelection(null);
-        };
-        return () => delete window.setShuffledMappingForKeyboard;
-    }, []);
-
-    const handleAnswer = async (idx) => {
-        if (finished || mode === "review") return;
-        setIsKeyboardMode(true);
-        document.body.classList.add("keyboard-mode-active");
-
-        setQuestionSet((prev) => {
-            const c = [...prev];
-            if (c[currentIndex])
-                c[currentIndex] = { ...c[currentIndex], userAnswer: idx };
-            return c;
-        });
-        if (idx !== questionSet[currentIndex].correctIndex) {
-            triggerHaptic("error");
-            addMistake(questionSet[currentIndex].number);
-        } else {
-            triggerHaptic("success");
-            triggerFakeSync();
-        }
-
-        // --- OKAM┼ŻIT├ë ULO┼ŻEN├Ź PRO SMART RE┼ŻIM (MANU├üLN├Ź KLIK) ---
-        if (mode === "smart" && questionSet.length <= SMART_SAVE_LIMIT) {
-            const nextSet = [...questionSet];
-            if (nextSet[currentIndex])
-                nextSet[currentIndex] = {
-                    ...nextSet[currentIndex],
-                    userAnswer: idx,
-                };
-            persistSmartSession(nextSet, currentIndex, score);
-        }
-    };
-
-    const clickFlashcardAnswer = (idx) => {
-        if (finished || showResult) return;
-        if (idx === null) return;
-        const currentQ = questionSet[currentIndex];
-        const isCorrect = idx === currentQ.correctIndex;
-        const newSet = [...questionSet];
-        if (newSet[currentIndex])
-            newSet[currentIndex] = { ...newSet[currentIndex], userAnswer: idx };
-        setQuestionSet(newSet);
-        setSelectedAnswer(idx);
-        setShowResult(true);
-        setSessionQuestionsCount((prev) => prev + 1);
-        setVisualSelection(null);
-
-        if (mode === "test_practice" && activeTest) {
-            const currentStats = testPracticeStats[activeTest.id] || [];
-            const newStats = [...currentStats, isCorrect].slice(-20);
-            saveDataToCloud(undefined, undefined, 0, 0, {
-                ...testPracticeStats,
-                [activeTest.id]: newStats,
-            });
-        }
-
-        // Vypo─Ź├şt├íme nov├ę sk├│re pro ulo┼żen├ş
-        let nextScore = { ...score };
-
-        if (isCorrect) {
-            triggerHaptic("success");
-            nextScore.correct += 1;
-            nextScore.total += 1;
-            setScore(nextScore);
-            setCombo((c) => c + 1);
-            if (mode === "mistakes") removeMistake(currentQ.number);
-            else triggerFakeSync();
-        } else {
-            triggerHaptic("error");
-            nextScore.total += 1;
-            setScore(nextScore);
-            addMistake(currentQ.number);
-            if (combo >= 3) {
-                setShake(true);
-                setTimeout(() => setShake(false), 500);
-            }
-            setCombo(0);
-        }
-
-        // --- OKAM┼ŻIT├ë ULO┼ŻEN├Ź PRO SMART RE┼ŻIM (FLASHCARD) ---
-        if (mode === "smart" && questionSet.length <= SMART_SAVE_LIMIT) {
-            persistSmartSession(newSet, currentIndex, nextScore);
-        }
-    };
-
-    // --- FUNKCE PRO P┼śECHOD NA DAL┼á├Ź OT├üZKU ---
-    const nextFlashcardQuestion = () => {
-        if (mode === "random" || mode === "test_practice") {
-            if (currentIndex >= questionSet.length - 1) setFinished(true);
-            else {
-                setCurrentIndex((prev) => prev + 1);
-                setSelectedAnswer(null);
-                setShowResult(false);
-            }
-        } else if (mode === "smart" || mode === "mistakes") {
-            const currentQ = questionSet[0];
-            const isCorrect = selectedAnswer === currentQ.correctIndex;
-            let newSet = [...questionSet];
-            if (isCorrect) newSet.shift();
-            else {
-                let qToMove = newSet.shift();
-
-                const optionsWithMeta = qToMove.options.map((opt, i) => ({
-                    text: opt,
-                    isCorrect: i === qToMove.correctIndex,
-                }));
-
-                for (let i = optionsWithMeta.length - 1; i > 0; i--) {
-                    const j = Math.floor(Math.random() * (i + 1));
-                    [optionsWithMeta[i], optionsWithMeta[j]] = [
-                        optionsWithMeta[j],
-                        optionsWithMeta[i],
-                    ];
-                }
-
-                qToMove = {
-                    ...qToMove,
-                    options: optionsWithMeta.map((o) => o.text),
-                    correctIndex: optionsWithMeta.findIndex((o) => o.isCorrect),
-                    userAnswer: undefined,
-                    _instanceId: Math.random(),
-                };
-
-                newSet.splice(
-                    Math.min(newSet.length, 3 + Math.floor(Math.random() * 3)),
-                    0,
-                    qToMove,
-                );
-            }
-
-            if (newSet.length === 0) {
-                setFinished(true);
-                addToHistory(score);
-                clearSmartSession(); // Smazat session p┼Öi dokon─Źen├ş
-            } else {
-                setQuestionSet(newSet);
-                setSelectedAnswer(null);
-                setShowResult(false);
-
-                // Fix scrollu
-                if (containerRef.current) {
-                    containerRef.current.scrollTop = 0;
-                }
-                window.scrollTo({ top: 0, behavior: "instant" });
-            }
-        }
-    };
-
-    // ... (zbytek funkc├ş z┼»st├ív├í stejn├Ż)
-
-    const confirmFlashcardAnswer = () => {
-        if (!finished && !showResult)
-            clickFlashcardAnswer(selectedAnswer !== null ? selectedAnswer : -1);
-    };
-    const selectRandomAnswer = (idx) => {
-        if (!finished && !showResult) {
-            triggerHaptic("light");
-            setVisualSelection(idx);
-            setIsKeyboardMode(true);
-            document.body.classList.add("keyboard-mode-active");
-        }
-    };
-    const clearAnswer = () => {
-        setQuestionSet((prev) => {
-            const c = [...prev];
-            if (c[currentIndex])
-                c[currentIndex] = { ...c[currentIndex], userAnswer: undefined };
-            return c;
-        });
-        setSelectedAnswer(null);
-        setShowResult(false);
-    };
-
-    const moveToQuestion = (newIdx) => {
-        const b = Math.max(0, Math.min(newIdx, questionSet.length - 1));
-        if (b < currentIndex) setDirection("left");
-        else setDirection("right");
-
-        // Reset content ready state synchronously
-        setReadyQuestionId(null);
-        setCurrentIndex(b);
-        setSelectedAnswer(null);
-    };
-
-    const handleSwipe = (dir) => {
-        if (
-            finished ||
-            showConfirmExit ||
-            showConfirmSubmit ||
-            exitDirection ||
-            isSessionBlocked
-        )
-            return;
-
-        const isFlashcard = isFlashcardStyle(mode) || mode === "test_practice";
-
-        const performAction = () => {
-            if (dir === "left") {
-                if (isFlashcard) {
-                    if (showResult) nextFlashcardQuestion();
-                    else if (selectedAnswer !== null) confirmFlashcardAnswer();
-                } else if (currentIndex < questionSet.length - 1) {
-                    moveToQuestion(currentIndex + 1);
-                }
-            } else if (dir === "right") {
-                if (!isFlashcard && currentIndex > 0) {
-                    moveToQuestion(currentIndex - 1);
-                }
-            }
-        };
-
-        if (isFlashcard) {
-            performAction();
-        } else {
-            setExitDirection(dir);
-            setTimeout(() => {
-                performAction();
-                setExitDirection(null);
-            }, 80);
-        }
-    };
-
-    const submitTest = () => {
-        const qEval = questionSet;
-        const cor = qEval.filter((q) => q.userAnswer === q.correctIndex).length;
-        const finalScore = { correct: cor, total: qEval.length };
-        const answeredCount = qEval.filter(
-            (q) => q.userAnswer !== undefined,
-        ).length;
-        setSessionQuestionsCount((prev) => prev + answeredCount);
-        setScore(finalScore);
-        setTimeLeftAtSubmit(timeLeft);
-        setFinished(true);
-        setShowConfirmSubmit(false);
-        addToHistory(finalScore);
-    };
-    const addToHistory = (s) => {
-        if (mode !== "mock") return;
-        const newRec = {
-            date: new Date().toISOString(),
-            mode: mode,
-            score: s,
-            subject: subject,
-            id: Date.now() + "-" + Math.random(),
-        };
-        updateHistory((prev) => [...prev, newRec]);
-    };
-    const tryReturnToMenu = () => {
-        if (mode === "test_practice") {
-            setMode("scheduled_list");
-            setCombo(0);
-            setShowResult(false);
-            setSelectedAnswer(null);
-            setVisualSelection(null);
-            setShuffledMapping([]);
-            setMenuSelection(1);
-            setActiveTest(null);
-            return;
-        }
-
-        // --- UPRAVEN├ü LOGIKA PRO SMART MODE (Exit Prompt) ---
-        if (
-            mode === "smart" &&
-            !finished &&
-            questionSet.length <= SMART_SAVE_LIMIT
-        ) {
-            setShowSaveProgressPrompt(true);
-            return;
-        }
-
-        if (mode === "mock" && !finished) {
-            setShowConfirmExit(true);
-        } else {
-            setMode(null);
-            setCombo(0);
-            setShowResult(false);
-            setSelectedAnswer(null);
-            setVisualSelection(null);
-            setShuffledMapping([]);
-            setMenuSelection(0);
-        }
-    };
-
-    const confirmExit = () => {
-        setShowConfirmExit(false);
-        const wasPractice = mode === "test_practice";
-        setMode(wasPractice ? "scheduled_list" : null);
-        setCombo(0);
-        setShowResult(false);
-        setSelectedAnswer(null);
-        setVisualSelection(null);
-        setShuffledMapping([]);
-        setMenuSelection(wasPractice ? 1 : 0);
-        if (wasPractice) setActiveTest(null);
-    };
-
-    const handleSaveAndExit = async (shouldSave) => {
-        setShowSaveProgressPrompt(false);
-        if (!shouldSave) {
-            // Pokud nechce ulo┼żit, sma┼żeme session
-            const currentSmartSessions = profileData?.smart_session || {};
-            const updatedSessions = { ...currentSmartSessions };
-            delete updatedSessions[subject];
-            await saveData({ smart_session: updatedSessions });
-        }
-
-        setMode(null);
-        setCombo(0);
-        setShowResult(false);
-        setSelectedAnswer(null);
-        setMenuSelection(0);
-    };
-
-    const handleFileUpload = (questions) => {
-        if (!questions) return;
-        const norm = questions.map((q, i) => ({
-            number: q.number ?? i + 1,
-            question: q.question ?? `Ot├ízka ${i + 1}`,
-            options: q.options || [],
-            correctIndex: q.correctIndex ?? 0,
-        }));
-        setCustomQuestions(norm);
-        setSubject("CUSTOM");
-    };
-
-    useEffect(() => {
-        const handleKeyDown = (e) => {
-            if (isSessionBlocked) return;
-            if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
-                return;
-            if (e.repeat) return;
-            if (
-                (e.key === "Enter" || e.key === " ") &&
-                e.target.tagName === "BUTTON"
-            )
-                return;
-
-            if (!isKeyboardMode) {
-                setIsKeyboardMode(true);
-                document.body.classList.add("keyboard-mode-active");
-            }
-            if (
-                [
-                    "ArrowUp",
-                    "ArrowDown",
-                    "ArrowLeft",
-                    "ArrowRight",
-                    " ",
-                    "f",
-                    "F",
-                ].includes(e.key)
-            )
-                e.preventDefault();
-            if (
-                showConfirmExit ||
-                showConfirmSubmit ||
-                showSmartSettings ||
-                showClearMistakesConfirm ||
-                recordToDelete ||
-                reportModalOpen ||
-                testToStart ||
-                showResumePrompt ||
-                showSaveProgressPrompt
-            ) {
-                if (e.key === "Escape") {
-                    setShowConfirmExit(false);
-                    setShowConfirmSubmit(false);
-                    setShowSmartSettings(false);
-                    setShowClearMistakesConfirm(false);
-                    setRecordToDelete(null);
-                    setReportModalOpen(false);
-                    setTestToStart(null);
-                    setShowResumePrompt(false);
-                    setShowSaveProgressPrompt(false);
-                    return;
-                }
-                if (e.key === "Enter") {
-                    if (showConfirmExit) tryReturnToMenu();
-                    if (showConfirmSubmit) submitTest();
-                    if (showClearMistakesConfirm) clearMistakes();
-                    if (recordToDelete) handleDeleteRecordConfirm();
-                    if (testToStart) confirmStartTest();
-                    if (showResumePrompt) resumeSmartSession();
-                    if (showSaveProgressPrompt) handleSaveAndExit(true);
-                    return;
-                }
-                return;
-            }
-
-            if (e.key === "f" || e.key === "F") {
-                if (fullscreenImage) setFullscreenImage(null);
-                return;
-            }
-            if (fullscreenImage) {
-                if (
-                    e.key === "Escape" ||
-                    e.key === "f" ||
-                    e.key === "F" ||
-                    e.key === "Enter"
-                )
-                    setFullscreenImage(null);
-                return;
-            }
-            if (finished || mode === "no_mistakes") {
-                if (
-                    [
-                        "Backspace",
-                        "Enter",
-                        "ArrowLeft",
-                        "a",
-                        "A",
-                        "Escape",
-                    ].includes(e.key)
-                ) {
-                    setMode(null);
-                    setMenuSelection(0);
-                }
-                return;
-            }
-
-            if (!mode) {
-                const k = e.key.toLowerCase();
-                if (!subject) {
-                    const subjectCount = 3;
-                    if (k === "w" || k === "arrowup")
-                        setMenuSelection(
-                            (p) => (p - 1 + subjectCount) % subjectCount,
-                        );
-                    else if (k === "s" || k === "arrowdown")
-                        setMenuSelection((p) => (p + 1) % subjectCount);
-                    else if (
-                        k === "d" ||
-                        k === "arrowright" ||
-                        e.key === "Enter" ||
-                        e.key === " "
-                    ) {
-                        const subjects = ["sps", "stt", "CUSTOM"];
-                        handleSelectSubject(subjects[menuSelection]);
-                    }
-                    return;
-                }
-                const hasScheduled = scheduledTests.length > 0;
-                const menuMapping = [];
-                const modeCount = 9;
-                const getNextIndex = (current, dir) => {
-                    let next = current;
-                    let safety = 0;
-                    do {
-                        next = (next + dir + modeCount) % modeCount;
-                        safety++;
-                        const isVisible =
-                            next === 0 ||
-                            (next === 1 && hasScheduled) ||
-                            next === 2 ||
-                            next === 3 ||
-                            next === 4 ||
-                            next === 5 ||
-                            (next === 6 && isTeacher) ||
-                            next === 7 ||
-                            next === 8;
-                        if (isVisible) return next;
-                    } while (safety < 20);
-                    return next;
-                };
-
-                if (k === "w" || k === "arrowup")
-                    setMenuSelection((p) => getNextIndex(p, -1));
-                else if (k === "s" || k === "arrowdown")
-                    setMenuSelection((p) => getNextIndex(p, 1));
-                else if (k === "a" || k === "arrowleft") {
-                    if (subject) setSubject(null);
-                } else if (
-                    k === "d" ||
-                    k === "arrowright" ||
-                    e.key === "Enter"
-                ) {
-                    if (!subject) {
-                        if (menuSelection === 0) handleSelectSubject("SPS");
-                        else if (menuSelection === 1)
-                            handleSelectSubject("STT");
-                        else if (menuSelection === 2)
-                            document
-                                .querySelector("input[type='file']")
-                                ?.click();
-                        else if (menuSelection === 3 && user === "admin")
-                            setMode("admin");
-                    } else {
-                        let selection = menuSelection % modeCount;
-                        if (selection < 0) selection += modeCount;
-                        if (selection === 0)
-                            handleStartMode(startMockTest, "mock");
-                        else if (selection === 1 && hasScheduled)
-                            setMode("scheduled_list");
-                        else if (selection === 2)
-                            handleStartMode(startNewSmartSession, "smart");
-                        else if (selection === 3)
-                            handleStartMode(startRandomMode, "random");
-                        else if (selection === 4) setMode("duel");
-                        else if (selection === 5)
-                            handleStartMode(startReviewMode, "review");
-                        else if (selection === 6) {
-                            if (isTeacher) setMode("teacher_manager");
-                        } else if (selection === 7)
-                            handleStartMode(startMistakesMode, "mistakes");
-                        else if (selection === 8) openHistoryWithRefresh();
-                    }
-                } else if (
-                    k === "a" ||
-                    k === "arrowleft" ||
-                    k === "backspace"
-                ) {
-                    if (subject) setSubject(null);
-                }
-                return;
-            }
-            if (mode === "duel" || mode === "duel_match") return;
-            if (!mode || mode === "real_test") return;
-            const opts = questionSet[currentIndex]?.options?.length || 4;
-            const isFlashcardInput =
-                isFlashcardStyle(mode) || mode === "test_practice";
-            const k = e.key.toLowerCase();
-
-            if (k === "w" || e.key === "ArrowUp") {
-                if (isFlashcardInput && !showResult) {
-                    const nextVisual =
-                        visualSelection === null
-                            ? opts - 1
-                            : (visualSelection - 1 + opts) % opts;
-                    selectRandomAnswer(nextVisual);
-                } else if (!isFlashcardInput)
-                    handleAnswer(
-                        questionSet[currentIndex].userAnswer === undefined
-                            ? opts - 1
-                            : (questionSet[currentIndex].userAnswer -
-                                  1 +
-                                  opts) %
-                                  opts,
-                    );
-            }
-            if (k === "s" || e.key === "ArrowDown") {
-                if (isFlashcardInput && !showResult) {
-                    const nextVisual =
-                        visualSelection === null
-                            ? 0
-                            : (visualSelection + 1) % opts;
-                    selectRandomAnswer(nextVisual);
-                } else if (!isFlashcardInput)
-                    handleAnswer(
-                        questionSet[currentIndex].userAnswer === undefined
-                            ? 0
-                            : (questionSet[currentIndex].userAnswer + 1) % opts,
-                    );
-            }
-            if (k === "a" || e.key === "ArrowLeft") {
-                if (isFlashcardInput) return;
-                if (mode === "history") {
-                    setMode(null);
-                    return;
-                }
-                if (currentIndex > 0) moveToQuestion(currentIndex - 1);
-            }
-            if (k === "d" || e.key === "ArrowRight" || e.key === "Enter") {
-                if (mode === "history") return;
-                if (isFlashcardInput) {
-                    if (showResult) nextFlashcardQuestion();
-                    else {
-                        const finalIdx =
-                            visualSelection !== null
-                                ? (shuffledMapping[visualSelection] ??
-                                  selectedAnswer)
-                                : selectedAnswer;
-                        clickFlashcardAnswer(finalIdx);
-                    }
-                } else if (currentIndex < questionSet.length - 1) {
-                    moveToQuestion(currentIndex + 1);
-                }
-            }
-            if (e.key === " ") {
-                if (mode === "history") return;
-                if (isFlashcardInput && !showResult) {
-                    const finalIdx =
-                        visualSelection !== null
-                            ? (shuffledMapping[visualSelection] ??
-                              selectedAnswer)
-                            : selectedAnswer;
-                    clickFlashcardAnswer(finalIdx);
-                } else if (!finished && mode === "mock")
-                    setShowConfirmSubmit(true);
-            }
-            if (e.key === "Backspace") {
-                if (mode === "history") {
-                    setMode(null);
-                    return;
-                }
-                clearAnswer();
-            }
-            if (e.key === "Escape") {
-                if (mode === "history") {
-                    setMode(null);
-                    return;
-                }
-                tryReturnToMenu();
-            }
-        };
-        window.addEventListener("keydown", handleKeyDown);
-        return () => window.removeEventListener("keydown", handleKeyDown);
-    }, [
-        mode,
-        questionSet,
-        currentIndex,
-        showResult,
-        selectedAnswer,
-        showConfirmSubmit,
-        showConfirmExit,
-        finished,
-        menuSelection,
-        subject,
-        user,
-        fullscreenImage,
-        reportModalOpen,
-        isSessionBlocked,
-        testToStart,
-        visualSelection,
-        shuffledMapping,
-        showResumePrompt,
-        showSaveProgressPrompt,
-    ]);
-
-    useEffect(() => {
-        if (
-            finished ||
-            (mode !== "mock" && mode !== "smart" && mode !== "mistakes")
-        )
-            return;
-        const interval = setInterval(() => {
-            if (mode === "mock") setTimeLeft((p) => Math.max(0, p - 1));
-            else setTrainingTime((t) => t + 1);
-        }, 1000);
-        return () => clearInterval(interval);
-    }, [mode, finished]);
-    useEffect(() => {
-        if (mode === "mock" && timeLeft === 0 && !finished) submitTest();
-    }, [timeLeft, mode, finished]);
-
-    const [showCustomImport, setShowCustomImport] = useState(false);
-
-    useEffect(() => {
-        window.handleCustomImport = (questions) => {
-            handleFileUpload(questions);
-            setShowCustomImport(false);
-        };
-        return () => delete window.handleCustomImport;
-    }, [activeQuestionsCache]);
-
-    if (showCustomImport) {
-        return <CustomImportGuide onBack={() => setShowCustomImport(false)} />;
-    }
-
-    if (!user)
-        return (
-            <>
-                <div
-                    style={{
-                        position: "absolute",
-                        top: "1rem",
-                        right: "1rem",
-                        zIndex: 100,
-                    }}
-                >
-                    <ThemeToggle currentTheme={theme} toggle={toggleTheme} />
-                </div>
-                <CloudLoginScreen onLogin={login} loading={loading} />
-            </>
-        );
-
-    if (isSessionBlocked)
-        return <SessionBlockedScreen onTakeOver={takeOverSession} />;
-
-    if (mode === "leaderboard") {
-        if (!profileData?.class) {
-            setMode(null);
-            return null;
-        }
-        return (
-            <div
-                className="container fadeIn"
-                style={{
-                    minHeight: "var(--vh)",
-                    display: "flex",
-                    flexDirection: "column",
-                    alignItems: "center",
-                    justifyContent: "flex-start",
-                }}
-            >
-                <div className="top-navbar" style={{ width: "100%" }}>
-                    <div className="navbar-group">
-                        <button
-                            className="menuBackButton"
-                            onClick={() => setMode(null)}
-                        >
-                            ÔćÉ{" "}
-                            <span className="mobile-hide-text">
-                                Zp─Ťt do menu
-                            </span>
-                        </button>
-                    </div>
-                    <div className="navbar-group">
-                        <UserBadgeDisplay
-                            user={user}
-                            syncing={syncing}
-                            onLogout={handleLogout}
-                        />
-                        <ThemeToggle
-                            currentTheme={theme}
-                            toggle={toggleTheme}
-                        />
-                    </div>
-                </div>
-                <div
-                    style={{
-                        width: "100%",
-                        maxWidth: "900px",
-                        padding: "1.5rem 1rem 2rem",
-                    }}
-                >
-                    <LeaderboardPanel
-                        entries={leaderboardEntries}
-                        loading={leaderboardLoading}
-                        error={leaderboardError}
-                        title={
-                            profileData?.class
-                                ? `┼Żeb┼Ö├ş─Źek t┼Ö├şdy ${profileData.class}`
-                                : "┼Żeb┼Ö├ş─Źek t┼Ö├şdy"
-                        }
-                        className="leaderboard-full"
-                    />
-                </div>
-            </div>
-        );
-    }
-
-    if (mode === "teacher_manager") {
-        if (!isTeacher) {
-            setMode(null);
-            return null;
-        }
-        return (
-            <TestManager
-                onBack={() => setMode(null)}
-                subject={subject}
-                isTeacher={isTeacher}
-                user={user}
-                syncing={syncing}
-                theme={theme}
-                toggleTheme={toggleTheme}
-            />
-        );
-    }
-
-    if (mode === "scheduled_list") {
-        return (
-            <>
-                <ScheduledTestsList
-                    scheduledTests={scheduledTests}
-                    onBack={() => setMode(null)}
-                    subject={subject}
-                    user={user}
-                    syncing={syncing}
-                    theme={theme}
-                    toggleTheme={toggleTheme}
-                    onStartGradedTest={startGradedTest}
-                    onStartPractice={startTestPractice}
-                    completedTestIds={completedTestIds}
-                    testPracticeStats={testPracticeStats}
-                    onRefresh={handleManualRefresh}
-                />
-                {testToStart && (
-                    <ConfirmModal
-                        title={`Spustit test "${testToStart.title}"?`}
-                        message={
-                            <div style={{ textAlign: "left" }}>
-                                <p style={{ marginBottom: "1rem" }}>
-                                    Chyst├íte se spustit ostr├Ż test.
-                                </p>
-                                <ul
-                                    style={{
-                                        paddingLeft: "1.2rem",
-                                        color: "var(--color-text-secondary)",
-                                        fontSize: "0.95rem",
-                                        lineHeight: "1.5",
-                                    }}
-                                >
-                                    <li>
-                                        Do testu lze vstoupit{" "}
-                                        <strong>pouze jednou</strong>.
-                                    </li>
-                                    <li>
-                                        Jakmile test spust├şte, za─Źne b─Ť┼żet
-                                        ─Źasov├Ż limit ({testToStart.time_limit}{" "}
-                                        min).
-                                    </li>
-                                    <li>
-                                        Test nelze p┼Öeru┼íit ani se k n─Ťmu vr├ítit
-                                        pozd─Ťji.
-                                    </li>
-                                    <li>
-                                        Ujist─Ťte se, ┼że m├íte stabiln├ş p┼Öipojen├ş
-                                        k internetu.
-                                    </li>
-                                </ul>
-                            </div>
-                        }
-                        onCancel={() => setTestToStart(null)}
-                        onConfirm={confirmStartTest}
-                        confirmText="Spustit test"
-                        danger={false}
-                    />
-                )}
-            </>
-        );
-    }
-
-    if (mode === "real_test") {
-        return (
-            <RealTestMode
-                test={activeTest}
-                initialQuestions={questionSet}
-                user={user}
-                userId={dbId}
-                onExit={() => setMode(null)}
-                onFinish={() => setMode(null)}
-                theme={theme}
-                toggleTheme={toggleTheme}
-                syncing={syncing}
-                onReport={handleReportClick}
-                onTestCompleted={handleTestCompletion}
-            />
-        );
-    }
-
-    if (!mode) {
-        if (!subject || isTransitioningSubject)
-            return (
-                <div
-                    className="container fadeIn"
-                    style={{
-                        minHeight: "var(--vh)",
-                        display: "flex",
-                        flexDirection: "column",
-                        alignItems: "center",
-                        justifyContent: "flex-start",
-                        paddingBottom: "1.5rem",
-                    }}
-                >
-                    {isLoadingQuestions || isTransitioningSubject ? (
-                        <div
-                            style={{
-                                margin: "2rem",
-                                fontSize: "1.2rem",
-                                color: "#888",
-                                display: "flex",
-                                flexDirection: "column",
-                                alignItems: "center",
-                                justifyContent: "center",
-                                height: "100%",
-                            }}
-                        >
-                            <div
-                                style={{
-                                    fontSize: "3rem",
-                                    marginBottom: "1rem",
-                                }}
-                            >
-                                ÔĆ│
-                            </div>
-                            Na─Ź├şt├ím ot├ízky a obr├ízky...
-                        </div>
-                    ) : (
-                        <>
-                            <div
-                                className="top-navbar"
-                                style={{ width: "100%" }}
-                            >
-                                <div className="navbar-group">
-                                    {user === "admin" && (
-                                        <button
-                                            className="menuBackButton"
-                                            onClick={() => setMode("admin")}
-                                            title="Admin Panel"
-                                        >
-                                            ­čŤá´ŞĆ Admin
-                                        </button>
-                                    )}
-                                    <SubjectBadge subject={subject} compact />
-                                </div>
-                                <div className="navbar-group">
-                                    <UserBadgeDisplay
-                                        user={user}
-                                        syncing={syncing}
-                                        onLogout={handleLogout}
-                                        alwaysShowFullName={true}
-                                    />
-                                    <ThemeToggle
-                                        currentTheme={theme}
-                                        toggle={toggleTheme}
-                                    />
-                                </div>
-                            </div>
-                            <div
-                                style={{
-                                    flexGrow: 1,
-                                    display: "flex",
-                                    flexDirection: "column",
-                                    justifyContent: "center",
-                                    width: "100%",
-                                }}
-                            >
-                                <div className="subject-menu-layout">
-                                    <div className="subject-menu-main">
-                                        <SubjectSelector
-                                            menuSelection={menuSelection}
-                                            onSelectSubject={handleSelectSubject}
-                                            onUploadFile={handleFileUpload}
-                                            isKeyboardMode={isKeyboardMode}
-                                            setIsKeyboardMode={
-                                                setIsKeyboardMode
-                                            }
-                                        />
-                                        {profileData?.class && (
-                                            <button
-                                                className="leaderboard-mobile-button"
-                                                onClick={() =>
-                                                    setMode("leaderboard")
-                                                }
-                                            >
-                                                ­čĆć ┼Żeb┼Ö├ş─Źek t┼Ö├şdy
-                                            </button>
-                                        )}
-                                    </div>
-                                    {profileData?.class && (
-                                        <div className="leaderboard-desktop">
-                                            <LeaderboardPanel
-                                                entries={leaderboardEntries}
-                                                loading={leaderboardLoading}
-                                                error={leaderboardError}
-                                                title={
-                                                    profileData?.class
-                                                        ? `┼Żeb┼Ö├ş─Źek t┼Ö├şdy ${profileData.class}`
-                                                        : "┼Żeb┼Ö├ş─Źek t┼Ö├şdy"
-                                                }
-                                            />
-                                        </div>
-                                    )}
-                                </div>
-                            </div>
-                        </>
-                    )}
-                    <div style={{ height: "1px" }}></div>
-                </div>
-            );
-
-        const mistakesCount = mistakes[subject]?.length || 0;
-        return (
-            <>
-                <ReportModal
-                    isOpen={reportModalOpen}
-                    onClose={() => {
-                        setReportModalOpen(false);
-                        setQuestionToReport(null);
-                    }}
-                    theme={theme}
-                    {...(() => {
-                        let activeReportQuestion = currentQuestion;
-                        if (questionToReport) {
-                            const found = questionSet.find(
-                                (q) => q.number === questionToReport,
-                            );
-                            if (found) activeReportQuestion = found;
-                        }
-                        const qForModal = activeReportQuestion || {};
-                        return {
-                            questionText: qForModal.question,
-                            questionId: qForModal.id,
-                            subject: qForModal.subject,
-                            questionNumber: qForModal.number,
-                            options: qForModal.options,
-                            correctIndex: qForModal.correctIndex,
-                            userAnswer: qForModal.userAnswer,
-                        };
-                    })()}
-                    mode={mode}
-                    username={user}
-                    userId={dbId}
-                    isExiting={!!exitDirection}
-                />
-
-                {showSmartSettings && (
-                    <SmartSettingsModal
-                        onStart={startNewSmartSession}
-                        onCancel={() => setShowSmartSettings(false)}
-                        totalQuestions={activeQuestionsCache.length}
-                    />
-                )}
-
-                {showResumePrompt && (
-                    <ConfirmModal
-                        title="Nalezen rozpracovan├Ż bal├ş─Źek"
-                        message={
-                            <div>
-                                <p>M├í┼í ulo┼żen├Ż nedokon─Źen├Ż bal├ş─Źek z minula.</p>
-                                <p>Chce┼í v n─Ťm pokra─Źovat?</p>
-                            </div>
-                        }
-                        onCancel={() => {
-                            setShowResumePrompt(false);
-                            setShowSmartSettings(true);
-                        }}
-                        onConfirm={resumeSmartSession}
-                        confirmText="Pokra─Źovat"
-                        cancelText="Nov├Ż bal├ş─Źek"
-                        danger={false}
-                    />
-                )}
-
-                {showClearMistakesConfirm && (
-                    <ConfirmModal
-                        title="Vynulovat opravnu?"
-                        message="Smazat chyby z cloudu?"
-                        onCancel={() => setShowClearMistakesConfirm(false)}
-                        onConfirm={clearMistakes}
-                        confirmText="Smazat"
-                        danger={true}
-                    />
-                )}
-
-                <div
-                    ref={containerRef}
-                    className="container fadeIn"
-                    style={{
-                        minHeight: "var(--vh)",
-                        display: "flex",
-                        flexDirection: "column",
-                        justifyContent: "flex-start",
-                        alignItems: "center",
-                    }}
-                >
-                    {!isLoadingQuestions && (
-                        <div className="top-navbar" style={{ width: "100%" }}>
-                            <div className="navbar-group">
-                                <div className="navbar-group">
-                                    <button
-                                        className="menuBackButton"
-                                        onClick={() => {
-                                            flushSessionStats();
-                                            clearImageCache();
-                                            setSubject(null);
-                                        }}
-                                    >
-                                        ÔćÉ{" "}
-                                        <span className="mobile-hide-text">
-                                            Zm─Ťnit p┼Öedm─Ťt
-                                        </span>
-                                    </button>
-                                    <SubjectBadge subject={subject} compact />
-                                </div>
-                            </div>
-                            <div className="navbar-group">
-                                <UserBadgeDisplay
-                                    user={user}
-                                    syncing={syncing}
-                                    onLogout={handleLogout}
-                                />
-                                <ThemeToggle
-                                    currentTheme={theme}
-                                    toggle={toggleTheme}
-                                />
-                            </div>
-                        </div>
-                    )}
-                    {isLoadingQuestions || mode === "loading" ? (
-                        <div
-                            style={{
-                                margin: "2rem",
-                                fontSize: "1.2rem",
-                                color: "#888",
-                                display: "flex",
-                                flexDirection: "column",
-                                alignItems: "center",
-                                justifyContent: "center",
-                                height: "100%",
-                            }}
-                        >
-                            <div
-                                style={{
-                                    fontSize: "3rem",
-                                    marginBottom: "1rem",
-                                }}
-                            >
-                                ÔĆ│
-                            </div>
-                            Na─Ź├şt├ím ot├ízky a obr├ízky...
-                        </div>
-                    ) : (
-                        <MainMenu
-                            scheduledTests={scheduledTests}
-                            completedTestIds={completedTestIds}
-                            menuSelection={menuSelection}
-                            isKeyboardMode={isKeyboardMode}
-                            isTeacher={isTeacher}
-                            userClass={profileData?.class}
-                user={user}
-                syncing={syncing}
-                theme={theme}
-                toggleTheme={toggleTheme}
-                            mistakesCount={mistakesCount}
-                            onOpenScheduled={() => setMode("scheduled_list")}
-                            onStartMock={() =>
-                                handleStartMode(startMockTest, "mock")
-                            }
-                            onStartSmart={() =>
-                                handleStartMode(startNewSmartSession, "smart")
-                            }
-                            onStartRandom={() =>
-                                handleStartMode(startRandomMode, "random")
-                            }
-                            onStartDuel={() => setMode("duel")}
-                            onStartReview={() =>
-                                handleStartMode(startReviewMode, "review")
-                            }
-                            onOpenTeacherManager={() =>
-                                setMode("teacher_manager")
-                            }
-                            onStartMistakes={() =>
-                                handleStartMode(startMistakesMode, "mistakes")
-                            }
-                            onClearMistakes={() =>
-                                setShowClearMistakesConfirm(true)
-                            }
-                            onOpenHistory={openHistoryWithRefresh}
-                        />
-                    )}
-                </div>
-            </>
-        );
-    }
-
-    if (mode === "admin") return <AdminPanel onBack={() => setMode(null)} />;
-    if (mode === "no_mistakes")
-        return (
-            <NoMistakesScreen onBack={() => setMode(null)} subject={subject} />
-        );
-
-    if (mode === "history")
-        return (
-            <>
-                <HistoryView
-                    history={history}
-                    totalTimeMap={totalTimeMap}
-                    sessionTime={sessionTime}
-                    totalQuestionsMap={totalQuestionsMap}
-                    sessionQuestionsCount={sessionQuestionsCount}
-                    onBack={() => setMode(null)}
-                    currentSubject={subject}
-                    onDeleteRecord={setRecordToDelete}
-                    user={user}
-                    syncing={syncing}
-                />
-                {recordToDelete && (
-                    <ConfirmModal
-                        title="Smazat z├íznam?"
-                        message="Smazat tento z├íznam?"
-                        onCancel={() => setRecordToDelete(null)}
-                        onConfirm={() => {
-                            updateHistory((prev) =>
-                                prev.filter((h) => h.id !== recordToDelete),
-                            );
-                            setRecordToDelete(null);
-                        }}
-                        confirmText="Smazat"
-                        danger={true}
-                    />
-                )}
-            </>
-        );
-
-    if (mode === "review") {
-        const REVIEW_COLUMNS = window.innerWidth > 768 ? 2 : 1;
-        const REVIEW_ROWS = 5;
-        const REVIEW_ITEMS_PER_PAGE = REVIEW_COLUMNS * REVIEW_ROWS;
-        const normalizedSearch = removeAccents(searchTerm);
-        const filteredQuestions = questionSet.filter(
-            (q) =>
-                removeAccents(q.question).includes(normalizedSearch) ||
-                String(q.number).includes(normalizedSearch),
-        );
-        const highlightRegex = getSmartRegex(searchTerm);
-        const totalReviewPages = Math.ceil(
-            filteredQuestions.length / REVIEW_ITEMS_PER_PAGE,
-        );
-        const paginatedQuestions = filteredQuestions.slice(
-            reviewPage * REVIEW_ITEMS_PER_PAGE,
-            (reviewPage + 1) * REVIEW_ITEMS_PER_PAGE,
-        );
-
-        const scrollToTop = () => {
-            if (containerRef.current) {
-                containerRef.current.scrollTo({ top: 0, behavior: "smooth" });
-            } else {
-                window.scrollTo({ top: 0, behavior: "smooth" });
-            }
-        };
-
-        return (
-            <>
-                <CustomImageModal
-                    src={fullscreenImage}
-                    onClose={() => setFullscreenImage(null)}
-                />
-                {(() => {
-                    let activeReportQuestion = currentQuestion;
-                    if (questionToReport) {
-                        const found = activeQuestionsCache.find(
-                            (q) => q.number === questionToReport,
-                        );
-                        if (found) activeReportQuestion = found;
-                    }
-                    const qForModal = activeReportQuestion || {};
-                    return (
-                        <ReportModal
-                            isOpen={reportModalOpen}
-                            onClose={() => {
-                                setReportModalOpen(false);
-                                setQuestionToReport(null);
-                            }}
-                            theme={theme}
-                            questionText={qForModal.question}
-                            questionId={qForModal.id}
-                            subject={qForModal.subject || subject}
-                            questionNumber={qForModal.number}
-                            mode={mode}
-                            options={qForModal.options}
-                            correctIndex={qForModal.correctIndex}
-                            userAnswer={qForModal.userAnswer}
-                            username={user}
-                            userId={dbId}
-                            isExiting={!!exitDirection}
-                        />
-                    );
-                })()}
-                <div
-                    className="container fadeIn"
-                    style={{ minHeight: "var(--vh)" }}
-                >
-                    <div className="top-navbar" style={{ width: "100%" }}>
-                        <div className="navbar-group">
-                            <button
-                                className="menuBackButton"
-                                onClick={() => {
-                                    flushSessionStats();
-                                    tryReturnToMenu();
-                                }}
-                            >
-                                ÔćÉ <span className="mobile-hide-text">Zp─Ťt</span>
-                            </button>
-                            <SubjectBadge subject={subject} compact />
-                        </div>
-                        <div className="navbar-group">
-                            <UserBadgeDisplay user={user} syncing={syncing} />
-                            <ThemeToggle
-                                currentTheme={theme}
-                                toggle={toggleTheme}
-                            />
-                        </div>
-                    </div>
-                    <h1 className="title">Prohl├ş┼żen├ş ot├ízek</h1>
-                    <div className="reviewControls">
-                        <input
-                            type="text"
-                            placeholder="Hledat..."
-                            value={searchTerm}
-                            onChange={(e) => {
-                                setSearchTerm(e.target.value);
-                                setReviewPage(0);
-                            }}
-                            className="reviewSearchInput"
-                        />
-                        {totalReviewPages > 1 && (
-                            <div className="reviewPageInfo">
-                                Strana {reviewPage + 1} z {totalReviewPages} (
-                                {filteredQuestions.length} ot├ízek)
-                            </div>
-                        )}
-                    </div>
-                    <div className="reviewGrid">
-                        {paginatedQuestions.length === 0 ? (
-                            <p
-                                style={{
-                                    textAlign: "center",
-                                    color: "#888",
-                                    gridColumn: "1/-1",
-                                }}
-                            >
-                                Nic nenalezeno.
-                            </p>
-                        ) : (
-                            paginatedQuestions.map((q) => {
-                                const imageUrl =
-                                    q.image_base64 ||
-                                    (q.id ? getCachedImage(q.id) : null) ||
-                                    getImageUrl(subject, q.number) ||
-                                    (q.image && q.image.length > 5
-                                        ? q.image
-                                        : null);
-                                return (
-                                    <div
-                                        key={`${q.number}-${reviewPage}`}
-                                        className="reviewCard"
-                                    >
-                                        <div
-                                            className="reviewHeader"
-                                            style={{
-                                                display: "flex",
-                                                alignItems: "flex-start",
-                                                gap: "10px",
-                                                position: "relative",
-                                            }}
-                                        >
-                                            <div style={{ flex: 1 }}>
-                                                <strong>#{q.number}.</strong>{" "}
-                                                <HighlightedText
-                                                    text={q.question}
-                                                    highlightRegex={
-                                                        highlightRegex
-                                                    }
-                                                />
-                                            </div>
-                                            <button
-                                                className="report-btn-flash"
-                                                onClick={() =>
-                                                    handleReportClick(q.number)
-                                                }
-                                                style={{
-                                                    background: "transparent",
-                                                    border: "none",
-                                                    padding: "4px",
-                                                    width: "32px",
-                                                    height: "32px",
-                                                    display: "flex",
-                                                    alignItems: "center",
-                                                    justifyContent: "center",
-                                                    cursor: "pointer",
-                                                    fontSize: "1.1rem",
-                                                    flexShrink: 0,
-                                                    opacity: 0.7,
-                                                    marginTop: "-2px",
-                                                }}
-                                                title="Nahl├ísit chybu v t├ęto ot├ízce"
-                                            >
-                                                ­čĆ│´ŞĆ
-                                            </button>
-                                        </div>
-                                        <ReviewImage
-                                            q={q}
-                                            subject={subject}
-                                            setFullscreenImage={
-                                                setFullscreenImage
-                                            }
-                                        />
-                                        <div
-                                            style={{
-                                                marginTop: "1rem",
-                                                display: "flex",
-                                                flexDirection: "column",
-                                                gap: "0.4rem",
-                                            }}
-                                        >
-                                            {q.options.map((opt, idx) => (
-                                                <div
-                                                    key={idx}
-                                                    style={{
-                                                        fontSize: "0.9rem",
-                                                        color:
-                                                            idx ===
-                                                            q.correctIndex
-                                                                ? "var(--color-review-correct)"
-                                                                : "var(--color-text-secondary)",
-                                                        fontWeight:
-                                                            idx ===
-                                                            q.correctIndex
-                                                                ? "bold"
-                                                                : "normal",
-                                                    }}
-                                                >
-                                                    <span>
-                                                        {idx === q.correctIndex
-                                                            ? "Ôťů"
-                                                            : "ÔÇó"}
-                                                    </span>{" "}
-                                                    <span>
-                                                        <HighlightedText
-                                                            text={opt}
-                                                            highlightRegex={
-                                                                highlightRegex
-                                                            }
-                                                        />
-                                                    </span>
-                                                </div>
-                                            ))}
-                                        </div>
-                                    </div>
-                                );
-                            })
-                        )}
-                    </div>
-                    <ReviewNavigator
-                        currentPage={reviewPage}
-                        totalPages={totalReviewPages}
-                        onPageChange={(page) => {
-                            setReviewPage(page);
-                        }}
-                    />
-                </div>
-            </>
-        );
-    }
-
-    let comboClass =
-        combo >= 10
-            ? "combo-high"
-            : combo >= 5
-              ? "combo-med"
-              : combo >= 3
-                ? "combo-low"
-                : "";
-    let remainingCards = 0;
-    if (mode === "smart" || mode === "mistakes")
-        remainingCards = questionSet.length;
-    else if (mode === "random" || mode === "test_practice")
-        remainingCards = questionSet.length - currentIndex;
-
-    let stackLevelClass = "";
-    if (remainingCards <= 1) stackLevelClass = "stack-level-0";
-    else if (remainingCards === 2) stackLevelClass = "stack-level-1";
-
-    return (
-        <>
-            <CustomImageModal
-                src={fullscreenImage}
-                onClose={() => setFullscreenImage(null)}
-            />
-            {(() => {
-                let activeReportQuestion = currentQuestion;
-                if (questionToReport) {
-                    const found = activeQuestionsCache.find(
-                        (q) => q.number === questionToReport,
-                    );
-                    if (found) activeReportQuestion = found;
-                }
-                const qForModal = activeReportQuestion || {};
-                return (
-                    <ReportModal
-                        isOpen={reportModalOpen}
-                        onClose={() => {
-                            setReportModalOpen(false);
-                            setQuestionToReport(null);
-                        }}
-                        theme={theme}
-                        questionText={qForModal.question}
-                        questionId={qForModal.id}
-                        subject={qForModal.subject || subject}
-                        questionNumber={qForModal.number}
-                        mode={mode}
-                        options={qForModal.options}
-                        correctIndex={qForModal.correctIndex}
-                        userAnswer={qForModal.userAnswer}
-                        username={user}
-                        userId={dbId}
-                        isExiting={!!exitDirection}
-                    />
-                );
-            })()}
-
-            <div
-                className="container fadeIn"
-                style={{ minHeight: "var(--vh)", paddingBottom: "2rem" }}
-            >
-                {showConfirmSubmit && (
-                    <ConfirmModal
-                        title={
-                            mode === "real_test"
-                                ? "Odevzdat test?"
-                                : "Odevzdat?"
-                        }
-                        message={
-                            mode === "real_test"
-                                ? "Po odevzd├ín├ş u┼ż nep┼»jde odpov─Ťdi zm─Ťnit."
-                                : "Opravdu odevzdat?"
-                        }
-                        onCancel={() => setShowConfirmSubmit(false)}
-                        onConfirm={mode === "real_test" ? () => {} : submitTest}
-                        confirmText={mode === "real_test" ? "ODEVZDAT" : "Ano"}
-                        danger={mode === "real_test"}
-                    />
-                )}
-                {showConfirmExit && (
-                    <ConfirmModal
-                        title="Ukon─Źit?"
-                        message="Ztracen├ę odpov─Ťdi nebudou ulo┼żeny."
-                        onCancel={() => setShowConfirmExit(false)}
-                        onConfirm={confirmExit}
-                        confirmText="Ukon─Źit"
-                    />
-                )}
-
-                {/* --- SAVE PROGRESS PROMPT --- */}
-                {showSaveProgressPrompt && (
-                    <ConfirmModal
-                        title="Ulo┼żit postup?"
-                        message={
-                            <div>
-                                <p>
-                                    Chce┼í si ulo┼żit aktu├íln├ş postup na p┼Ö├ş┼ít─Ť?
-                                </p>
-                                <p
-                                    style={{
-                                        fontSize: "0.85rem",
-                                        color: "var(--color-text-secondary)",
-                                        marginTop: "0.5rem",
-                                    }}
-                                >
-                                    (Pokud zvol├ş┼í 'Neukl├ídat', tento
-                                    rozpracovan├Ż bal├ş─Źek se sma┼że.)
-                                </p>
-                            </div>
-                        }
-                        onCancel={() => handleSaveAndExit(false)} // Ne = smazat a odej├şt
-                        onConfirm={() => handleSaveAndExit(true)} // Ano = nechat ulo┼żeno a odej├şt
-                        confirmText="Ulo┼żit a odej├şt"
-                        cancelText="Neukl├ídat"
-                        danger={false}
-                    />
-                )}
-
-                {finished && (
-                    <ResultScreen
-                        mode={mode}
-                        score={score}
-                        trainingTime={trainingTime}
-                        questionSet={questionSet}
-                        maxSeenIndex={maxSeenIndex}
-                        // --- OPRAVA: P┼śID├üN├Ź LOGIKY ONBACK ---
-                        onBack={() => {
-                            if (mode === "smart") {
-                                clearSmartSession();
-                            }
-                            setMode(null);
-                            setCombo(0);
-                        }}
-                        // ------------------------------------
-
-                        currentSubject={subject}
-                        timeLeftAtSubmit={timeLeftAtSubmit}
-                        onZoom={setFullscreenImage}
-                        user={user}
-                        syncing={syncing}
-                        onReport={handleReportClick}
-                        theme={theme}
-                        toggleTheme={toggleTheme}
-                    />
-                )}
-
-                {mode === "loading" && (
-                    <div
-                        className="fadeIn"
-                        style={{
-                            position: "fixed",
-                            top: 0,
-                            left: 0,
-                            width: "100%",
-                            height: "100%",
-                            height: "100dvh",
-                            display: "flex",
-                            alignItems: "center",
-                            justifyContent: "center",
-                            backgroundColor: "var(--color-bg-body)",
-                            zIndex: 9999,
-                            backdropFilter: "blur(5px)",
-                        }}
-                    >
-                        <div
-                            className="card"
-                            style={{
-                                padding: "2.5rem 2rem",
-                                width: "90%",
-                                maxWidth: "400px",
-                                display: "flex",
-                                flexDirection: "column",
-                                alignItems: "center",
-                                gap: "1.5rem",
-                                boxShadow:
-                                    "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
-                                border: "1px solid var(--color-border)",
-                                textAlign: "center",
-                            }}
-                        >
-                            <div
-                                style={{
-                                    transform: "scale(1.2)",
-                                    marginBottom: "0.5rem",
-                                }}
-                            >
-                                <SubjectBadge subject={subject} />
-                            </div>
-
-                            <div className="custom-loader"></div>
-
-                            <div>
-                                <h2
-                                    style={{
-                                        margin: 0,
-                                        fontSize: "1.4rem",
-                                        fontWeight: "700",
-                                    }}
-                                >
-                                    {activeTest
-                                        ? "P┼Ö├şprava testu"
-                                        : "Na─Ź├şt├ím data"}
-                                </h2>
-                                <p
-                                    style={{
-                                        margin: "0.5rem 0 0",
-                                        color: "var(--color-text-secondary)",
-                                        fontSize: "0.95rem",
-                                    }}
-                                >
-                                    Kompletuji ot├ízky a stahuji obr├ízky...
-                                </p>
-                            </div>
-
-                            <div
-                                style={{
-                                    width: "100%",
-                                    display: "flex",
-                                    flexDirection: "column",
-                                    gap: "8px",
-                                }}
-                            >
-                                <div
-                                    style={{
-                                        width: "100%",
-                                        height: "8px",
-                                        background: "var(--color-bg-secondary)",
-                                        borderRadius: "99px",
-                                        overflow: "hidden",
-                                    }}
-                                >
-                                    <div
-                                        style={{
-                                            width: `${loadingProgress}%`,
-                                            height: "100%",
-                                            background: "var(--color-primary)",
-                                            transition: "width 0.3s ease-out",
-                                            borderRadius: "99px",
-                                        }}
-                                    ></div>
-                                </div>
-                                <span
-                                    style={{
-                                        fontSize: "0.85rem",
-                                        color: "var(--color-text-secondary)",
-                                        fontWeight: "bold",
-                                    }}
-                                >
-                                    {Math.round(loadingProgress)}%
-                                </span>
-                            </div>
-
-                            <style>{`
-                                .custom-loader {
-                                    width: 40px;
-                                    height: 40px;
-                                    border: 4px solid var(--color-bg-secondary);
-                                    border-top: 4px solid var(--color-primary);
-                                    border-radius: 50%;
-                                    animation: spin 1s linear infinite;
-                                }
-                                @keyframes spin {
-                                    0% { transform: rotate(0deg); }
-                                    100% { transform: rotate(360deg); }
-                                }
-                            `}</style>
-                        </div>
-                    </div>
-                )}
-                {!finished && mode !== "loading" && (
-                    <>
-                        <div className="top-navbar" style={{ width: "100%" }}>
-                            <div className="navbar-group">
-                                {mode === "real_test" ? (
-                                    <span
-                                        style={{
-                                            fontWeight: "bold",
-                                            color: "var(--color-error)",
-                                        }}
-                                    >
-                                        ÔÜá´ŞĆ TEST: NEOPOU┼áT─ÜJ OKNO!
-                                    </span>
-                                ) : (
-                                    <button
-                                        className="menuBackButton"
-                                        onClick={tryReturnToMenu}
-                                    >
-                                        ÔćÉ{" "}
-                                        <span className="mobile-hide-text">
-                                            Zp─Ťt
-                                        </span>
-                                    </button>
-                                )}
-                                <div className="mobile-hidden">
-                                    <SubjectBadge subject={subject} compact />
-                                </div>
-                            </div>
-                            <div className="navbar-group">
-                                {mode === "mock" && (
-                                    <div
-                                        className={`timer ${timeLeft <= 300 ? "timerWarning" : ""} ${timeLeft <= 60 ? "timerDanger" : ""}`}
-                                    >
-                                        {formatTime(timeLeft)}
-                                    </div>
-                                )}
-                                {(mode === "training" ||
-                                    mode === "smart" ||
-                                    mode === "mistakes") && (
-                                    <div className="timer">
-                                        {formatTime(trainingTime)}
-                                    </div>
-                                )}
-                                <UserBadgeDisplay
-                                    user={user}
-                                    syncing={syncing}
-                                    compactOnMobile={true}
-                                />
-                                <ThemeToggle
-                                    currentTheme={theme}
-                                    toggle={toggleTheme}
-                                />
-                            </div>
-                        </div>
-                        <div className="quizContentWrapper">
-                            <h1 className="title">
-                                {mode === "real_test"
-                                    ? activeTest?.title
-                                    : mode === "random"
-                                      ? "Flashcards"
-                                      : mode === "mock"
-                                        ? "Test nane─Źisto"
-                                        : mode === "mistakes"
-                                          ? "Opravna chyb"
-                                          : mode === "smart" ||
-                                              mode === "test_practice"
-                                            ? "Procvi─Źov├ín├ş"
-                                            : "Tr├ęninkov├Ż re┼żim"}
-                            </h1>
-
-                            {isFlashcardStyle(mode) ||
-                            mode === "test_practice" ? (
-                                <div
-                                    className={`flashcardHeader ${comboClass}`}
-                                >
-                                    {mode !== "test_practice" && (
-                                        <div className="statItem">
-                                            <span className="statLabel">
-                                                {mode === "random"
-                                                    ? "Zodpov─Ťzeno"
-                                                    : "Zb├Żv├í"}
-                                            </span>
-                                            <span className="statValue">
-                                                {mode === "random"
-                                                    ? currentIndex
-                                                    : remainingCards}
-                                            </span>
-                                        </div>
-                                    )}
-                                    {combo >= 3 && (
-                                        <div className="comboContainer">
-                                            <div className="comboFlame">­čöą</div>
-                                            <div className="comboCount">
-                                                {combo}x
-                                            </div>
-                                        </div>
-                                    )}
-                                    <div
-                                        className="statItem"
-                                        style={{
-                                            textAlign: "right",
-                                            marginLeft: "auto",
-                                        }}
-                                    >
-                                        <span className="statLabel">
-                                            ├Üsp─Ť┼ínost
-                                        </span>
-                                        <span className="statValue">
-                                            {mode === "test_practice" &&
-                                            activeTest
-                                                ? (() => {
-                                                      const stats =
-                                                          testPracticeStats[
-                                                              activeTest.id
-                                                          ] || [];
-                                                      if (stats.length === 0)
-                                                          return "0%";
-                                                      return (
-                                                          Math.round(
-                                                              (stats.filter(
-                                                                  Boolean,
-                                                              ).length /
-                                                                  stats.length) *
-                                                                  100,
-                                                          ) + "%"
-                                                      );
-                                                  })()
-                                                : (score.total > 0
-                                                      ? Math.round(
-                                                            (score.correct /
-                                                                score.total) *
-                                                                100,
-                                                        )
-                                                      : 0) + "%"}
-                                        </span>
-                                    </div>
-                                </div>
-                            ) : (
-                                <>
-                                    <div className="progressBarContainer">
-                                        <div
-                                            className="progressBarFill"
-                                            style={{
-                                                width: `${((currentIndex + 1) / questionSet.length) * 100}%`,
-                                            }}
-                                        ></div>
-                                    </div>
-                                    <div className="progressText">
-                                        Ot├ízka {currentIndex + 1} /{" "}
-                                        {questionSet.length}
-                                    </div>
-                                </>
-                            )}
-
-                            <div
-                                className={`card ${isFlashcardStyle(mode) || mode === "test_practice" ? `stacked-card ${stackLevelClass}` : ""} ${shake ? "shake" : ""}`}
-                                ref={cardRef}
-                                style={{
-                                    minHeight: "200px",
-                                    position: "relative",
-                                }}
-                            >
-                                {questionSet.map((q, index) => {
-                                    const isFlashcardMode =
-                                        mode === "random" ||
-                                        mode === "smart" ||
-                                        mode === "mistakes" ||
-                                        mode === "test_practice";
-
-                                    if (isFlashcardMode) {
-                                        if (
-                                            index !== currentIndex &&
-                                            index !== currentIndex + 1
-                                        )
-                                            return null;
-                                    }
-
-                                    const isCurrent = index === currentIndex;
-                                    const loadImg = isFlashcardMode
-                                        ? index === currentIndex ||
-                                          index === currentIndex + 1
-                                        : Math.abs(index - currentIndex) <= 2;
-
-                                    let animClass = "";
-                                    if (isCurrent && !isFlashcardMode) {
-                                        if (direction === "left")
-                                            animClass = "slide-in-left";
-                                        else if (direction === "right")
-                                            animClass = "slide-in-right";
-                                    }
-
-                                    return (
-                                        <div
-                                            key={
-                                                q._instanceId ||
-                                                q.id ||
-                                                q.number ||
-                                                index
-                                            }
-                                            style={{
-                                                position: isCurrent
-                                                    ? "relative"
-                                                    : "absolute",
-                                                top: 0,
-                                                left: 0,
-                                                width: "100%",
-                                                opacity: isCurrent ? 1 : 0,
-                                                zIndex: isCurrent ? 2 : -1,
-                                                pointerEvents: isCurrent
-                                                    ? "auto"
-                                                    : "none",
-                                                display: "block",
-                                            }}
-                                            className={animClass}
-                                        >
-                                            <QuestionCard
-                                                currentQuestion={q}
-                                                mode={mode}
-                                                isActive={isCurrent}
-                                                shouldLoadImage={loadImg}
-                                                showResult={
-                                                    showResult && isCurrent
-                                                }
-                                                selectedAnswer={
-                                                    isCurrent
-                                                        ? selectedAnswer
-                                                        : q.userAnswer
-                                                }
-                                                visualSelection={
-                                                    isCurrent
-                                                        ? visualSelection
-                                                        : null
-                                                }
-                                                onSelect={(i) =>
-                                                    isFlashcardStyle(mode) ||
-                                                    mode === "test_practice"
-                                                        ? clickFlashcardAnswer(
-                                                              i,
-                                                          )
-                                                        : handleAnswer(i)
-                                                }
-                                                onSwipe={handleSwipe}
-                                                onZoom={setFullscreenImage}
-                                                onReport={handleReportClick}
-                                                onContentReady={
-                                                    isCurrent
-                                                        ? setReadyQuestionId
-                                                        : undefined
-                                                }
-                                                optionRefsForCurrent={
-                                                    isCurrent
-                                                        ? optionRefsForCurrent
-                                                        : null
-                                                }
-                                                disabled={
-                                                    (isFlashcardStyle(mode) ||
-                                                        mode ===
-                                                            "test_practice") &&
-                                                    showResult
-                                                }
-                                                isKeyboardMode={isKeyboardMode}
-                                                currentSubject={subject}
-                                                score={score}
-                                                isExiting={
-                                                    isCurrent && !!exitDirection
-                                                }
-                                            />
-                                        </div>
-                                    );
-                                })}
-
-                                {(isFlashcardStyle(mode) ||
-                                    mode === "test_practice") &&
-                                    !showResult && (
-                                        <div
-                                            className="actionButtons right"
-                                            style={{ minHeight: "50px" }}
-                                        >
-                                            <button
-                                                className="navButton primary"
-                                                onClick={confirmFlashcardAnswer}
-                                            >
-                                                Potvrdit
-                                            </button>
-                                        </div>
-                                    )}
-
-                                {(isFlashcardStyle(mode) ||
-                                    mode === "test_practice") &&
-                                    showResult && (
-                                        <div
-                                            className="actionButtons right"
-                                            style={{ minHeight: "50px" }}
-                                        >
-                                            <button
-                                                className="navButton"
-                                                onClick={nextFlashcardQuestion}
-                                            >
-                                                Dal┼í├ş ot├ízka
-                                            </button>
-                                        </div>
-                                    )}
-
-                                {!(
-                                    isFlashcardStyle(mode) ||
-                                    mode === "test_practice"
-                                ) && (
-                                    <div style={{ marginTop: "1rem" }}>
-                                        <div className="actionButtons spaced">
-                                            <button
-                                                className="navButton"
-                                                onClick={() =>
-                                                    moveToQuestion(
-                                                        Math.max(
-                                                            0,
-                                                            currentIndex - 1,
-                                                        ),
-                                                    )
-                                                }
-                                                disabled={currentIndex === 0}
-                                            >
-                                                P┼Öedchoz├ş
-                                            </button>
-                                            <button
-                                                className="navButton"
-                                                onClick={() =>
-                                                    moveToQuestion(
-                                                        currentIndex + 1,
-                                                    )
-                                                }
-                                                disabled={
-                                                    currentIndex >=
-                                                    questionSet.length - 1
-                                                }
-                                            >
-                                                Dal┼í├ş
-                                            </button>
-                                        </div>
-
-                                        <div className="navigatorPlaceholder">
-                                            <Navigator
-                                                questionSet={questionSet}
-                                                currentIndex={currentIndex}
-                                                setCurrentIndex={moveToQuestion}
-                                                mode={mode}
-                                                maxSeenIndex={
-                                                    mode === "real_test"
-                                                        ? questionSet.length
-                                                        : maxSeenIndex
-                                                }
-                                            />
-
-                                            {mode === "mock" && (
-                                                <div
-                                                    style={{
-                                                        marginTop: "2rem",
-                                                        width: "100%",
-                                                        display: "flex",
-                                                        justifyContent:
-                                                            "center",
-                                                    }}
-                                                >
-                                                    <button
-                                                        className="navButton primary"
-                                                        style={{
-                                                            padding:
-                                                                "10px 30px",
-                                                            fontSize: "0.95rem",
-                                                            minWidth: "150px",
-                                                        }}
-                                                        onClick={() =>
-                                                            setShowConfirmSubmit(
-                                                                true,
-                                                            )
-                                                        }
-                                                    >
-                                                        Odevzdat test
-                                                    </button>
-                                                </div>
-                                            )}
-                                        </div>
-                                    </div>
-                                )}
-                            </div>
-                        </div>
-                    </>
-                )}
-
-                {questionSet.length > 3 && (
-                    <HiddenPreloader
-                        questionSet={questionSet}
-                        currentIndex={currentIndex}
-                        subject={subject}
-                        mode={mode}
-                    />
-                )}
-
-                <div className="footer"></div>
-            </div>
-        </>
-    );
-}
+import React, { useState, useEffect, useRef } from "react";

+import { supabase } from "./supabaseClient";

+import { useUserProfile } from "./hooks/useUserProfile";

+import { useActivityDetection } from "./hooks/useActivityDetection";

+import { useGlobalKeyboard } from "./hooks/useGlobalKeyboard";

+

+import { SubjectSelector } from "./components/SubjectSelector.jsx";

+import { AdminPanel } from "./components/AdminPanel.jsx";

+import { TestManager } from "./components/TestManager.jsx";

+

+import { SessionBlockedScreen } from "./components/SessionBlockedScreen.jsx";

+import { CloudLoginScreen } from "./components/CloudLoginScreen.jsx";

+import { CustomImageModal } from "./components/CustomImageModal.jsx";

+import { HighlightedText } from "./components/HighlightedText.jsx";

+import { MainMenu } from "./components/MainMenu.jsx";

+import { ScheduledTestsList } from "./components/ScheduledTestsList.jsx";

+import { RealTestMode } from "./components/RealTestMode.jsx";

+

+import {

+    formatTime,

+    removeAccents,

+    getSmartRegex,

+    isFlashcardStyle,

+} from "./utils/formatting.js";

+import { getImageUrl } from "./utils/images.js";

+import {

+    fetchQuestionsLightweight,

+    clearImageCache,

+    getCachedImage,

+    fetchQuestionImage,

+    preloadTestImages,

+} from "./utils/dataManager.js";

+

+import { SubjectBadge } from "./components/SubjectBadge.jsx";

+import { UserBadgeDisplay } from "./components/UserBadgeDisplay.jsx";

+import { HistoryView } from "./components/HistoryView.jsx";

+import { ResultScreen } from "./components/ResultScreen.jsx";

+import { QuestionCard } from "./components/QuestionCard.jsx";

+import { Navigator } from "./components/Navigator.jsx";

+import { ThemeToggle } from "./components/ThemeToggle.jsx";

+import { HiddenPreloader } from "./components/HiddenPreloader.jsx";

+import { ConfirmModal } from "./components/Modals.jsx";

+import { NoMistakesScreen } from "./components/NoMistakesScreen.jsx";

+import { ReportModal } from "./components/ReportModal.jsx";

+import { SmartSettingsModal } from "./components/Modals.jsx";

+

+import { CustomImportGuide } from "./components/CustomImportGuide.jsx";

+import { LeaderboardPanel } from "./components/LeaderboardPanel.jsx";

+

+/* ---------- Review Navigator Component ---------- */

+const ReviewNavigator = ({ currentPage, totalPages, onPageChange }) => {

+    const getPageNumbers = () => {

+        const current = currentPage + 1;

+        const delta = 2;

+        const range = [];

+        const rangeWithDots = [];

+        let l;

+

+        for (let i = 1; i <= totalPages; i++) {

+            if (

+                i === 1 ||

+                i === totalPages ||

+                (i >= current - delta && i <= current + delta)

+            ) {

+                range.push(i);

+            }

+        }

+

+        for (let i of range) {

+            if (l) {

+                if (i - l === 2) {

+                    rangeWithDots.push(l + 1);

+                } else if (i - l !== 1) {

+                    rangeWithDots.push("...");

+                }

+            }

+            rangeWithDots.push(i);

+            l = i;

+        }

+

+        return rangeWithDots;

+    };

+

+    if (totalPages <= 1) return null;

+

+    return (

+        <div

+            className="reviewPagination"

+            style={{

+                flexWrap: "wrap",

+                gap: "0.5rem",

+                justifyContent: "center",

+                marginTop: "2rem",

+            }}

+        >

+            <button

+                className="reviewPaginationBtn"

+                disabled={currentPage === 0}

+                onClick={() => onPageChange(currentPage - 1)}

+                style={{

+                    padding: "0 1rem",

+                    minHeight: "40px",

+                    display: "flex",

+                    alignItems: "center",

+                    justifyContent: "center",

+                }}

+            >

+                ├ö

+            </button>

+

+            {getPageNumbers().map((page, index) => {

+                const isDots = page === "...";

+                const isCurrent = page === currentPage + 1;

+

+                return (

+                    <button

+                        key={index}

+                        className="reviewPaginationBtn"

+                        onClick={() =>

+                            typeof page === "number"

+                                ? onPageChange(page - 1)

+                                : null

+                        }

+                        disabled={isDots}

+                        style={{

+                            width: "40px",

+                            height: "40px",

+                            padding: 0,

+                            minHeight: "40px",

+                            display: "flex",

+                            alignItems: "center",

+                            justifyContent: "center",

+                            cursor: isDots ? "default" : "pointer",

+                            opacity: isDots ? 0.5 : 1,

+                            background: isDots

+                                ? "transparent"

+                                : isCurrent

+                                  ? "var(--color-primary)"

+                                  : undefined,

+                            borderColor: isDots

+                                ? "transparent"

+                                : isCurrent

+                                  ? "var(--color-primary)"

+                                  : undefined,

+                            color: isCurrent ? "#fff" : undefined,

+                            fontWeight: isCurrent ? "bold" : "normal",

+                            boxShadow: isCurrent

+                                ? "0 4px 12px rgba(59, 130, 246, 0.4)"

+                                : "none",

+                        }}

+                    >

+                        {page}

+                    </button>

+                );

+            })}

+

+            <button

+                className="reviewPaginationBtn"

+                disabled={currentPage === totalPages - 1}

+                onClick={() => onPageChange(currentPage + 1)}

+                style={{

+                    padding: "0 1rem",

+                    minHeight: "40px",

+                    display: "flex",

+                    alignItems: "center",

+                    justifyContent: "center",

+                }}

+            >

+                ├ö

+            </button>

+        </div>

+    );

+};

+

+/* ---------- Review Image Component ---------- */

+

+const ReviewImage = ({ q, subject, setFullscreenImage }) => {

+    const [imgUrl, setImgUrl] = useState(() => {

+        return (

+            q.image_base64 ||

+            (q.id ? getCachedImage(q.id) : null) ||

+            getImageUrl(subject, q.number) ||

+            (q.image && q.image.length > 5 ? q.image : null)

+        );

+    });

+

+    useEffect(() => {

+        if (q.id && !imgUrl) {

+            fetchQuestionImage(q.id).then((url) => {

+                if (url) setImgUrl(url);

+            });

+        }

+    }, [q.id, imgUrl]);

+

+    if (!imgUrl) return null;

+

+    return (

+        <div

+            className="reviewImageWrapper"

+            onClick={() => setFullscreenImage(imgUrl)}

+        >

+            <img

+                src={imgUrl}

+                alt=""

+                className="reviewImage"

+                onError={(e) => (e.target.style.display = "none")}

+            />

+        </div>

+    );

+};

+

+/* ---------- Main App Component ---------- */

+

+export default function App() {

+    const {

+        user,

+        dbId,

+        loading,

+        syncing,

+        isSessionBlocked,

+        profileData,

+        mistakes,

+        history,

+        testPracticeStats,

+        totalTimeMap,

+        totalQuestionsMap,

+        login,

+        logout,

+        takeOverSession,

+        saveData,

+        refreshData,

+        triggerFakeSync,

+        setMistakes,

+        setHistory,

+    } = useUserProfile();

+

+    // --- KONSTANTA PRO LIMIT ---

+    const SMART_SAVE_LIMIT = 100;

+

+    const [subject, setSubject] = useState(null);

+    const [customQuestions, setCustomQuestions] = useState(null);

+

+    const [theme, setTheme] = useState(

+        () => localStorage.getItem("quizio_theme") || "dark",

+    );

+    const [activeQuestionsCache, setActiveQuestionsCache] = useState([]);

+    const [isLoadingQuestions, setIsLoadingQuestions] = useState(false);

+    const [isTransitioningSubject, setIsTransitioningSubject] = useState(false);

+    const [menuSelection, setMenuSelection] = useState(-1);

+    const [mode, setMode] = useState(null);

+    const [leaderboardEntries, setLeaderboardEntries] = useState([]);

+    const [leaderboardLoading, setLeaderboardLoading] = useState(false);

+    const [leaderboardError, setLeaderboardError] = useState(null);

+

+    const DUEL_ANSWER_SECONDS = 45;

+    const DUEL_RUSH_SECONDS = 10;

+    const DUEL_RESULT_SECONDS = 3;

+

+    const [duelOnlineUsers, setDuelOnlineUsers] = useState([]);

+    const [duelInvites, setDuelInvites] = useState([]);

+    const [duelInviteToShow, setDuelInviteToShow] = useState(null);

+    const [duelOutgoingMatch, setDuelOutgoingMatch] = useState(null);

+    const [duelActiveMatch, setDuelActiveMatch] = useState(null);

+    const [duelQuestionSet, setDuelQuestionSet] = useState([]);

+    const [duelAnswers, setDuelAnswers] = useState([]);

+    const [duelLocalAnswers, setDuelLocalAnswers] = useState({});

+    const [duelClock, setDuelClock] = useState(Date.now());

+    const [duelClockOffsetMs, setDuelClockOffsetMs] = useState(0);

+    const [duelRushOverride, setDuelRushOverride] = useState(null);

+    const [duelResultOverride, setDuelResultOverride] = useState(null);

+    const [duelStats, setDuelStats] = useState(null);

+    const [duelSettings, setDuelSettings] = useState({

+        questionCount: 10,

+        rangeMode: "all",

+        rangeStart: "",

+        rangeEnd: "",

+    });

+    const [duelError, setDuelError] = useState("");

+    const duelPresenceRef = useRef(null);

+    const duelFinalizeRef = useRef(false);

+

+    useEffect(() => {

+        const syncStateFromUrl = () => {

+            const params = new URLSearchParams(window.location.search);

+            const s = params.get("s");

+            const m = params.get("m");

+

+            if (s) setSubject(s.toUpperCase());

+            else setSubject(null);

+

+            if (m) setMode(m);

+            else setMode(null);

+        };

+

+        window.addEventListener("popstate", syncStateFromUrl);

+        syncStateFromUrl();

+        return () => window.removeEventListener("popstate", syncStateFromUrl);

+    }, []);

+

+    useEffect(() => {

+        if (!profileData?.class) {

+            setLeaderboardEntries([]);

+            return;

+        }

+

+        let isActive = true;

+

+        const fetchLeaderboard = async () => {

+            setLeaderboardLoading(true);

+            setLeaderboardError(null);

+

+            const { data, error } = await supabase

+                .from("profiles")

+                .select("id, username, subject_times, question_counts, class")

+                .eq("class", profileData.class);

+

+            if (!isActive) return;

+

+            if (error) {

+                setLeaderboardError(error.message);

+                setLeaderboardEntries([]);

+            } else {

+                const mapped = (data || [])

+                    .map((profile) => {

+                        const subjectTimes = profile.subject_times || {};

+                        const questionCounts = profile.question_counts || {};

+                        const totalTime = Object.values(subjectTimes).reduce(

+                            (sum, value) => sum + (value || 0),

+                            0,

+                        );

+                        const totalQuestions = Object.values(

+                            questionCounts,

+                        ).reduce((sum, value) => sum + (value || 0), 0);

+                        return {

+                            id: profile.id,

+                            username: profile.username,

+                            subjectTimes,

+                            questionCounts,

+                            totalTime,

+                            totalQuestions,

+                        };

+                    })

+                    .sort((a, b) => b.totalTime - a.totalTime);

+

+                setLeaderboardEntries(mapped);

+            }

+

+            setLeaderboardLoading(false);

+        };

+

+        fetchLeaderboard();

+

+        return () => {

+            isActive = false;

+        };

+    }, [profileData?.class]);

+

+    useEffect(() => {

+        if (!dbId || !user || !profileData?.class) return;

+

+        const channel = supabase.channel(

+            `duel_presence_${profileData.class}`,

+            {

+                config: { presence: { key: dbId } },

+            },

+        );

+

+        channel.on("presence", { event: "sync" }, () => {

+            const state = channel.presenceState();

+            const users = [];

+            Object.values(state).forEach((entries) => {

+                entries.forEach((entry) => {

+                    if (entry.user_id !== dbId) {

+                        users.push({

+                            id: entry.user_id,

+                            username: entry.username,

+                            class: entry.class,

+                        });

+                    }

+                });

+            });

+            setDuelOnlineUsers(users);

+        });

+

+        channel.subscribe((status) => {

+            if (status === "SUBSCRIBED") {

+                channel.track({

+                    user_id: dbId,

+                    username: user,

+                    class: profileData.class,

+                });

+            }

+        });

+

+        duelPresenceRef.current = channel;

+

+        return () => {

+            supabase.removeChannel(channel);

+            duelPresenceRef.current = null;

+        };

+    }, [dbId, user, profileData?.class]);

+

+    useEffect(() => {

+        if (!dbId) return;

+

+        const fetchStats = async () => {

+            const { data } = await supabase

+                .from("duel_stats")

+                .select("*")

+                .eq("user_id", dbId)

+                .maybeSingle();

+            if (data) setDuelStats(data);

+            else

+                setDuelStats({

+                    trophies: 0,

+                    wins: 0,

+                    losses: 0,

+                    draws: 0,

+                });

+        };

+

+        fetchStats();

+    }, [dbId]);

+

+    useEffect(() => {

+        if (!dbId) return;

+

+        let isActive = true;

+

+        const fetchInvites = async () => {

+            const { data: incoming } = await supabase

+                .from("duel_matches")

+                .select("*")

+                .eq("opponent_id", dbId)

+                .eq("status", "pending");

+

+            const { data: outgoing } = await supabase

+                .from("duel_matches")

+                .select("*")

+                .eq("challenger_id", dbId)

+                .in("status", ["pending", "active"]);

+

+            if (!isActive) return;

+            setDuelInvites(incoming || []);

+            setDuelOutgoingMatch(outgoing?.[0] || null);

+            if (outgoing?.[0]?.status === "active") {

+                setDuelActiveMatch(outgoing[0]);

+                setMode("duel_match");

+            }

+        };

+

+        fetchInvites();

+

+        const channel = supabase

+            .channel(`duel_matches_${dbId}`)

+            .on(

+                "postgres_changes",

+                {

+                    event: "*",

+                    schema: "public",

+                    table: "duel_matches",

+                    filter: `opponent_id=eq.${dbId}`,

+                },

+                (payload) => {

+                    const match = payload.new;

+                    if (!match) return;

+

+                    if (match.status === "pending") {

+                        setDuelInvites((prev) => {

+                            const exists = prev.find((i) => i.id === match.id);

+                            if (exists) return prev;

+                            return [...prev, match];

+                        });

+                    } else {

+                        setDuelInvites((prev) =>

+                            prev.filter((i) => i.id !== match.id),

+                        );

+                    }

+

+                    if (match.status === "active") {

+                        setDuelActiveMatch(match);

+                        duelFinalizeRef.current = false;

+                        if (subject !== match.subject) setSubject(match.subject);

+                        setMode("duel_match");

+                    }

+                },

+            )

+            .on(

+                "postgres_changes",

+                {

+                    event: "*",

+                    schema: "public",

+                    table: "duel_matches",

+                    filter: `challenger_id=eq.${dbId}`,

+                },

+                (payload) => {

+                    const match = payload.new;

+                    if (!match) return;

+

+                    if (match.status === "pending") {

+                        setDuelOutgoingMatch(match);

+                    } else if (match.status === "active") {

+                        setDuelOutgoingMatch(null);

+                        setDuelActiveMatch(match);

+                        duelFinalizeRef.current = false;

+                        if (subject !== match.subject) setSubject(match.subject);

+                        setMode("duel_match");

+                    } else if (

+                        match.status === "declined" ||

+                        match.status === "cancelled"

+                    ) {

+                        setDuelOutgoingMatch(null);

+                    }

+                },

+            )

+            .subscribe();

+

+        return () => {

+            isActive = false;

+            supabase.removeChannel(channel);

+        };

+    }, [dbId, subject]);

+

+    useEffect(() => {

+        if (mode === "real_test") return;

+        if (!duelInviteToShow && duelInvites.length > 0) {

+            setDuelInviteToShow(duelInvites[0]);

+        }

+    }, [duelInvites, duelInviteToShow, mode]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.id) return;

+

+        const channel = supabase

+            .channel(`duel_match_${duelActiveMatch.id}`)

+            .on(

+                "postgres_changes",

+                {

+                    event: "UPDATE",

+                    schema: "public",

+                    table: "duel_matches",

+                    filter: `id=eq.${duelActiveMatch.id}`,

+                },

+                (payload) => {

+                    const match = payload.new;

+                    if (!match) return;

+                    setDuelActiveMatch(match);

+                    if (

+                        match.status === "completed" ||

+                        match.status === "cancelled" ||

+                        match.status === "declined"

+                    ) {

+                        supabase.from("duel_matches").delete().eq("id", match.id);

+                        if (match.status !== "completed") {

+                            setDuelActiveMatch(null);

+                            setDuelAnswers([]);

+                            setDuelQuestionSet([]);

+                            setDuelLocalAnswers({});

+                            setDuelRushOverride(null);

+                            setDuelResultOverride(null);

+                            setMode("duel");

+                        }

+                    }

+                },

+            )

+            .subscribe();

+

+        return () => {

+            supabase.removeChannel(channel);

+        };

+    }, [duelActiveMatch?.id]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.id) return;

+        setDuelLocalAnswers({});

+    }, [duelActiveMatch?.id]);

+

+    useEffect(() => {

+        if (!duelAnswers.length) return;

+        const latestAnswerAt = duelAnswers

+            .map((answer) => new Date(answer.answered_at).getTime())

+            .filter(Number.isFinite)

+            .sort((a, b) => b - a)[0];

+        if (!latestAnswerAt) return;

+        setDuelClockOffsetMs(latestAnswerAt - Date.now());

+    }, [duelAnswers]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.started_at) return;

+        if (duelAnswers.length) return;

+        const startAt = new Date(duelActiveMatch.started_at).getTime();

+        if (!Number.isFinite(startAt)) return;

+        setDuelClockOffsetMs(startAt - Date.now());

+    }, [duelActiveMatch?.started_at, duelAnswers.length]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.started_at) return;

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        if (progress.phase !== "answer") {

+            if (duelRushOverride) setDuelRushOverride(null);

+            if (duelResultOverride) setDuelResultOverride(null);

+            return;

+        }

+        if (

+            duelRushOverride &&

+            duelRushOverride.questionIndex !== progress.index

+        ) {

+            setDuelRushOverride(null);

+        }

+        if (

+            duelResultOverride &&

+            duelResultOverride.questionIndex !== progress.index

+        ) {

+            setDuelResultOverride(null);

+        }

+    }, [

+        duelClock,

+        duelActiveMatch?.started_at,

+        duelRushOverride,

+        duelResultOverride,

+    ]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.started_at) return;

+        if (!duelAnswers.length) return;

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        if (progress.phase !== "answer") return;

+        const questionIndex = progress.index;

+        const answer = duelAnswers.find(

+            (item) => item.question_index === questionIndex,

+        );

+        if (!answer) return;

+        const answeredAt = new Date(answer.answered_at).getTime();

+        if (!Number.isFinite(answeredAt)) return;

+        if (progress.timeLeft <= DUEL_RUSH_SECONDS) return;

+        const endAt = answeredAt + DUEL_RUSH_SECONDS * 1000;

+        setDuelRushOverride((prev) => {

+            if (

+                prev &&

+                prev.questionIndex === questionIndex &&

+                prev.endAt <= endAt

+            )

+                return prev;

+            return { questionIndex, endAt };

+        });

+    }, [duelAnswers, duelClock, duelActiveMatch?.started_at]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.started_at) return;

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        if (progress.phase !== "answer") return;

+        const questionIndex = progress.index;

+        const opponent = getDuelOpponent(duelActiveMatch);

+        if (!opponent || !dbId) return;

+

+        const myAnswer = getAnswerFor(dbId, questionIndex);

+        const opponentAnswer = getAnswerFor(opponent.id, questionIndex);

+        const hasMine =

+            !!myAnswer || !!duelLocalAnswers[questionIndex];

+        const hasOpponent = !!opponentAnswer;

+        if (!hasMine || !hasOpponent) return;

+

+        const myAnsweredAt = myAnswer

+            ? new Date(myAnswer.answered_at).getTime()

+            : duelLocalAnswers[questionIndex]?.answeredAt;

+        const opponentAnsweredAt = opponentAnswer

+            ? new Date(opponentAnswer.answered_at).getTime()

+            : null;

+        const latestAnsweredAt = Math.max(

+            myAnsweredAt || 0,

+            opponentAnsweredAt || 0,

+            duelClock,

+        );

+        const endAt = latestAnsweredAt + DUEL_RESULT_SECONDS * 1000;

+

+        setDuelResultOverride((prev) => {

+            if (

+                prev &&

+                prev.questionIndex === questionIndex &&

+                prev.endAt >= endAt

+            ) {

+                return prev;

+            }

+            return { questionIndex, endAt };

+        });

+    }, [

+        duelAnswers,

+        duelLocalAnswers,

+        duelClock,

+        duelActiveMatch?.started_at,

+        dbId,

+    ]);

+

+    useEffect(() => {

+        if (!duelAnswers.length) return;

+        const confirmed = new Set(

+            duelAnswers

+                .filter((answer) => answer.user_id === dbId)

+                .map((answer) => answer.question_index),

+        );

+        if (confirmed.size === 0) return;

+        setDuelLocalAnswers((prev) => {

+            const next = { ...prev };

+            confirmed.forEach((idx) => {

+                delete next[idx];

+            });

+            return next;

+        });

+    }, [duelAnswers, dbId]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.id) return;

+

+        const fetchAnswers = async () => {

+            const { data } = await supabase

+                .from("duel_answers")

+                .select("*")

+                .eq("match_id", duelActiveMatch.id);

+            setDuelAnswers(data || []);

+        };

+

+        fetchAnswers();

+

+        const channel = supabase

+            .channel(`duel_answers_${duelActiveMatch.id}`)

+            .on(

+                "postgres_changes",

+                {

+                    event: "*",

+                    schema: "public",

+                    table: "duel_answers",

+                    filter: `match_id=eq.${duelActiveMatch.id}`,

+                },

+                (payload) => {

+                    if (payload.eventType === "DELETE") {

+                        setDuelAnswers((prev) =>

+                            prev.filter((a) => a.id !== payload.old.id),

+                        );

+                        return;

+                    }

+                    const answer = payload.new;

+                    if (!answer) return;

+                    setDuelAnswers((prev) => {

+                        const idx = prev.findIndex((a) => a.id === answer.id);

+                        if (idx === -1) return [...prev, answer];

+                        const next = [...prev];

+                        next[idx] = answer;

+                        return next;

+                    });

+                },

+            )

+            .subscribe();

+

+        return () => {

+            supabase.removeChannel(channel);

+        };

+    }, [duelActiveMatch?.id]);

+

+    useEffect(() => {

+        if (!duelActiveMatch) return;

+        const ids = duelActiveMatch.question_ids || [];

+        if (ids.length === 0) {

+            setDuelQuestionSet([]);

+            return;

+        }

+

+        const syncQuestions = async () => {

+            const localMap = new Map(

+                activeQuestionsCache.map((q) => [q.id, q]),

+            );

+            const missing = ids.filter((id) => !localMap.has(id));

+            let fetched = [];

+

+            if (missing.length > 0) {

+                const { data } = await supabase

+                    .from("questions")

+                    .select(

+                        "id, number, subject, question, options, correct_index, is_active, updated_at",

+                    )

+                    .in("id", missing);

+

+                fetched =

+                    data?.map((item) => ({

+                        ...item,

+                        correctIndex: item.correct_index,

+                        options: Array.isArray(item.options) ? item.options : [],

+                    })) || [];

+            }

+

+            fetched.forEach((item) => localMap.set(item.id, item));

+            const ordered = ids.map((id) => localMap.get(id)).filter(Boolean);

+            setDuelQuestionSet(ordered);

+        };

+

+        syncQuestions();

+    }, [duelActiveMatch, activeQuestionsCache]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.id) return;

+        const timer = setInterval(() => {

+            setDuelClock(Date.now() + duelClockOffsetMs);

+        }, 500);

+        return () => clearInterval(timer);

+    }, [duelActiveMatch?.id, duelClockOffsetMs]);

+

+    useEffect(() => {

+        if (!duelActiveMatch?.started_at) return;

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        if (progress.phase === "finished") finalizeDuelMatch();

+    }, [duelClock, duelActiveMatch, duelAnswers, duelQuestionSet]);

+

+    useEffect(() => {

+        if (mode === "loading") return;

+        const params = new URLSearchParams();

+        if (subject) params.set("s", subject.toLowerCase());

+        if (mode) params.set("m", mode);

+

+        const newUrl =

+            window.location.pathname +

+            (params.toString() ? "?" + params.toString() : "");

+        if (

+            window.location.search !== "?" + params.toString() &&

+            !(window.location.search === "" && params.toString() === "")

+        ) {

+            window.history.pushState({ subject, mode }, "", newUrl);

+        }

+    }, [subject, mode]);

+

+    const [showSmartSettings, setShowSmartSettings] = useState(false);

+    const [showResumePrompt, setShowResumePrompt] = useState(false);

+    const [showSaveProgressPrompt, setShowSaveProgressPrompt] = useState(false);

+

+    const [showClearMistakesConfirm, setShowClearMistakesConfirm] =

+        useState(false);

+    const [searchTerm, setSearchTerm] = useState("");

+    const [reviewPage, setReviewPage] = useState(0);

+    const [questionSet, setQuestionSet] = useState([]);

+    const [currentIndex, setCurrentIndex] = useState(0);

+    const [selectedAnswer, setSelectedAnswer] = useState(null);

+    const [showResult, setShowResult] = useState(false);

+    const [score, setScore] = useState({ correct: 0, total: 0 });

+    const [combo, setCombo] = useState(0);

+    const [shake, setShake] = useState(false);

+    const [timeLeft, setTimeLeft] = useState(0);

+    const [finished, setFinished] = useState(false);

+

+    // --- CENTR´┐ŻLN´┐Ż FUNKCE PRO ULO´┐ŻEN´┐Ż SMART SESSION ---

+    const persistSmartSession = async (currentSet, idx, currentScore) => {

+        if (!subject || !dbId || isSessionBlocked) return;

+        if (currentSet.length > SMART_SAVE_LIMIT) return; // Limit

+

+        // 1. Znskome aktu,ln´┐Ż data z profilu (pro zachov´┐Żn´┐Ż ostatn´┐Żch p´┐Żedm´┐Żt´┐Ż)

+        const existingSessions = profileData?.smart_session || {};

+

+        // 2. Data pro aktu´┐Żln´┐Ż p´┐Żedm´┐Żt

+        const questionIds = currentSet.map((q) => q.number);

+        const sessionData = {

+            ids: questionIds,

+            index: idx,

+            score: currentScore,

+            timestamp: Date.now(),

+        };

+

+        // 3. Merge: Existuj´┐Żc´┐Ż + Aktu´┐Żln´┐Ż

+        const updatedSessions = {

+            ...existingSessions,

+            [subject]: sessionData,

+        };

+

+        // 4. Odesltnt

+        await saveData({ smart_session: updatedSessions });

+    };

+

+    // Funkce pro smaz´┐Żn´┐Ż ulo´┐Żen´┐Żho postupu (vol´┐Ż se p´┐Żi dokon´┐Żen´┐Ż)

+    const clearSmartSession = async () => {

+        if (!subject) return;

+        const currentSessions = profileData?.smart_session || {};

+

+        // Vytvoiome kopii a smaeeme klue aktuslnuho p edm{tu

+        const updatedSessions = { ...currentSessions };

+        delete updatedSessions[subject];

+

+        await saveData({ smart_session: updatedSessions });

+        // console.log("Smart session vy´┐Żi´┐Żt´┐Żna manu´┐Żln´┐Ż.");

+    };

+

+    // --- AUTOMATICK´┐Ż UKL´┐ŻD´┐ŻN´┐Ż (Backup p´┐Żes useEffect) ---

+    // Ukl´┐Żd´┐Ż p´┐Żi zm´┐Żn´┐Ż indexu (nap´┐Ż. posun ´┐Żipkou)

+    useEffect(() => {

+        if (

+            mode === "smart" &&

+            !finished &&

+            questionSet.length > 0 &&

+            subject &&

+            questionSet.length <= SMART_SAVE_LIMIT

+        ) {

+            const timer = setTimeout(() => {

+                persistSmartSession(questionSet, currentIndex, score);

+            }, 500); // Debounce pro navigaci

+            return () => clearTimeout(timer);

+        }

+    }, [

+        mode,

+        currentIndex,

+        score,

+        finished,

+        subject,

+        questionSet,

+        profileData,

+    ]);

+

+    // --- ZAJI´┐ŻT´┐ŻN´┐Ż SCROLLU NAHORU P´┐ŻI ZM´┐ŻN´┐Ż OT´┐ŻZKY (UNIVERZ´┐ŻLN´┐Ż) ---

+    // Toto zajist´┐Ż, ´┐Że p´┐Żi ka´┐Żd´┐Ż zm´┐Żn´┐Ż indexu nebo re´┐Żimu se str´┐Żnka posune nahoru.

+    useEffect(() => {

+        if (containerRef.current) {

+            containerRef.current.scrollTop = 0;

+        }

+        window.scrollTo({ top: 0, behavior: "instant" });

+    }, [currentIndex, mode, subject]); // Spust´┐Ż se p´┐Żi zm´┐Żn´┐Ż indexu, m´┐Żdu nebo p´┐Żedm´┐Żtu

+    // -----------------------------------------------------------------

+

+    useEffect(() => {

+        window.currentTestIndex = currentIndex;

+        window.totalTestQuestions = questionSet.length;

+        return () => {

+            window.currentTestIndex = undefined;

+            window.totalTestQuestions = undefined;

+        };

+    }, [currentIndex, questionSet.length]);

+

+    const [maxSeenIndex, setMaxSeenIndex] = useState(0);

+    const [trainingTime, setTrainingTime] = useState(0);

+

+    const [showConfirmSubmit, setShowConfirmSubmit] = useState(false);

+    const [showConfirmExit, setShowConfirmExit] = useState(false);

+    const [recordToDelete, setRecordToDelete] = useState(null);

+    const [fullscreenImage, setFullscreenImage] = useState(null);

+    const [timeLeftAtSubmit, setTimeLeftAtSubmit] = useState(0);

+

+    const { isKeyboardMode, setIsKeyboardMode } = useGlobalKeyboard();

+    const { sessionTime, setSessionTime, isAfk } = useActivityDetection(

+        mode,

+        isSessionBlocked,

+    );

+

+    const [direction, setDirection] = useState("right");

+    const [exitDirection, setExitDirection] = useState(null);

+

+    const [reportModalOpen, setReportModalOpen] = useState(false);

+    const [questionToReport, setQuestionToReport] = useState(null);

+

+    const [scheduledTests, setScheduledTests] = useState([]);

+    const [activeTest, setActiveTest] = useState(null);

+    const [completedTestIds, setCompletedTestIds] = useState([]);

+    const [testToStart, setTestToStart] = useState(null);

+

+    const optionRefsForCurrent = useRef({});

+    const cardRef = useRef(null);

+    const containerRef = useRef(null);

+

+    const [sessionQuestionsCount, setSessionQuestionsCount] = useState(0);

+    const [readyQuestionId, setReadyQuestionId] = useState(null);

+    const [loadingProgress, setLoadingProgress] = useState(0);

+

+    const currentQuestion = questionSet[currentIndex] || {

+        question: "",

+        options: [],

+        correctIndex: 0,

+        number: 0,

+        _localIndex: currentIndex,

+    };

+    const currentQuestionId =

+        currentQuestion.id || currentQuestion.number || currentIndex;

+    const isContentReady = readyQuestionId === currentQuestionId;

+    const isTeacher = user === "admin" || user === "U(itel";

+

+    useEffect(() => {

+        const savedCode = localStorage.getItem("quizio_user_code");

+        if (savedCode && !user && !loading) {

+            login(savedCode);

+        }

+    }, []);

+

+    const saveDataToCloud = async (

+        newMistakes,

+        newHistory,

+        timeToAdd = 0,

+        questionsToAdd = 0,

+        newTestStats = null,

+    ) => {

+        const updates = {};

+        if (newMistakes !== undefined) updates.mistakes = newMistakes;

+        if (newHistory !== undefined) updates.history = newHistory;

+        if (newTestStats !== null) updates.test_practice_stats = newTestStats;

+        if (timeToAdd > 0 && subject) {

+            const currentSubjectTime = totalTimeMap[subject] || 0;

+            updates.subject_times = {

+                ...totalTimeMap,

+                [subject]: currentSubjectTime + timeToAdd,

+            };

+            setSessionTime(0);

+        }

+        if (questionsToAdd > 0 && subject) {

+            const currentCount = totalQuestionsMap[subject] || 0;

+            updates.question_counts = {

+                ...totalQuestionsMap,

+                [subject]: currentCount + questionsToAdd,

+            };

+            setSessionQuestionsCount(0);

+        }

+        if (Object.keys(updates).length > 0) await saveData(updates);

+    };

+

+    const flushSessionStats = () => {

+        if (sessionTime > 0 || sessionQuestionsCount > 0) {

+            saveDataToCloud(

+                undefined,

+                undefined,

+                sessionTime,

+                sessionQuestionsCount,

+            );

+        }

+    };

+

+    const fetchScheduledTests = async () => {

+        if (!subject || subject === "CUSTOM") return;

+        const { data } = await supabase

+            .from("scheduled_tests")

+            .select("*")

+            .eq("subject", subject)

+            .order("close_at", { ascending: true });

+        if (data) setScheduledTests(data);

+    };

+

+    const fetchCompletedTests = async () => {

+        if (!user || !dbId) {

+            setCompletedTestIds([]);

+            return;

+        }

+        const { data } = await supabase

+            .from("test_results")

+            .select("test_id")

+            .eq("user_id", dbId);

+        if (data) {

+            const ids = [...new Set(data.map((item) => item.test_id))];

+            setCompletedTestIds(ids);

+        }

+    };

+

+    useEffect(() => {

+        if (!subject || subject === "CUSTOM") return;

+        fetchScheduledTests();

+        const sub = supabase

+            .channel("tests_update")

+            .on(

+                "postgres_changes",

+                { event: "*", schema: "public", table: "scheduled_tests" },

+                fetchScheduledTests,

+            )

+            .subscribe();

+        return () => supabase.removeChannel(sub);

+    }, [subject]);

+

+    useEffect(() => {

+        if (!user || !dbId) {

+            setCompletedTestIds([]);

+            return;

+        }

+        fetchCompletedTests();

+        const sub = supabase

+            .channel("my_results_update")

+            .on(

+                "postgres_changes",

+                {

+                    event: "INSERT",

+                    schema: "public",

+                    table: "test_results",

+                    filter: `user_id=eq.${dbId}`,

+                },

+                (payload) =>

+                    setCompletedTestIds((prev) => [

+                        ...prev,

+                        payload.new.test_id,

+                    ]),

+            )

+            .on(

+                "postgres_changes",

+                { event: "DELETE", schema: "public", table: "test_results" },

+                fetchCompletedTests,

+            )

+            .subscribe();

+        return () => supabase.removeChannel(sub);

+    }, [user, dbId]);

+

+    const handleManualRefresh = async () => {

+        await Promise.all([

+            fetchScheduledTests(),

+            fetchCompletedTests(),

+            refreshData(),

+        ]);

+    };

+

+    const handleTestCompletion = (testId) => {

+        setCompletedTestIds((prev) =>

+            prev.includes(testId) ? prev : [...prev, testId],

+        );

+    };

+

+    const triggerHaptic = (type) => {

+        if (typeof navigator !== "undefined" && navigator.vibrate) {

+            if (type === "success") navigator.vibrate(50);

+            else if (type === "error") navigator.vibrate([50, 100, 50]);

+            else if (type === "light") navigator.vibrate(10);

+        }

+    };

+

+    const updateMistakes = (newValOrFn) => {

+        const next =

+            typeof newValOrFn === "function"

+                ? newValOrFn(mistakes)

+                : newValOrFn;

+        setMistakes(next);

+        saveDataToCloud(next, undefined);

+    };

+

+    const updateHistory = (newValOrFn) => {

+        const next =

+            typeof newValOrFn === "function" ? newValOrFn(history) : newValOrFn;

+        setHistory(next);

+        saveDataToCloud(undefined, next);

+    };

+

+    const handleLogout = () => {

+        flushSessionStats();

+        setSubject(null);

+        setMode(null);

+        logout();

+    };

+

+    const openHistoryWithRefresh = async () => {

+        flushSessionStats();

+        setMode("history");

+        await refreshData();

+    };

+

+    useEffect(() => {

+        if (sessionTime >= 60 || sessionQuestionsCount >= 10)

+            saveDataToCloud(

+                undefined,

+                undefined,

+                sessionTime,

+                sessionQuestionsCount,

+            );

+    }, [sessionTime, sessionQuestionsCount]);

+

+    useEffect(() => {

+        localStorage.setItem("quizio_theme", theme);

+        document.body.className = theme === "light" ? "light-mode" : "";

+        document.documentElement.setAttribute("data-theme", theme);

+        window.dispatchEvent(new Event("storage"));

+

+        if (theme === "light")

+            document.documentElement.style.backgroundColor = "#f8fafc";

+        else document.documentElement.style.backgroundColor = "#0a0e27";

+    }, [theme]);

+

+    const toggleTheme = () => {

+        setTheme((prev) => {

+            const next = prev === "dark" ? "light" : "dark";

+            return next;

+        });

+    };

+

+    const prepareQuestionSet = (

+        baseQuestions,

+        shouldShuffleOptions = false,

+    ) => {

+        if (!Array.isArray(baseQuestions)) return [];

+        return baseQuestions.map((q, idx) => {

+            let options = [...(q.options || [])];

+            let correctIndex = q.correctIndex;

+

+            if (shouldShuffleOptions) {

+                const optionsWithMeta = options.map((opt, i) => ({

+                    text: opt,

+                    isCorrect: i === correctIndex,

+                }));

+                // Fisher-Yates shuffle

+                for (let i = optionsWithMeta.length - 1; i > 0; i--) {

+                    const j = Math.floor(Math.random() * (i + 1));

+                    [optionsWithMeta[i], optionsWithMeta[j]] = [

+                        optionsWithMeta[j],

+                        optionsWithMeta[i],

+                    ];

+                }

+                options = optionsWithMeta.map((o) => o.text);

+                correctIndex = optionsWithMeta.findIndex((o) => o.isCorrect);

+            }

+

+            return {

+                ...q,

+                options,

+                correctIndex,

+                userAnswer: undefined,

+                _localIndex: idx,

+                _instanceId: Math.random(),

+            };

+        });

+    };

+

+    useEffect(() => {

+        const fetchQuestions = async () => {

+            if (!subject) {

+                setActiveQuestionsCache([]);

+                return;

+            }

+            if (subject === "CUSTOM") {

+                setActiveQuestionsCache(

+                    prepareQuestionSet(customQuestions || []),

+                );

+                return;

+            }

+

+            setIsLoadingQuestions(true);

+            const minDelay = new Promise((resolve) => setTimeout(resolve, 500));

+

+            try {

+                const { data, error } =

+                    await fetchQuestionsLightweight(subject);

+                await minDelay;

+                if (error) throw error;

+                if (data && data.length > 0) {

+                    const mappedData = data.map((item) => ({

+                        ...item,

+                        correctIndex: item.correct_index,

+                        options: Array.isArray(item.options)

+                            ? item.options

+                            : [],

+                    }));

+                    setActiveQuestionsCache(prepareQuestionSet(mappedData));

+                } else {

+                    setActiveQuestionsCache([]);

+                }

+            } catch (err) {

+                console.error("Chyba p´┐Żi stahov´┐Żn´┐Ż ot├ízek:", err);

+                alert("Nepodaiilo se st´┐Żhnout ot´┐Żzky z cloudu.");

+                setActiveQuestionsCache([]);

+            } finally {

+                setIsLoadingQuestions(false);

+                setIsTransitioningSubject(false);

+            }

+        };

+        fetchQuestions();

+    }, [subject, customQuestions]);

+

+    // --- LOGIKA PRO OBNOVEN´┐Ż SMART RELACE ---

+    const checkSmartSession = () => {

+        const savedSession = profileData?.smart_session?.[subject];

+        if (savedSession && savedSession.ids && savedSession.ids.length > 0) {

+            // M"me ulorenou relaci, zept´┐Żme se u´┐Żivatele

+            setShowResumePrompt(true);

+        } else {

+            // e(dnc relace, otevteme nastaven´┐Ż pro novou

+            setShowSmartSettings(true);

+        }

+    };

+

+    const resumeSmartSession = async () => {

+        setShowResumePrompt(false);

+        const savedSession = profileData?.smart_session?.[subject];

+        if (!savedSession) return;

+

+        setMode("loading");

+        setLoadingProgress(0);

+

+        const sessionIds = savedSession.ids;

+        const reorderedQuestions = [];

+

+        sessionIds.forEach((id) => {

+            const found = activeQuestionsCache.find((q) => q.number === id);

+            if (found) {

+                reorderedQuestions.push({

+                    ...found,

+                    _instanceId: Math.random(),

+                    userAnswer: undefined,

+                });

+            }

+        });

+

+        const startIndex = savedSession.index || 0;

+        const subsetToPreload = reorderedQuestions.slice(

+            startIndex,

+            startIndex + 5,

+        );

+        await preloadTestImages(subsetToPreload, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setQuestionSet(reorderedQuestions);

+        setCurrentIndex(startIndex);

+        setScore(savedSession.score || { correct: 0, total: 0 });

+

+        setReadyQuestionId(null);

+        setMode("smart");

+        setFinished(false);

+        setSelectedAnswer(null);

+        setShowResult(false);

+        setIsKeyboardMode(false);

+        setTrainingTime(0);

+        setCombo(0);

+    };

+

+    const startNewSmartSession = async (count) => {

+        setShowResumePrompt(false);

+        setShowSmartSettings(false);

+

+        // Pokud startujeme novou, sma´┐Żeme tu starou z cloudu

+        const currentSmartSessions = profileData?.smart_session || {};

+        const updatedSessions = { ...currentSmartSessions };

+        delete updatedSessions[subject];

+        saveData({ smart_session: updatedSessions });

+

+        let pool = activeQuestionsCache;

+        if (!pool || pool.length === 0) {

+            alert("codne ot zky nejsou k dispozici.");

+            return;

+        }

+

+        let shuffled = [...pool]

+            .sort(() => Math.random() - 0.5)

+            .map((q, idx) => ({

+                ...q,

+                _localIndex: idx,

+                _instanceId: Math.random(),

+            }));

+        if (count !== "all" && typeof count === "number")

+            shuffled = shuffled.slice(0, count);

+

+        // P ednainttnn

+        setMode("loading");

+        setLoadingProgress(0);

+

+        const subsetToPreload = shuffled.slice(0, 5);

+        await preloadTestImages(subsetToPreload, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setReadyQuestionId(null);

+        setQuestionSet(shuffled);

+        setMode("smart");

+        setCurrentIndex(0);

+        setScore({ correct: 0, total: 0 });

+        setFinished(false);

+        setSelectedAnswer(null);

+        setShowResult(false);

+        setIsKeyboardMode(false);

+        setTrainingTime(0);

+        setCombo(0);

+

+        // Hned ulocome po: te no stav

+        if (shuffled.length <= SMART_SAVE_LIMIT) {

+            persistSmartSession(shuffled, 0, { correct: 0, total: 0 });

+        }

+    };

+

+    // --- END SMART LOGIC ---

+

+    const startTestPractice = async (test) => {

+        const pool = activeQuestionsCache.filter(

+            (q) =>

+                q.number >= test.topic_range_start &&

+                q.number <= test.topic_range_end,

+        );

+        if (pool.length === 0) {

+            alert("addng ot´┐Żzky v rozsahu.");

+            return;

+        }

+        const shuffled = [...pool]

+            .sort(() => Math.random() - 0.5)

+            .map((q, idx) => ({

+                ...q,

+                _localIndex: idx,

+                _instanceId: Math.random(),

+            }));

+

+        setMode("loading");

+        setLoadingProgress(0);

+

+        const subsetToPreload = shuffled.slice(0, 5);

+        await preloadTestImages(subsetToPreload, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setReadyQuestionId(null);

+        setQuestionSet(shuffled);

+        setMode("test_practice");

+        setActiveTest(test);

+        setCurrentIndex(0);

+        setScore({ correct: 0, total: 0 });

+        setFinished(false);

+        setSelectedAnswer(null);

+        setShowResult(false);

+        setCombo(0);

+    };

+

+    const confirmStartTest = async () => {

+        if (!testToStart) return;

+        setTestToStart(null);

+

+        const test = testToStart;

+        const pool = activeQuestionsCache.filter(

+            (q) =>

+                q.number >= test.topic_range_start &&

+                q.number <= test.topic_range_end,

+        );

+        const selected = [...pool]

+            .sort(() => Math.random() - 0.5)

+            .slice(0, test.question_count);

+        const prepared = prepareQuestionSet(selected, true);

+

+        setMode("loading");

+        setLoadingProgress(0);

+        await preloadTestImages(prepared, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setQuestionSet(prepared);

+        setActiveTest(test);

+        setReadyQuestionId(null);

+        setMode("real_test");

+    };

+

+    const startGradedTest = async (test) => {

+        const now = new Date();

+        if (!test.open_at || !test.close_at) {

+            alert("Tento test nem´┐Ż stanoven´┐Ż term´┐Żn.");

+            return;

+        }

+        if (now < new Date(test.open_at)) {

+            alert("Test jeutb nen= otev´┐Żen.");

+            return;

+        }

+        if (now > new Date(test.close_at)) {

+            alert("Test je ji[ uzavcen.");

+            return;

+        }

+        if (completedTestIds.includes(test.id)) {

+            alert("Tento test jste ji´┐Ż vypracovali.");

+            return;

+        }

+        setTestToStart(test);

+    };

+

+    const startRandomMode = async () => {

+        const pool = activeQuestionsCache;

+        if (!pool || pool.length === 0) {

+            alert("´┐Ż´┐Żdn´┐Ż ot´┐Żzky nejsou k dispozici.");

+            return;

+        }

+

+        setScore({ correct: 0, total: 0 });

+        setFinished(false);

+        setShowResult(false);

+        setSelectedAnswer(null);

+        setCurrentIndex(0);

+        setCombo(0);

+        setIsKeyboardMode(false);

+        setReadyQuestionId(null);

+

+        const shuffled = [...pool]

+            .sort(() => Math.random() - 0.5)

+            .map((q, idx) => ({

+                ...q,

+                _localIndex: idx,

+                _instanceId: Math.random(),

+            }));

+

+        setMode("loading");

+        setLoadingProgress(0);

+

+        const subsetToPreload = shuffled.slice(0, 5);

+        await preloadTestImages(subsetToPreload, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setQuestionSet(shuffled);

+        setMode("random");

+    };

+    const startMockTest = async () => {

+        const pool = activeQuestionsCache;

+        if (!pool || pool.length === 0) {

+            alert("´┐Ż´┐Żdn´┐Ż ot´┐Żzky nejsou k dispozici.");

+            return;

+        }

+

+        setScore({ correct: 0, total: 0 });

+        setFinished(false);

+        setShowResult(false);

+        setSelectedAnswer(null);

+        setCurrentIndex(0);

+        setMaxSeenIndex(0);

+        setCombo(0);

+        setIsKeyboardMode(false);

+        setReadyQuestionId(null);

+

+        const sel = [...pool]

+            .sort(() => Math.random() - 0.5)

+            .slice(0, Math.min(40, pool.length));

+        const prepared = prepareQuestionSet(sel, true);

+

+        setMode("loading");

+        setLoadingProgress(0);

+        await preloadTestImages(prepared, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setQuestionSet(prepared);

+        setTimeLeft(1800);

+        setMode("mock");

+    };

+    const startMistakesMode = async () => {

+        const all = activeQuestionsCache;

+        if (!all || all.length === 0) {

+            alert("iodn  ot´┐Żzky nejsou k dispozici.");

+            return;

+        }

+        const userMistakes = mistakes[subject] || [];

+        const filtered = all.filter((q) => userMistakes.includes(q.number));

+        if (filtered.length === 0) {

+            setMode("no_mistakes");

+            return;

+        }

+

+        const shuffled = [...filtered]

+            .sort(() => Math.random() - 0.5)

+            .map((q, idx) => ({

+                ...q,

+                _localIndex: idx,

+                _instanceId: Math.random(),

+            }));

+

+        setMode("loading");

+        setLoadingProgress(0);

+

+        const subsetToPreload = shuffled.slice(0, 5);

+        await preloadTestImages(subsetToPreload, (progress) => {

+            setLoadingProgress(progress);

+        });

+

+        setReadyQuestionId(null);

+        setQuestionSet(shuffled);

+        setMode("mistakes");

+        setCurrentIndex(0);

+        setScore({ correct: 0, total: 0 });

+        setFinished(false);

+        setSelectedAnswer(null);

+        setShowResult(false);

+        setIsKeyboardMode(false);

+        setTrainingTime(0);

+        setCombo(0);

+    };

+

+    const startReviewMode = () => {

+        const all = activeQuestionsCache;

+        if (!all || all.length === 0) {

+            alert("´┐Ż´┐Żdn´┐Ż ot´┐Żzky nejsou k dispozici.");

+            return;

+        }

+        setQuestionSet(all);

+        setMode("review");

+        setCombo(0);

+        setReviewPage(0);

+        setSearchTerm("");

+    };

+

+    const addMistake = (qNumber) =>

+        updateMistakes((prev) => {

+            const cur = prev[subject] || [];

+            return !cur.includes(qNumber)

+                ? { ...prev, [subject]: [...cur, qNumber] }

+                : prev;

+        });

+    const removeMistake = (qNumber) =>

+        updateMistakes((prev) => {

+            const cur = prev[subject] || [];

+            return cur.includes(qNumber)

+                ? { ...prev, [subject]: cur.filter((n) => n !== qNumber) }

+                : prev;

+        });

+    const clearMistakes = () => {

+        updateMistakes((prev) => ({ ...prev, [subject]: [] }));

+        setShowClearMistakesConfirm(false);

+    };

+    const handleSelectSubject = (subj) => {

+        if (subj === "CUSTOM") {

+            setShowCustomImport(true);

+            return;

+        }

+        setIsTransitioningSubject(true);

+        setSubject(subj.toUpperCase());

+        setMenuSelection(0);

+        setMode(null);

+    };

+    const handleStartMode = (startFn, modeName) => {

+        if (modeName === "smart") {

+            checkSmartSession();

+            return;

+        }

+        startFn();

+    };

+

+    const shuffleArray = (list) => {

+        const arr = [...list];

+        for (let i = arr.length - 1; i > 0; i -= 1) {

+            const j = Math.floor(Math.random() * (i + 1));

+            [arr[i], arr[j]] = [arr[j], arr[i]];

+        }

+        return arr;

+    };

+

+    const getDuelOpponent = (match) => {

+        if (!match) return null;

+        const isChallenger = match.challenger_id === dbId;

+        return {

+            id: isChallenger ? match.opponent_id : match.challenger_id,

+            username: isChallenger ? match.opponent_name : match.challenger_name,

+        };

+    };

+

+    const getDuelEligibleQuestions = () => {

+        if (!activeQuestionsCache || activeQuestionsCache.length === 0)

+            return [];

+        if (duelSettings.rangeMode === "all") return activeQuestionsCache;

+

+        const start = Number.parseInt(duelSettings.rangeStart, 10);

+        const end = Number.parseInt(duelSettings.rangeEnd, 10);

+        if (!Number.isFinite(start) || !Number.isFinite(end)) return [];

+        const from = Math.min(start, end);

+        const to = Math.max(start, end);

+        return activeQuestionsCache.filter(

+            (q) => q.number >= from && q.number <= to,

+        );

+    };

+

+    const validateDuelSettings = () => {

+        if (!subject) return "Nejdriv vyber predmet.";

+        const eligible = getDuelEligibleQuestions();

+        const allowedCounts = [5, 10, 20, 50];

+        if (!allowedCounts.includes(duelSettings.questionCount)) {

+            return "Vyber povolenn poDet ot├ízek.";

+        }

+        if (eligible.length < duelSettings.questionCount) {

+            return "V rozsahu neni dost ot├ízek pro zvoleny pocet.";

+        }

+        return "";

+    };

+

+    const createDuelMatch = async (opponent) => {

+        const validation = validateDuelSettings();

+        if (validation) {

+            setDuelError(validation);

+            return;

+        }

+

+        const eligible = getDuelEligibleQuestions();

+        const selectedQuestions = shuffleArray(eligible).slice(

+            0,

+            duelSettings.questionCount,

+        );

+        const questionIds = selectedQuestions.map((q) => q.id);

+

+        const payload = {

+            challenger_id: dbId,

+            opponent_id: opponent.id,

+            challenger_name: user,

+            opponent_name: opponent.username,

+            subject,

+            question_count: duelSettings.questionCount,

+            range_mode: duelSettings.rangeMode,

+            range_start:

+                duelSettings.rangeMode === "range"

+                    ? Number.parseInt(duelSettings.rangeStart, 10)

+                    : null,

+            range_end:

+                duelSettings.rangeMode === "range"

+                    ? Number.parseInt(duelSettings.rangeEnd, 10)

+                    : null,

+            question_ids: questionIds,

+            status: "pending",

+        };

+

+        const { data, error } = await supabase

+            .from("duel_matches")

+            .insert([payload])

+            .select()

+            .single();

+

+        if (error) {

+            console.error("Chyba pri vytvoreni duelu:", error);

+            setDuelError("Nepodarilo se vytvorit duel.");

+            return;

+        }

+

+        setDuelOutgoingMatch(data);

+        setDuelError("");

+        setMode("duel");

+    };

+

+    const acceptDuelInvite = async (invite) => {

+        const startAt = new Date().toISOString();

+        const { data, error } = await supabase

+            .from("duel_matches")

+            .update({

+                status: "active",

+                accepted_at: startAt,

+                started_at: startAt,

+            })

+            .eq("id", invite.id)

+            .eq("status", "pending")

+            .select()

+            .single();

+

+        if (error || !data) {

+            console.error("Chyba pri prijeti duelu:", error);

+            return;

+        }

+

+        setDuelInviteToShow(null);

+        setDuelInvites((prev) => prev.filter((i) => i.id !== invite.id));

+        setDuelOutgoingMatch(null);

+        setDuelActiveMatch(data);

+        duelFinalizeRef.current = false;

+        if (subject !== data.subject) setSubject(data.subject);

+        setMode("duel_match");

+    };

+

+    const declineDuelInvite = async (invite) => {
+        await supabase
+            .from("duel_matches")
+            .update({ status: "declined" })
+            .eq("id", invite.id);
+        await supabase.from("duel_matches").delete().eq("id", invite.id);
+        setDuelInvites((prev) => prev.filter((i) => i.id !== invite.id));
+        setDuelInviteToShow(null);
+    };
+
+    const cancelOutgoingDuel = async () => {
+        if (!duelOutgoingMatch) return;
+        await supabase
+            .from("duel_matches")
+            .update({ status: "cancelled" })
+            .eq("id", duelOutgoingMatch.id);
+        await supabase
+            .from("duel_matches")
+            .delete()
+            .eq("id", duelOutgoingMatch.id);
+        setDuelOutgoingMatch(null);
+    };
+

+    const getDuelProgress = (match, now, includeLocal = true) => {

+        if (!match?.started_at) {

+            return { index: 0, phase: "waiting", timeLeft: 0 };

+        }

+

+        const questionCount = match.question_count || 0;

+        let questionStart = new Date(match.started_at).getTime();

+        const rushQuestionIndex =

+            Number.isFinite(match?.rush_question_index) ||

+            match?.rush_question_index === 0

+                ? match.rush_question_index

+                : null;

+        const rushEndAt = match?.rush_end_at

+            ? new Date(match.rush_end_at).getTime()

+            : null;

+

+        for (let i = 0; i < questionCount; i += 1) {

+            const rawAnswersForQuestion = duelAnswers

+                .filter((answer) => answer.question_index === i)

+                .map((answer) => ({

+                    userId: answer.user_id,

+                    answeredAt: new Date(answer.answered_at).getTime(),

+                }));

+

+            const answersForQuestion = rawAnswersForQuestion.filter((answer) =>

+                Number.isFinite(answer.answeredAt),

+            );

+

+            if (includeLocal) {

+                const localAnswer = duelLocalAnswers[i];

+                if (

+                    localAnswer &&

+                    !rawAnswersForQuestion.some(

+                        (answer) =>

+                            String(answer.userId) === String(dbId),

+                    )

+                ) {

+                    rawAnswersForQuestion.push({

+                        userId: dbId,

+                        answeredAt: localAnswer.answeredAt,

+                    });

+                    answersForQuestion.push({

+                        userId: dbId,

+                        answeredAt: localAnswer.answeredAt,

+                    });

+                }

+            }

+

+            const answerTimes = answersForQuestion

+                .map((answer) => answer.answeredAt)

+                .sort((a, b) => a - b);

+            const answerUserIds = new Set(

+                rawAnswersForQuestion

+                    .map((answer) => answer.userId)

+                    .filter(Boolean)

+                    .map((id) => String(id)),

+            );

+

+            const firstAnswerAt = answerTimes[0] ?? null;

+            const secondAnswerAt = answerTimes[1] ?? null;

+

+            let answerDeadline =

+                questionStart + DUEL_ANSWER_SECONDS * 1000;

+            if (

+                firstAnswerAt &&

+                firstAnswerAt + DUEL_RUSH_SECONDS * 1000 < answerDeadline

+            ) {

+                answerDeadline = firstAnswerAt + DUEL_RUSH_SECONDS * 1000;

+            }

+            if (

+                rushQuestionIndex === i &&

+                Number.isFinite(rushEndAt) &&

+                rushEndAt < answerDeadline

+            ) {

+                answerDeadline = rushEndAt;

+            }

+

+            let answerPhaseEnd = answerDeadline;

+            if (secondAnswerAt && secondAnswerAt < answerPhaseEnd) {

+                answerPhaseEnd = secondAnswerAt;

+            }

+            if (answerUserIds.size >= 2) {

+                answerPhaseEnd = Math.min(answerPhaseEnd, now);

+            }

+

+            if (

+                duelResultOverride &&

+                duelResultOverride.questionIndex === i &&

+                now < duelResultOverride.endAt

+            ) {

+                return {

+                    index: i,

+                    phase: "result",

+                    timeLeft: Math.max(

+                        0,

+                        Math.ceil((duelResultOverride.endAt - now) / 1000),

+                    ),

+                    answerEndsAt: answerPhaseEnd,

+                    resultEndsAt: duelResultOverride.endAt,

+                    questionStartsAt: questionStart,

+                };

+            }

+

+            if (now < answerPhaseEnd) {

+                return {

+                    index: i,

+                    phase: "answer",

+                    timeLeft: Math.max(

+                        0,

+                        Math.ceil((answerPhaseEnd - now) / 1000),

+                    ),

+                    answerEndsAt: answerPhaseEnd,

+                    questionStartsAt: questionStart,

+                };

+            }

+

+            let resultEndsAt =

+                answerPhaseEnd + DUEL_RESULT_SECONDS * 1000;

+            if (

+                duelResultOverride &&

+                duelResultOverride.questionIndex === i

+            ) {

+                resultEndsAt = Math.max(

+                    resultEndsAt,

+                    duelResultOverride.endAt,

+                );

+            }

+            if (now < resultEndsAt) {

+                return {

+                    index: i,

+                    phase: "result",

+                    timeLeft: Math.max(

+                        0,

+                        Math.ceil((resultEndsAt - now) / 1000),

+                    ),

+                    answerEndsAt: answerPhaseEnd,

+                    resultEndsAt,

+                    questionStartsAt: questionStart,

+                };

+            }

+

+            questionStart = resultEndsAt;

+        }

+

+        return { index: questionCount, phase: "finished", timeLeft: 0 };

+    };

+

+    const getAnswerFor = (userId, questionIndex) =>

+        duelAnswers.find(

+            (answer) =>

+                answer.user_id === userId &&

+                answer.question_index === questionIndex,

+        );

+

+    const submitDuelAnswer = async (answerIndex) => {

+        if (!duelActiveMatch || !dbId) return;

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        if (progress.phase !== "answer") return;

+        const questionIndex = progress.index;

+        const existing = getAnswerFor(dbId, questionIndex);

+        if (existing || duelLocalAnswers[questionIndex]) return;

+

+        const triggerDuelRush = async () => {

+            if (progress.timeLeft <= DUEL_RUSH_SECONDS) return;

+            const questionStartAt = progress.questionStartsAt;

+            if (!Number.isFinite(questionStartAt)) return;

+

+            const rushEndAtMs = Math.min(

+                questionStartAt + DUEL_ANSWER_SECONDS * 1000,

+                duelClock + DUEL_RUSH_SECONDS * 1000,

+            );

+            const rushEndAtIso = new Date(rushEndAtMs).toISOString();

+

+            setDuelRushOverride({

+                questionIndex,

+                endAt: rushEndAtMs,

+            });

+            setDuelActiveMatch((prev) => {

+                if (!prev) return prev;

+                return {

+                    ...prev,

+                    rush_question_index: questionIndex,

+                    rush_end_at: rushEndAtIso,

+                };

+            });

+

+            const { error: rushError } = await supabase

+                .from("duel_matches")

+                .update({

+                    rush_question_index: questionIndex,

+                    rush_end_at: rushEndAtIso,

+                })

+                .eq("id", duelActiveMatch.id)

+                .or(

+                    `rush_question_index.is.null,rush_question_index.lt.${questionIndex}`,

+                );

+

+            if (rushError) {

+                console.error("Chyba p´┐Żi ulo´┐Żen! ?asu zkr´┐Żcen!:", rushError);

+            }

+        };

+

+        void triggerDuelRush();

+

+        setDuelLocalAnswers((prev) => ({

+            ...prev,

+            [questionIndex]: {

+                answerIndex,

+                answeredAt: duelClock,

+            },

+        }));

+

+        const { error } = await supabase.from("duel_answers").insert([

+            {

+                match_id: duelActiveMatch.id,

+                user_id: dbId,

+                question_index: questionIndex,

+                answer_index: answerIndex,

+            },

+        ]);

+

+        if (error) {

+            console.error("Chyba p´┐Żi ukl´┐Żd´┐Żn´┐Ż odpov´┐Żdi:", error);

+            setDuelLocalAnswers((prev) => {

+                const next = { ...prev };

+                delete next[questionIndex];

+                return next;

+            });

+        }

+    };

+

+    const computeDuelScore = () => {

+        if (!duelActiveMatch) return { myScore: 0, opponentScore: 0 };

+        const opponent = getDuelOpponent(duelActiveMatch);

+        if (!opponent) return { myScore: 0, opponentScore: 0 };

+        let myScore = 0;

+        let opponentScore = 0;

+

+        for (let i = 0; i < duelActiveMatch.question_count; i += 1) {

+            const question = duelQuestionSet[i];

+            if (!question) continue;

+

+            const myAnswer = getAnswerFor(dbId, i);

+            const opponentAnswer = getAnswerFor(opponent.id, i);

+

+            const myCorrect =

+                myAnswer && myAnswer.answer_index === question.correctIndex;

+            const opponentCorrect =

+                opponentAnswer &&

+                opponentAnswer.answer_index === question.correctIndex;

+

+            if (myCorrect && opponentCorrect) {

+                const myTime = new Date(myAnswer.answered_at).getTime();

+                const opponentTime = new Date(

+                    opponentAnswer.answered_at,

+                ).getTime();

+                if (myTime < opponentTime) myScore += 1;

+                else if (opponentTime < myTime) opponentScore += 1;

+                else {

+                    myScore += 1;

+                    opponentScore += 1;

+                }

+            } else if (myCorrect) {

+                myScore += 1;

+            } else if (opponentCorrect) {

+                opponentScore += 1;

+            }

+        }

+

+        return { myScore, opponentScore };

+    };

+

+    const applyDuelTrophies = async (

+        myScore,

+        opponentScore,

+        questionCount,

+        opponentId,

+    ) => {

+        const multiplier = Math.max(1, questionCount / 5);

+        const isDraw = myScore === opponentScore;

+        const myWin = myScore > opponentScore;

+        const opponentWin = opponentScore > myScore;

+

+        let myDelta = 0;

+        let opponentDelta = 0;

+        let myWins = 0;

+        let myLosses = 0;

+        let myDraws = 0;

+        let opponentWins = 0;

+        let opponentLosses = 0;

+        let opponentDraws = 0;

+

+        if (isDraw) {

+            myDelta = 3 * multiplier;

+            opponentDelta = 3 * multiplier;

+            myDraws = 1;

+            opponentDraws = 1;

+        } else if (myWin) {

+            myDelta = 5 * multiplier;

+            opponentDelta = -2 * multiplier;

+            myWins = 1;

+            opponentLosses = 1;

+        } else if (opponentWin) {

+            myDelta = -2 * multiplier;

+            opponentDelta = 5 * multiplier;

+            myLosses = 1;

+            opponentWins = 1;

+        }

+

+        const { data: stats } = await supabase

+            .from("duel_stats")

+            .select("*")

+            .in("user_id", [dbId, opponentId]);

+

+        const statsById = new Map(

+            (stats || []).map((entry) => [entry.user_id, entry]),

+        );

+

+        const myStats = statsById.get(dbId) || {};

+        const opponentStats = statsById.get(opponentId) || {};

+

+        const payload = [

+            {

+                user_id: dbId,

+                trophies: (myStats.trophies || 0) + myDelta,

+                wins: (myStats.wins || 0) + myWins,

+                losses: (myStats.losses || 0) + myLosses,

+                draws: (myStats.draws || 0) + myDraws,

+                updated_at: new Date().toISOString(),

+            },

+            {

+                user_id: opponentId,

+                trophies: (opponentStats.trophies || 0) + opponentDelta,

+                wins: (opponentStats.wins || 0) + opponentWins,

+                losses: (opponentStats.losses || 0) + opponentLosses,

+                draws: (opponentStats.draws || 0) + opponentDraws,

+                updated_at: new Date().toISOString(),

+            },

+        ];

+

+        await supabase.from("duel_stats").upsert(payload, {

+            onConflict: "user_id",

+        });

+

+        const { data: refreshed } = await supabase

+            .from("duel_stats")

+            .select("*")

+            .eq("user_id", dbId)

+            .maybeSingle();

+        if (refreshed) setDuelStats(refreshed);

+    };

+

+    const finalizeDuelMatch = async () => {
+        if (!duelActiveMatch || duelFinalizeRef.current) return;
+        duelFinalizeRef.current = true;
+
+        const opponent = getDuelOpponent(duelActiveMatch);
+        if (!opponent) return;
+

+        const { myScore, opponentScore } = computeDuelScore();

+        const challengerScore =

+            duelActiveMatch.challenger_id === dbId

+                ? myScore

+                : opponentScore;

+        const opponentScoreValue =

+            duelActiveMatch.challenger_id === dbId

+                ? opponentScore

+                : myScore;

+

+        let winnerId = null;

+        if (myScore > opponentScore) winnerId = dbId;

+        if (opponentScore > myScore) winnerId = opponent.id;

+

+        const { data } = await supabase

+            .from("duel_matches")

+            .update({

+                status: "completed",

+                completed_at: new Date().toISOString(),

+                challenger_score: challengerScore,

+                opponent_score: opponentScoreValue,

+                winner_id: winnerId,

+                result_finalized: true,

+            })

+            .eq("id", duelActiveMatch.id)

+            .eq("result_finalized", false)

+            .select("id");

+

+        if (data && data.length > 0) {
+            await applyDuelTrophies(
+                myScore,
+                opponentScore,
+                duelActiveMatch.question_count,
+                opponent.id,
+            );
+            const matchId = duelActiveMatch.id;
+            window.setTimeout(() => {
+                supabase.from("duel_matches").delete().eq("id", matchId);
+            }, 8000);
+        }
+    };
+
+    const leaveActiveDuel = async () => {
+        if (!duelActiveMatch) return;
+        const matchId = duelActiveMatch.id;
+        const isCompleted = duelActiveMatch.status === "completed";
+        if (!isCompleted) {
+            await supabase
+                .from("duel_matches")
+                .update({ status: "cancelled" })
+                .eq("id", matchId);
+        }
+        await supabase.from("duel_matches").delete().eq("id", matchId);
+        setDuelActiveMatch(null);
+        setDuelAnswers([]);
+        setDuelQuestionSet([]);
+        setDuelLocalAnswers({});
+        setDuelRushOverride(null);
+        setDuelResultOverride(null);
+        setMode("duel");
+    };
+

+    const handleReportClick = (questionNumber) => {

+        setQuestionToReport(questionNumber);

+        setReportModalOpen(true);

+    };

+

+    const [visualSelection, setVisualSelection] = useState(null);

+    const [shuffledMapping, setShuffledMapping] = useState([]);

+

+    useEffect(() => {

+        const updateHeight = () => {

+            const vh = window.innerHeight * 0.01;

+            document.documentElement.style.setProperty("--vh", `${vh}px`);

+        };

+        updateHeight();

+        window.addEventListener("resize", updateHeight);

+        window.addEventListener("orientationchange", updateHeight);

+        return () => {

+            window.removeEventListener("resize", updateHeight);

+            window.removeEventListener("orientationchange", updateHeight);

+        };

+    }, []);

+

+    useEffect(() => {

+        window.setShuffledMappingForKeyboard = (mapping) => {

+            setShuffledMapping(mapping);

+            setVisualSelection(null);

+        };

+        return () => delete window.setShuffledMappingForKeyboard;

+    }, []);

+

+    const handleAnswer = async (idx) => {

+        if (finished || mode === "review") return;

+        setIsKeyboardMode(true);

+        document.body.classList.add("keyboard-mode-active");

+

+        setQuestionSet((prev) => {

+            const c = [...prev];

+            if (c[currentIndex])

+                c[currentIndex] = { ...c[currentIndex], userAnswer: idx };

+            return c;

+        });

+        if (idx !== questionSet[currentIndex].correctIndex) {

+            triggerHaptic("error");

+            addMistake(questionSet[currentIndex].number);

+        } else {

+            triggerHaptic("success");

+            triggerFakeSync();

+        }

+

+        // --- OKAMMITp ULO[EN; PRO SMART RE´┐ŻIM (MANU´┐ŻLN´┐Ż KLIK) ---

+        if (mode === "smart" && questionSet.length <= SMART_SAVE_LIMIT) {

+            const nextSet = [...questionSet];

+            if (nextSet[currentIndex])

+                nextSet[currentIndex] = {

+                    ...nextSet[currentIndex],

+                    userAnswer: idx,

+                };

+            persistSmartSession(nextSet, currentIndex, score);

+        }

+    };

+

+    const clickFlashcardAnswer = (idx) => {

+        if (finished || showResult) return;

+        if (idx === null) return;

+        const currentQ = questionSet[currentIndex];

+        const isCorrect = idx === currentQ.correctIndex;

+        const newSet = [...questionSet];

+        if (newSet[currentIndex])

+            newSet[currentIndex] = { ...newSet[currentIndex], userAnswer: idx };

+        setQuestionSet(newSet);

+        setSelectedAnswer(idx);

+        setShowResult(true);

+        setSessionQuestionsCount((prev) => prev + 1);

+        setVisualSelection(null);

+

+        if (mode === "test_practice" && activeTest) {

+            const currentStats = testPracticeStats[activeTest.id] || [];

+            const newStats = [...currentStats, isCorrect].slice(-20);

+            saveDataToCloud(undefined, undefined, 0, 0, {

+                ...testPracticeStats,

+                [activeTest.id]: newStats,

+            });

+        }

+

+        // Vypoantlme novw sk re pro ulo´┐Żen´┐Ż

+        let nextScore = { ...score };

+

+        if (isCorrect) {

+            triggerHaptic("success");

+            nextScore.correct += 1;

+            nextScore.total += 1;

+            setScore(nextScore);

+            setCombo((c) => c + 1);

+            if (mode === "mistakes") removeMistake(currentQ.number);

+            else triggerFakeSync();

+        } else {

+            triggerHaptic("error");

+            nextScore.total += 1;

+            setScore(nextScore);

+            addMistake(currentQ.number);

+            if (combo >= 3) {

+                setShake(true);

+                setTimeout(() => setShake(false), 500);

+            }

+            setCombo(0);

+        }

+

+        // --- OKAM IT" ULO´┐ŻEN´┐Ż PRO SMART RE´┐ŻIM (FLASHCARD) ---

+        if (mode === "smart" && questionSet.length <= SMART_SAVE_LIMIT) {

+            persistSmartSession(newSet, currentIndex, nextScore);

+        }

+    };

+

+    // --- FUNKCE PRO PfECHOD NA DAL´┐Ż´┐Ż OT´┐ŻZKU ---

+    const nextFlashcardQuestion = () => {

+        if (mode === "random" || mode === "test_practice") {

+            if (currentIndex >= questionSet.length - 1) setFinished(true);

+            else {

+                setCurrentIndex((prev) => prev + 1);

+                setSelectedAnswer(null);

+                setShowResult(false);

+            }

+        } else if (mode === "smart" || mode === "mistakes") {

+            const currentQ = questionSet[0];

+            const isCorrect = selectedAnswer === currentQ.correctIndex;

+            let newSet = [...questionSet];

+            if (isCorrect) newSet.shift();

+            else {

+                let qToMove = newSet.shift();

+

+                const optionsWithMeta = qToMove.options.map((opt, i) => ({

+                    text: opt,

+                    isCorrect: i === qToMove.correctIndex,

+                }));

+

+                for (let i = optionsWithMeta.length - 1; i > 0; i--) {

+                    const j = Math.floor(Math.random() * (i + 1));

+                    [optionsWithMeta[i], optionsWithMeta[j]] = [

+                        optionsWithMeta[j],

+                        optionsWithMeta[i],

+                    ];

+                }

+

+                qToMove = {

+                    ...qToMove,

+                    options: optionsWithMeta.map((o) => o.text),

+                    correctIndex: optionsWithMeta.findIndex((o) => o.isCorrect),

+                    userAnswer: undefined,

+                    _instanceId: Math.random(),

+                };

+

+                newSet.splice(

+                    Math.min(newSet.length, 3 + Math.floor(Math.random() * 3)),

+                    0,

+                    qToMove,

+                );

+            }

+

+            if (newSet.length === 0) {

+                setFinished(true);

+                addToHistory(score);

+                clearSmartSession(); // Smazat session p´┐Żi dokon´┐Żen´┐Ż

+            } else {

+                setQuestionSet(newSet);

+                setSelectedAnswer(null);

+                setShowResult(false);

+

+                // Fix scrollu

+                if (containerRef.current) {

+                    containerRef.current.scrollTop = 0;

+                }

+                window.scrollTo({ top: 0, behavior: "instant" });

+            }

+        }

+    };

+

+    // ... (zbytek funkc´┐Ż z´┐Żst´┐Żv´┐Ż stejn´┐Ż)

+

+    const confirmFlashcardAnswer = () => {

+        if (!finished && !showResult)

+            clickFlashcardAnswer(selectedAnswer !== null ? selectedAnswer : -1);

+    };

+    const selectRandomAnswer = (idx) => {

+        if (!finished && !showResult) {

+            triggerHaptic("light");

+            setVisualSelection(idx);

+            setIsKeyboardMode(true);

+            document.body.classList.add("keyboard-mode-active");

+        }

+    };

+    const clearAnswer = () => {

+        setQuestionSet((prev) => {

+            const c = [...prev];

+            if (c[currentIndex])

+                c[currentIndex] = { ...c[currentIndex], userAnswer: undefined };

+            return c;

+        });

+        setSelectedAnswer(null);

+        setShowResult(false);

+    };

+

+    const moveToQuestion = (newIdx) => {

+        const b = Math.max(0, Math.min(newIdx, questionSet.length - 1));

+        if (b < currentIndex) setDirection("left");

+        else setDirection("right");

+

+        // Reset content ready state synchronously

+        setReadyQuestionId(null);

+        setCurrentIndex(b);

+        setSelectedAnswer(null);

+    };

+

+    const handleSwipe = (dir) => {

+        if (

+            finished ||

+            showConfirmExit ||

+            showConfirmSubmit ||

+            exitDirection ||

+            isSessionBlocked

+        )

+            return;

+

+        const isFlashcard = isFlashcardStyle(mode) || mode === "test_practice";

+

+        const performAction = () => {

+            if (dir === "left") {

+                if (isFlashcard) {

+                    if (showResult) nextFlashcardQuestion();

+                    else if (selectedAnswer !== null) confirmFlashcardAnswer();

+                } else if (currentIndex < questionSet.length - 1) {

+                    moveToQuestion(currentIndex + 1);

+                }

+            } else if (dir === "right") {

+                if (!isFlashcard && currentIndex > 0) {

+                    moveToQuestion(currentIndex - 1);

+                }

+            }

+        };

+

+        if (isFlashcard) {

+            performAction();

+        } else {

+            setExitDirection(dir);

+            setTimeout(() => {

+                performAction();

+                setExitDirection(null);

+            }, 80);

+        }

+    };

+

+    const submitTest = () => {

+        const qEval = questionSet;

+        const cor = qEval.filter((q) => q.userAnswer === q.correctIndex).length;

+        const finalScore = { correct: cor, total: qEval.length };

+        const answeredCount = qEval.filter(

+            (q) => q.userAnswer !== undefined,

+        ).length;

+        setSessionQuestionsCount((prev) => prev + answeredCount);

+        setScore(finalScore);

+        setTimeLeftAtSubmit(timeLeft);

+        setFinished(true);

+        setShowConfirmSubmit(false);

+        addToHistory(finalScore);

+    };

+    const addToHistory = (s) => {

+        if (mode !== "mock") return;

+        const newRec = {

+            date: new Date().toISOString(),

+            mode: mode,

+            score: s,

+            subject: subject,

+            id: Date.now() + "-" + Math.random(),

+        };

+        updateHistory((prev) => [...prev, newRec]);

+    };

+    const tryReturnToMenu = () => {

+        if (mode === "test_practice") {

+            setMode("scheduled_list");

+            setCombo(0);

+            setShowResult(false);

+            setSelectedAnswer(null);

+            setVisualSelection(null);

+            setShuffledMapping([]);

+            setMenuSelection(1);

+            setActiveTest(null);

+            return;

+        }

+

+        // --- UPRAVENn LOGIKA PRO SMART MODE (Exit Prompt) ---

+        if (

+            mode === "smart" &&

+            !finished &&

+            questionSet.length <= SMART_SAVE_LIMIT

+        ) {

+            setShowSaveProgressPrompt(true);

+            return;

+        }

+

+        if (mode === "mock" && !finished) {

+            setShowConfirmExit(true);

+        } else {

+            setMode(null);

+            setCombo(0);

+            setShowResult(false);

+            setSelectedAnswer(null);

+            setVisualSelection(null);

+            setShuffledMapping([]);

+            setMenuSelection(0);

+        }

+    };

+

+    const confirmExit = () => {

+        setShowConfirmExit(false);

+        const wasPractice = mode === "test_practice";

+        setMode(wasPractice ? "scheduled_list" : null);

+        setCombo(0);

+        setShowResult(false);

+        setSelectedAnswer(null);

+        setVisualSelection(null);

+        setShuffledMapping([]);

+        setMenuSelection(wasPractice ? 1 : 0);

+        if (wasPractice) setActiveTest(null);

+    };

+

+    const handleSaveAndExit = async (shouldSave) => {

+        setShowSaveProgressPrompt(false);

+        if (!shouldSave) {

+            // Pokud nechce ulo it, smateme session

+            const currentSmartSessions = profileData?.smart_session || {};

+            const updatedSessions = { ...currentSmartSessions };

+            delete updatedSessions[subject];

+            await saveData({ smart_session: updatedSessions });

+        }

+

+        setMode(null);

+        setCombo(0);

+        setShowResult(false);

+        setSelectedAnswer(null);

+        setMenuSelection(0);

+    };

+

+    const handleFileUpload = (questions) => {

+        if (!questions) return;

+        const norm = questions.map((q, i) => ({

+            number: q.number ?? i + 1,

+            question: q.question ?? `Ot├ízka ${i + 1}`,

+            options: q.options || [],

+            correctIndex: q.correctIndex ?? 0,

+        }));

+        setCustomQuestions(norm);

+        setSubject("CUSTOM");

+    };

+

+    useEffect(() => {

+        const handleKeyDown = (e) => {

+            if (isSessionBlocked) return;

+            if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")

+                return;

+            if (e.repeat) return;

+            if (

+                (e.key === "Enter" || e.key === " ") &&

+                e.target.tagName === "BUTTON"

+            )

+                return;

+

+            if (!isKeyboardMode) {

+                setIsKeyboardMode(true);

+                document.body.classList.add("keyboard-mode-active");

+            }

+            if (

+                [

+                    "ArrowUp",

+                    "ArrowDown",

+                    "ArrowLeft",

+                    "ArrowRight",

+                    " ",

+                    "f",

+                    "F",

+                ].includes(e.key)

+            )

+                e.preventDefault();

+            if (

+                showConfirmExit ||

+                showConfirmSubmit ||

+                showSmartSettings ||

+                showClearMistakesConfirm ||

+                recordToDelete ||

+                reportModalOpen ||

+                testToStart ||

+                showResumePrompt ||

+                showSaveProgressPrompt

+            ) {

+                if (e.key === "Escape") {

+                    setShowConfirmExit(false);

+                    setShowConfirmSubmit(false);

+                    setShowSmartSettings(false);

+                    setShowClearMistakesConfirm(false);

+                    setRecordToDelete(null);

+                    setReportModalOpen(false);

+                    setTestToStart(null);

+                    setShowResumePrompt(false);

+                    setShowSaveProgressPrompt(false);

+                    return;

+                }

+                if (e.key === "Enter") {

+                    if (showConfirmExit) tryReturnToMenu();

+                    if (showConfirmSubmit) submitTest();

+                    if (showClearMistakesConfirm) clearMistakes();

+                    if (recordToDelete) handleDeleteRecordConfirm();

+                    if (testToStart) confirmStartTest();

+                    if (showResumePrompt) resumeSmartSession();

+                    if (showSaveProgressPrompt) handleSaveAndExit(true);

+                    return;

+                }

+                return;

+            }

+

+            if (e.key === "f" || e.key === "F") {

+                if (fullscreenImage) setFullscreenImage(null);

+                return;

+            }

+            if (fullscreenImage) {

+                if (

+                    e.key === "Escape" ||

+                    e.key === "f" ||

+                    e.key === "F" ||

+                    e.key === "Enter"

+                )

+                    setFullscreenImage(null);

+                return;

+            }

+            if (finished || mode === "no_mistakes") {

+                if (

+                    [

+                        "Backspace",

+                        "Enter",

+                        "ArrowLeft",

+                        "a",

+                        "A",

+                        "Escape",

+                    ].includes(e.key)

+                ) {

+                    setMode(null);

+                    setMenuSelection(0);

+                }

+                return;

+            }

+

+            if (!mode) {

+                const k = e.key.toLowerCase();

+                if (!subject) {

+                    const subjectCount = 3;

+                    if (k === "w" || k === "arrowup")

+                        setMenuSelection(

+                            (p) => (p - 1 + subjectCount) % subjectCount,

+                        );

+                    else if (k === "s" || k === "arrowdown")

+                        setMenuSelection((p) => (p + 1) % subjectCount);

+                    else if (

+                        k === "d" ||

+                        k === "arrowright" ||

+                        e.key === "Enter" ||

+                        e.key === " "

+                    ) {

+                        const subjects = ["sps", "stt", "CUSTOM"];

+                        handleSelectSubject(subjects[menuSelection]);

+                    }

+                    return;

+                }

+                const hasScheduled = scheduledTests.length > 0;

+                const menuMapping = [];

+                const modeCount = 9;

+                const getNextIndex = (current, dir) => {

+                    let next = current;

+                    let safety = 0;

+                    do {

+                        next = (next + dir + modeCount) % modeCount;

+                        safety++;

+                        const isVisible =

+                            next === 0 ||

+                            (next === 1 && hasScheduled) ||

+                            next === 2 ||

+                            next === 3 ||

+                            (next === 4 && profileData?.class === "4.B") ||

+                            next === 5 ||

+                            (next === 6 && isTeacher) ||

+                            next === 7 ||

+                            next === 8;

+                        if (isVisible) return next;

+                    } while (safety < 20);

+                    return next;

+                };

+

+                if (k === "w" || k === "arrowup")

+                    setMenuSelection((p) => getNextIndex(p, -1));

+                else if (k === "s" || k === "arrowdown")

+                    setMenuSelection((p) => getNextIndex(p, 1));

+                else if (k === "a" || k === "arrowleft") {

+                    if (subject) setSubject(null);

+                } else if (

+                    k === "d" ||

+                    k === "arrowright" ||

+                    e.key === "Enter"

+                ) {

+                    if (!subject) {

+                        if (menuSelection === 0) handleSelectSubject("SPS");

+                        else if (menuSelection === 1)

+                            handleSelectSubject("STT");

+                        else if (menuSelection === 2)

+                            document

+                                .querySelector("input[type='file']")

+                                ?.click();

+                        else if (menuSelection === 3 && user === "admin")

+                            setMode("admin");

+                    } else {

+                        let selection = menuSelection % modeCount;

+                        if (selection < 0) selection += modeCount;

+                        if (selection === 0)

+                            handleStartMode(startMockTest, "mock");

+                        else if (selection === 1 && hasScheduled)

+                            setMode("scheduled_list");

+                        else if (selection === 2)

+                            handleStartMode(startNewSmartSession, "smart");

+                        else if (selection === 3)

+                            handleStartMode(startRandomMode, "random");

+                        else if (selection === 4) {

+                            if (profileData?.class === "4.B") {

+                                setMode("duel");

+                            }

+                        }

+                        else if (selection === 5)

+                            handleStartMode(startReviewMode, "review");

+                        else if (selection === 6) {

+                            if (isTeacher) setMode("teacher_manager");

+                        } else if (selection === 7)

+                            handleStartMode(startMistakesMode, "mistakes");

+                        else if (selection === 8) openHistoryWithRefresh();

+                    }

+                } else if (

+                    k === "a" ||

+                    k === "arrowleft" ||

+                    k === "backspace"

+                ) {

+                    if (subject) setSubject(null);

+                }

+                return;

+            }

+            if (mode === "duel" || mode === "duel_match") return;

+            if (!mode || mode === "real_test") return;

+            const opts = questionSet[currentIndex]?.options?.length || 4;

+            const isFlashcardInput =

+                isFlashcardStyle(mode) || mode === "test_practice";

+            const k = e.key.toLowerCase();

+

+            if (k === "w" || e.key === "ArrowUp") {

+                if (isFlashcardInput && !showResult) {

+                    const nextVisual =

+                        visualSelection === null

+                            ? opts - 1

+                            : (visualSelection - 1 + opts) % opts;

+                    selectRandomAnswer(nextVisual);

+                } else if (!isFlashcardInput)

+                    handleAnswer(

+                        questionSet[currentIndex].userAnswer === undefined

+                            ? opts - 1

+                            : (questionSet[currentIndex].userAnswer -

+                                  1 +

+                                  opts) %

+                                  opts,

+                    );

+            }

+            if (k === "s" || e.key === "ArrowDown") {

+                if (isFlashcardInput && !showResult) {

+                    const nextVisual =

+                        visualSelection === null

+                            ? 0

+                            : (visualSelection + 1) % opts;

+                    selectRandomAnswer(nextVisual);

+                } else if (!isFlashcardInput)

+                    handleAnswer(

+                        questionSet[currentIndex].userAnswer === undefined

+                            ? 0

+                            : (questionSet[currentIndex].userAnswer + 1) % opts,

+                    );

+            }

+            if (k === "a" || e.key === "ArrowLeft") {

+                if (isFlashcardInput) return;

+                if (mode === "history") {

+                    setMode(null);

+                    return;

+                }

+                if (currentIndex > 0) moveToQuestion(currentIndex - 1);

+            }

+            if (k === "d" || e.key === "ArrowRight" || e.key === "Enter") {

+                if (mode === "history") return;

+                if (isFlashcardInput) {

+                    if (showResult) nextFlashcardQuestion();

+                    else {

+                        const finalIdx =

+                            visualSelection !== null

+                                ? (shuffledMapping[visualSelection] ??

+                                  selectedAnswer)

+                                : selectedAnswer;

+                        clickFlashcardAnswer(finalIdx);

+                    }

+                } else if (currentIndex < questionSet.length - 1) {

+                    moveToQuestion(currentIndex + 1);

+                }

+            }

+            if (e.key === " ") {

+                if (mode === "history") return;

+                if (isFlashcardInput && !showResult) {

+                    const finalIdx =

+                        visualSelection !== null

+                            ? (shuffledMapping[visualSelection] ??

+                              selectedAnswer)

+                            : selectedAnswer;

+                    clickFlashcardAnswer(finalIdx);

+                } else if (!finished && mode === "mock")

+                    setShowConfirmSubmit(true);

+            }

+            if (e.key === "Backspace") {

+                if (mode === "history") {

+                    setMode(null);

+                    return;

+                }

+                clearAnswer();

+            }

+            if (e.key === "Escape") {

+                if (mode === "history") {

+                    setMode(null);

+                    return;

+                }

+                tryReturnToMenu();

+            }

+        };

+        window.addEventListener("keydown", handleKeyDown);

+        return () => window.removeEventListener("keydown", handleKeyDown);

+    }, [

+        mode,

+        questionSet,

+        currentIndex,

+        showResult,

+        selectedAnswer,

+        showConfirmSubmit,

+        showConfirmExit,

+        finished,

+        menuSelection,

+        subject,

+        user,

+        fullscreenImage,

+        reportModalOpen,

+        isSessionBlocked,

+        testToStart,

+        visualSelection,

+        shuffledMapping,

+        showResumePrompt,

+        showSaveProgressPrompt,

+    ]);

+

+    useEffect(() => {

+        if (

+            finished ||

+            (mode !== "mock" && mode !== "smart" && mode !== "mistakes")

+        )

+            return;

+        const interval = setInterval(() => {

+            if (mode === "mock") setTimeLeft((p) => Math.max(0, p - 1));

+            else setTrainingTime((t) => t + 1);

+        }, 1000);

+        return () => clearInterval(interval);

+    }, [mode, finished]);

+    useEffect(() => {

+        if (mode === "mock" && timeLeft === 0 && !finished) submitTest();

+    }, [timeLeft, mode, finished]);

+

+    const [showCustomImport, setShowCustomImport] = useState(false);

+

+    useEffect(() => {

+        window.handleCustomImport = (questions) => {

+            handleFileUpload(questions);

+            setShowCustomImport(false);

+        };

+        return () => delete window.handleCustomImport;

+    }, [activeQuestionsCache]);

+

+    if (showCustomImport) {

+        return <CustomImportGuide onBack={() => setShowCustomImport(false)} />;

+    }

+

+    if (!user)

+        return (

+            <>

+                <div

+                    style={{

+                        position: "absolute",

+                        top: "1rem",

+                        right: "1rem",

+                        zIndex: 100,

+                    }}

+                >

+                    <ThemeToggle currentTheme={theme} toggle={toggleTheme} />

+                </div>

+                <CloudLoginScreen onLogin={login} loading={loading} />

+            </>

+        );

+

+    if (isSessionBlocked)

+        return <SessionBlockedScreen onTakeOver={takeOverSession} />;

+

+    if (mode === "leaderboard") {

+        if (!profileData?.class) {

+            setMode(null);

+            return null;

+        }

+        return (

+            <div

+                className="container fadeIn"

+                style={{

+                    minHeight: "var(--vh)",

+                    display: "flex",

+                    flexDirection: "column",

+                    alignItems: "center",

+                    justifyContent: "flex-start",

+                }}

+            >

+                <div className="top-navbar" style={{ width: "100%" }}>

+                    <div className="navbar-group">

+                        <button

+                            className="menuBackButton"

+                            onClick={() => setMode(null)}

+                        >

+                            {"n"}{" "}

+                            <span className="mobile-hide-text">

+                                Zp─Ťt do menu

+                            </span>

+                        </button>

+                    </div>

+                    <div className="navbar-group">

+                        <UserBadgeDisplay

+                            user={user}

+                            syncing={syncing}

+                            onLogout={handleLogout}

+                        />

+                        <ThemeToggle

+                            currentTheme={theme}

+                            toggle={toggleTheme}

+                        />

+                    </div>

+                </div>

+                <div

+                    style={{

+                        width: "100%",

+                        maxWidth: "900px",

+                        padding: "1.5rem 1rem 2rem",

+                    }}

+                >

+                    <LeaderboardPanel

+                        entries={leaderboardEntries}

+                        loading={leaderboardLoading}

+                        error={leaderboardError}

+                        title={

+                            profileData?.class

+                                ? `´┐Żeb´┐Ż´┐Ż´┐Żek t´┐Ż´┐Żdy ${profileData.class}`

+                                : "zeb roek tcody"

+                        }

+                        className="leaderboard-full"

+                    />

+                </div>

+            </div>

+        );

+    }

+

+    if (mode === "teacher_manager") {

+        if (!isTeacher) {

+            setMode(null);

+            return null;

+        }

+        return (

+            <TestManager

+                onBack={() => setMode(null)}

+                subject={subject}

+                isTeacher={isTeacher}

+                user={user}

+                syncing={syncing}

+                theme={theme}

+                toggleTheme={toggleTheme}

+            />

+        );

+    }

+

+    if (mode === "scheduled_list") {

+        return (

+            <>

+                <ScheduledTestsList

+                    scheduledTests={scheduledTests}

+                    onBack={() => setMode(null)}

+                    subject={subject}

+                    user={user}

+                    syncing={syncing}

+                    theme={theme}

+                    toggleTheme={toggleTheme}

+                    onStartGradedTest={startGradedTest}

+                    onStartPractice={startTestPractice}

+                    completedTestIds={completedTestIds}

+                    testPracticeStats={testPracticeStats}

+                    onRefresh={handleManualRefresh}

+                />

+                {testToStart && (

+                    <ConfirmModal

+                        title={`Spustit test "${testToStart.title}"?`}

+                        message={

+                            <div style={{ textAlign: "left" }}>

+                                <p style={{ marginBottom: "1rem" }}>

+                                    Chyst}te se spustit ostr´┐Ż test.

+                                </p>

+                                <ul

+                                    style={{

+                                        paddingLeft: "1.2rem",

+                                        color: "var(--color-text-secondary)",

+                                        fontSize: "0.95rem",

+                                        lineHeight: "1.5",

+                                    }}

+                                >

+                                    <li>

+                                        Do testu lze vstoupit{" "}

+                                        <strong>pouze jednou</strong>.

+                                    </li>

+                                    <li>

+                                        Jakmile test spust´┐Żte, za´┐Żne b´┐Żet

+                                        gasov´┐Ż limit ({testToStart.time_limit}{" "}

+                                        min).

+                                    </li>

+                                    <li>

+                                        Test nelze p´┐Żeru´┐Żit ani se k n´┐Żmu vr´┐Żtit

+                                        pozd´┐Żji.

+                                    </li>

+                                    <li>

+                                        Ujist´┐Żte se, ´┐Że m´┐Żte stabiln´┐Ż p´┐Żipojen´┐Ż

+                                        k internetu.

+                                    </li>

+                                </ul>

+                            </div>

+                        }

+                        onCancel={() => setTestToStart(null)}

+                        onConfirm={confirmStartTest}

+                        confirmText="Spustit test"

+                        danger={false}

+                    />

+                )}

+            </>

+        );

+    }

+

+    if (mode === "real_test") {

+        return (

+            <RealTestMode

+                test={activeTest}

+                initialQuestions={questionSet}

+                user={user}

+                userId={dbId}

+                onExit={() => setMode(null)}

+                onFinish={() => setMode(null)}

+                theme={theme}

+                toggleTheme={toggleTheme}

+                syncing={syncing}

+                onReport={handleReportClick}

+                onTestCompleted={handleTestCompletion}

+            />

+        );

+    }

+

+    if (!mode) {

+        if (!subject || isTransitioningSubject)

+            return (

+                <div

+                    className="container fadeIn"

+                    style={{

+                        minHeight: "var(--vh)",

+                        display: "flex",

+                        flexDirection: "column",

+                        alignItems: "center",

+                        justifyContent: "flex-start",

+                        paddingBottom: "1.5rem",

+                    }}

+                >

+                    {isLoadingQuestions || isTransitioningSubject ? (

+                        <div

+                            style={{

+                                margin: "2rem",

+                                fontSize: "1.2rem",

+                                color: "#888",

+                                display: "flex",

+                                flexDirection: "column",

+                                alignItems: "center",

+                                justifyContent: "center",

+                                height: "100%",

+                            }}

+                        >

+                            <div

+                                style={{

+                                    fontSize: "3rem",

+                                    marginBottom: "1rem",

+                                }}

+                            >

+                                ?

+                            </div>

+                            Naontam ot(zky a obrozky...

+                        </div>

+                    ) : (

+                        <>

+                            <div

+                                className="top-navbar"

+                                style={{ width: "100%" }}

+                            >

+                                <div className="navbar-group">

+                                    {user === "admin" && (

+                                        <button

+                                            className="menuBackButton"

+                                            onClick={() => setMode("admin")}

+                                            title="Admin Panel"

+                                        >

+                                            ??? Admin

+                                        </button>

+                                    )}

+                                    <SubjectBadge subject={subject} compact />

+                                </div>

+                                <div className="navbar-group">

+                                    <UserBadgeDisplay

+                                        user={user}

+                                        syncing={syncing}

+                                        onLogout={handleLogout}

+                                        alwaysShowFullName={true}

+                                    />

+                                    <ThemeToggle

+                                        currentTheme={theme}

+                                        toggle={toggleTheme}

+                                    />

+                                </div>

+                            </div>

+                            <div

+                                style={{

+                                    flexGrow: 1,

+                                    display: "flex",

+                                    flexDirection: "column",

+                                    justifyContent: "center",

+                                    width: "100%",

+                                }}

+                            >

+                                <div className="subject-menu-layout">

+                                    <div className="subject-menu-main">

+                                        <SubjectSelector

+                                            menuSelection={menuSelection}

+                                            onSelectSubject={handleSelectSubject}

+                                            onUploadFile={handleFileUpload}

+                                            isKeyboardMode={isKeyboardMode}

+                                            setIsKeyboardMode={

+                                                setIsKeyboardMode

+                                            }

+                                        />

+                                        {profileData?.class && (

+                                            <button

+                                                className="leaderboard-mobile-button"

+                                                onClick={() =>

+                                                    setMode("leaderboard")

+                                                }

+                                            >

+                                                ?? ´┐Żeb´┐Ż´┐Ż´┐Żek t´┐Ż´┐Żdy

+                                            </button>

+                                        )}

+                                    </div>

+                                    {profileData?.class && (

+                                        <div className="leaderboard-desktop">

+                                            <LeaderboardPanel

+                                                entries={leaderboardEntries}

+                                                loading={leaderboardLoading}

+                                                error={leaderboardError}

+                                                title={

+                                                    profileData?.class

+                                                        ? `febd(´┐Żek t´┐Ż´┐Żdy ${profileData.class}`

+                                                        : "eebrt,ek t´┐Ż´┐Żdy"

+                                                }

+                                            />

+                                        </div>

+                                    )}

+                                </div>

+                            </div>

+                        </>

+                    )}

+                    <div style={{ height: "1px" }}></div>

+                </div>

+            );

+

+        const mistakesCount = mistakes[subject]?.length || 0;

+        return (

+            <>

+                <ReportModal

+                    isOpen={reportModalOpen}

+                    onClose={() => {

+                        setReportModalOpen(false);

+                        setQuestionToReport(null);

+                    }}

+                    theme={theme}

+                    {...(() => {

+                        let activeReportQuestion = currentQuestion;

+                        if (questionToReport) {

+                            const found = questionSet.find(

+                                (q) => q.number === questionToReport,

+                            );

+                            if (found) activeReportQuestion = found;

+                        }

+                        const qForModal = activeReportQuestion || {};

+                        return {

+                            questionText: qForModal.question,

+                            questionId: qForModal.id,

+                            subject: qForModal.subject,

+                            questionNumber: qForModal.number,

+                            options: qForModal.options,

+                            correctIndex: qForModal.correctIndex,

+                            userAnswer: qForModal.userAnswer,

+                        };

+                    })()}

+                    mode={mode}

+                    username={user}

+                    userId={dbId}

+                    isExiting={!!exitDirection}

+                />

+

+                {showSmartSettings && (

+                    <SmartSettingsModal

+                        onStart={startNewSmartSession}

+                        onCancel={() => setShowSmartSettings(false)}

+                        totalQuestions={activeQuestionsCache.length}

+                    />

+                )}

+

+                {showResumePrompt && (

+                    <ConfirmModal

+                        title="Nalezen rozpracovan´┐Ż bal´┐Ż´┐Żek"

+                        message={

+                            <div>

+                                <p>M´┐Ż ulo´┐Żen´┐Ż nedokon´┐Żen´┐Ż bal´┐Ż´┐Żek z minula.</p>

+                                <p>Chcer v nwm pokranovat?</p>

+                            </div>

+                        }

+                        onCancel={() => {

+                            setShowResumePrompt(false);

+                            setShowSmartSettings(true);

+                        }}

+                        onConfirm={resumeSmartSession}

+                        confirmText="Pokra´┐Żovat"

+                        cancelText="Novi balidek"

+                        danger={false}

+                    />

+                )}

+

+                {showClearMistakesConfirm && (

+                    <ConfirmModal

+                        title="Vynulovat opravnu?"

+                        message="Smazat chyby z cloudu?"

+                        onCancel={() => setShowClearMistakesConfirm(false)}

+                        onConfirm={clearMistakes}

+                        confirmText="Smazat"

+                        danger={true}

+                    />

+                )}

+

+                <div

+                    ref={containerRef}

+                    className="container fadeIn"

+                    style={{

+                        minHeight: "var(--vh)",

+                        display: "flex",

+                        flexDirection: "column",

+                        justifyContent: "flex-start",

+                        alignItems: "center",

+                    }}

+                >

+                    {!isLoadingQuestions && (

+                        <div className="top-navbar" style={{ width: "100%" }}>

+                            <div className="navbar-group">

+                                <div className="navbar-group">

+                                    <button

+                                        className="menuBackButton"

+                                        onClick={() => {

+                                            flushSessionStats();

+                                            clearImageCache();

+                                            setSubject(null);

+                                        }}

+                                    >

+                                        {" "}{" "}

+                                        <span className="mobile-hide-text">

+                                            Zm nit p´┐Żedm´┐Żt

+                                        </span>

+                                    </button>

+                                    <SubjectBadge subject={subject} compact />

+                                </div>

+                            </div>

+                            <div className="navbar-group">

+                                <UserBadgeDisplay

+                                    user={user}

+                                    syncing={syncing}

+                                    onLogout={handleLogout}

+                                />

+                                <ThemeToggle

+                                    currentTheme={theme}

+                                    toggle={toggleTheme}

+                                />

+                            </div>

+                        </div>

+                    )}

+                    {isLoadingQuestions || mode === "loading" ? (

+                        <div

+                            style={{

+                                margin: "2rem",

+                                fontSize: "1.2rem",

+                                color: "#888",

+                                display: "flex",

+                                flexDirection: "column",

+                                alignItems: "center",

+                                justifyContent: "center",

+                                height: "100%",

+                            }}

+                        >

+                            <div

+                                style={{

+                                    fontSize: "3rem",

+                                    marginBottom: "1rem",

+                                }}

+                            >

+                                ?

+                            </div>

+                            Na  t m ot zky a obr´┐Żzky...

+                        </div>

+                    ) : (

+                        <MainMenu

+                            scheduledTests={scheduledTests}

+                            completedTestIds={completedTestIds}

+                            menuSelection={menuSelection}

+                            isKeyboardMode={isKeyboardMode}

+                            isTeacher={isTeacher}

+                            userClass={profileData?.class}

+                user={user}

+                syncing={syncing}

+                theme={theme}

+                toggleTheme={toggleTheme}

+                            mistakesCount={mistakesCount}

+                            onOpenScheduled={() => setMode("scheduled_list")}

+                            onStartMock={() =>

+                                handleStartMode(startMockTest, "mock")

+                            }

+                            onStartSmart={() =>

+                                handleStartMode(startNewSmartSession, "smart")

+                            }

+                            onStartRandom={() =>

+                                handleStartMode(startRandomMode, "random")

+                            }

+                            onStartDuel={() => {

+                                if (profileData?.class === "4.B") {

+                                    setMode("duel");

+                                }

+                            }}

+                            onStartReview={() =>

+                                handleStartMode(startReviewMode, "review")

+                            }

+                            onOpenTeacherManager={() =>

+                                setMode("teacher_manager")

+                            }

+                            onStartMistakes={() =>

+                                handleStartMode(startMistakesMode, "mistakes")

+                            }

+                            onClearMistakes={() =>

+                                setShowClearMistakesConfirm(true)

+                            }

+                            onOpenHistory={openHistoryWithRefresh}

+                        />

+                    )}

+                </div>

+            </>

+        );

+    }

+

+    if (mode === "admin") return <AdminPanel onBack={() => setMode(null)} />;

+    if (mode === "no_mistakes")

+        return (

+            <NoMistakesScreen onBack={() => setMode(null)} subject={subject} />

+        );

+

+    if (mode === "history")

+        return (

+            <>

+                <HistoryView

+                    history={history}

+                    totalTimeMap={totalTimeMap}

+                    sessionTime={sessionTime}

+                    totalQuestionsMap={totalQuestionsMap}

+                    sessionQuestionsCount={sessionQuestionsCount}

+                    onBack={() => setMode(null)}

+                    currentSubject={subject}

+                    onDeleteRecord={setRecordToDelete}

+                    user={user}

+                    syncing={syncing}

+                />

+                {recordToDelete && (

+                    <ConfirmModal

+                        title="Smazat z´┐Żznam?"

+                        message="Smazat tento zgznam?"

+                        onCancel={() => setRecordToDelete(null)}

+                        onConfirm={() => {

+                            updateHistory((prev) =>

+                                prev.filter((h) => h.id !== recordToDelete),

+                            );

+                            setRecordToDelete(null);

+                        }}

+                        confirmText="Smazat"

+                        danger={true}

+                    />

+                )}

+            </>

+        );

+

+    if (mode === "review") {

+        const REVIEW_COLUMNS = window.innerWidth > 768 ? 2 : 1;

+        const REVIEW_ROWS = 5;

+        const REVIEW_ITEMS_PER_PAGE = REVIEW_COLUMNS * REVIEW_ROWS;

+        const normalizedSearch = removeAccents(searchTerm);

+        const filteredQuestions = questionSet.filter(

+            (q) =>

+                removeAccents(q.question).includes(normalizedSearch) ||

+                String(q.number).includes(normalizedSearch),

+        );

+        const highlightRegex = getSmartRegex(searchTerm);

+        const totalReviewPages = Math.ceil(

+            filteredQuestions.length / REVIEW_ITEMS_PER_PAGE,

+        );

+        const paginatedQuestions = filteredQuestions.slice(

+            reviewPage * REVIEW_ITEMS_PER_PAGE,

+            (reviewPage + 1) * REVIEW_ITEMS_PER_PAGE,

+        );

+

+        const scrollToTop = () => {

+            if (containerRef.current) {

+                containerRef.current.scrollTo({ top: 0, behavior: "smooth" });

+            } else {

+                window.scrollTo({ top: 0, behavior: "smooth" });

+            }

+        };

+

+        return (

+            <>

+                <CustomImageModal

+                    src={fullscreenImage}

+                    onClose={() => setFullscreenImage(null)}

+                />

+                {(() => {

+                    let activeReportQuestion = currentQuestion;

+                    if (questionToReport) {

+                        const found = activeQuestionsCache.find(

+                            (q) => q.number === questionToReport,

+                        );

+                        if (found) activeReportQuestion = found;

+                    }

+                    const qForModal = activeReportQuestion || {};

+                    return (

+                        <ReportModal

+                            isOpen={reportModalOpen}

+                            onClose={() => {

+                                setReportModalOpen(false);

+                                setQuestionToReport(null);

+                            }}

+                            theme={theme}

+                            questionText={qForModal.question}

+                            questionId={qForModal.id}

+                            subject={qForModal.subject || subject}

+                            questionNumber={qForModal.number}

+                            mode={mode}

+                            options={qForModal.options}

+                            correctIndex={qForModal.correctIndex}

+                            userAnswer={qForModal.userAnswer}

+                            username={user}

+                            userId={dbId}

+                            isExiting={!!exitDirection}

+                        />

+                    );

+                })()}

+                <div

+                    className="container fadeIn"

+                    style={{ minHeight: "var(--vh)" }}

+                >

+                    <div className="top-navbar" style={{ width: "100%" }}>

+                        <div className="navbar-group">

+                            <button

+                                className="menuBackButton"

+                                onClick={() => {

+                                    flushSessionStats();

+                                    tryReturnToMenu();

+                                }}

+                            >

+                                ´┐Ż <span className="mobile-hide-text">Zp─Ťt</span>

+                            </button>

+                            <SubjectBadge subject={subject} compact />

+                        </div>

+                        <div className="navbar-group">

+                            <UserBadgeDisplay user={user} syncing={syncing} />

+                            <ThemeToggle

+                                currentTheme={theme}

+                                toggle={toggleTheme}

+                            />

+                        </div>

+                    </div>

+                    <h1 className="title">Prohl"en{ ot├ízek</h1>

+                    <div className="reviewControls">

+                        <input

+                            type="text"

+                            placeholder="Hledat..."

+                            value={searchTerm}

+                            onChange={(e) => {

+                                setSearchTerm(e.target.value);

+                                setReviewPage(0);

+                            }}

+                            className="reviewSearchInput"

+                        />

+                        {totalReviewPages > 1 && (

+                            <div className="reviewPageInfo">

+                                Strana {reviewPage + 1} z {totalReviewPages} (

+                                {filteredQuestions.length} ot├ízek)

+                            </div>

+                        )}

+                    </div>

+                    <div className="reviewGrid">

+                        {paginatedQuestions.length === 0 ? (

+                            <p

+                                style={{

+                                    textAlign: "center",

+                                    color: "#888",

+                                    gridColumn: "1/-1",

+                                }}

+                            >

+                                Nic nenalezeno.

+                            </p>

+                        ) : (

+                            paginatedQuestions.map((q) => {

+                                const imageUrl =

+                                    q.image_base64 ||

+                                    (q.id ? getCachedImage(q.id) : null) ||

+                                    getImageUrl(subject, q.number) ||

+                                    (q.image && q.image.length > 5

+                                        ? q.image

+                                        : null);

+                                return (

+                                    <div

+                                        key={`${q.number}-${reviewPage}`}

+                                        className="reviewCard"

+                                    >

+                                        <div

+                                            className="reviewHeader"

+                                            style={{

+                                                display: "flex",

+                                                alignItems: "flex-start",

+                                                gap: "10px",

+                                                position: "relative",

+                                            }}

+                                        >

+                                            <div style={{ flex: 1 }}>

+                                                <strong>#{q.number}.</strong>{" "}

+                                                <HighlightedText

+                                                    text={q.question}

+                                                    highlightRegex={

+                                                        highlightRegex

+                                                    }

+                                                />

+                                            </div>

+                                            <button

+                                                className="report-btn-flash"

+                                                onClick={() =>

+                                                    handleReportClick(q.number)

+                                                }

+                                                style={{

+                                                    background: "transparent",

+                                                    border: "none",

+                                                    padding: "4px",

+                                                    width: "32px",

+                                                    height: "32px",

+                                                    display: "flex",

+                                                    alignItems: "center",

+                                                    justifyContent: "center",

+                                                    cursor: "pointer",

+                                                    fontSize: "1.1rem",

+                                                    flexShrink: 0,

+                                                    opacity: 0.7,

+                                                    marginTop: "-2px",

+                                                }}

+                                                title="Nahl´┐Żsit chybu v t´┐Żto ot´┐Żzce"

+                                            >

+                                                ???

+                                            </button>

+                                        </div>

+                                        <ReviewImage

+                                            q={q}

+                                            subject={subject}

+                                            setFullscreenImage={

+                                                setFullscreenImage

+                                            }

+                                        />

+                                        <div

+                                            style={{

+                                                marginTop: "1rem",

+                                                display: "flex",

+                                                flexDirection: "column",

+                                                gap: "0.4rem",

+                                            }}

+                                        >

+                                            {q.options.map((opt, idx) => (

+                                                <div

+                                                    key={idx}

+                                                    style={{

+                                                        fontSize: "0.9rem",

+                                                        color:

+                                                            idx ===

+                                                            q.correctIndex

+                                                                ? "var(--color-review-correct)"

+                                                                : "var(--color-text-secondary)",

+                                                        fontWeight:

+                                                            idx ===

+                                                            q.correctIndex

+                                                                ? "bold"

+                                                                : "normal",

+                                                    }}

+                                                >

+                                                    <span>

+                                                        {idx === q.correctIndex

+                                                            ? "?"

+                                                            : "´┐Ż"}

+                                                    </span>{" "}

+                                                    <span>

+                                                        <HighlightedText

+                                                            text={opt}

+                                                            highlightRegex={

+                                                                highlightRegex

+                                                            }

+                                                        />

+                                                    </span>

+                                                </div>

+                                            ))}

+                                        </div>

+                                    </div>

+                                );

+                            })

+                        )}

+                    </div>

+                    <ReviewNavigator

+                        currentPage={reviewPage}

+                        totalPages={totalReviewPages}

+                        onPageChange={(page) => {

+                            setReviewPage(page);

+                        }}

+                    />

+                </div>

+            </>

+        );

+    }

+

+    if (mode === "duel") {

+        if (profileData?.class !== "4.B") {

+            setMode(null);

+            return null;

+        }

+

+        const onlineClassmates = duelOnlineUsers.filter(

+            (u) => u.class === "4.B",

+        );

+        const allowedCounts = [5, 10, 20, 50];

+

+        return (

+            <>                {duelInviteToShow && (
+                    <ConfirmModal
+                        title="Pozvvnka do duelu"
+                        message={
+                            <div style={{ textAlign: "left" }}>
+                                <p style={{ marginBottom: "0.5rem" }}>
+                                    {duelInviteToShow.challenger_name} t´┐Ż zve na duel.
+                                </p>
+                                <div
+                                    style={{
+                                        display: "grid",
+                                        gap: "6px",
+                                        fontSize: "0.9rem",
+                                        color: "var(--color-text-secondary)",
+                                    }}
+                                >
+                                    <div>
+                                        Pcedmst:{" "}
+                                        <strong>
+                                            {duelInviteToShow.subject}
+                                        </strong>
+                                    </div>
+                                    <div>
+                                        Poget otczek:{" "}
+                                        <strong>
+                                            {duelInviteToShow.question_count}
+                                        </strong>
+                                    </div>
+                                </div>
+                            </div>
+                        }
+                        onCancel={() => declineDuelInvite(duelInviteToShow)}
+                        onConfirm={() => acceptDuelInvite(duelInviteToShow)}
+                        confirmText="Paijmout"
+                        cancelText="Odm=tnout"
+                        danger={false}
+                    />
+                )}
+

+                <div

+                    className="container fadeIn"

+                    style={{

+                        minHeight: "var(--vh)",

+                        paddingBottom: "2rem",

+                    }}

+                >

+                    <div className="top-navbar" style={{ width: "100%" }}>

+                        <div className="navbar-group">

+                            <button

+                                className="menuBackButton"

+                                onClick={() => setMode(null)}

+                            >

+                                {"´┐Ż"}{" "}

+                                <span className="mobile-hide-text">Zp─Ťt</span>

+                            </button>

+                            <SubjectBadge subject={subject} compact />

+                        </div>

+                        <div className="navbar-group">

+                            <UserBadgeDisplay user={user} syncing={syncing} />

+                            <ThemeToggle

+                                currentTheme={theme}

+                                toggle={toggleTheme}

+                            />

+                        </div>

+                    </div>

+

+                    <h1 className="title">Duel 1v1</h1>

+                    <p

+                        style={{

+                            textAlign: "center",

+                            color: "var(--color-text-secondary)",

+                            marginTop: "-0.5rem",

+                        }}

+                    >

+                        Online souboj pouze pro t┼Ö├şdu 4.B.

+                    </p>

+

+                    <div

+                        className="card"

+                        style={{ padding: "1rem 1.25rem", marginTop: "1.5rem" }}

+                    >

+                        <h3 style={{ marginTop: 0 }}>Nastaven├ş duelu</h3>

+                        <div

+                            style={{

+                                display: "grid",

+                                gap: "0.75rem",

+                            }}

+                        >

+                            <div>

+                                <div

+                                    style={{

+                                        fontWeight: 600,

+                                        marginBottom: "0.5rem",

+                                    }}

+                                >

+                                    Po─Źet ot├ízek

+                                </div>

+                                <div

+                                    style={{

+                                        display: "flex",

+                                        flexWrap: "wrap",

+                                        gap: "0.5rem",

+                                    }}

+                                >

+                                    {allowedCounts.map((count) => (

+                                        <button

+                                            key={count}

+                                            className={`navButton ${duelSettings.questionCount === count ? "primary" : ""}`}

+                                            onClick={() =>

+                                                setDuelSettings((prev) => ({

+                                                    ...prev,

+                                                    questionCount: count,

+                                                }))

+                                            }

+                                        >

+                                            {count}

+                                        </button>

+                                    ))}

+                                </div>

+                            </div>

+                            <div>

+                                <div

+                                    style={{

+                                        fontWeight: 600,

+                                        marginBottom: "0.5rem",

+                                    }}

+                                >

+                                    Rozsah ot├ízek

+                                </div>

+                                <div

+                                    style={{

+                                        display: "flex",

+                                        gap: "0.5rem",

+                                        flexWrap: "wrap",

+                                    }}

+                                >

+                                    <button

+                                        className={`navButton ${duelSettings.rangeMode === "all" ? "primary" : ""}`}

+                                        onClick={() =>

+                                            setDuelSettings((prev) => ({

+                                                ...prev,

+                                                rangeMode: "all",

+                                            }))

+                                        }

+                                    >

+                                        V┼íe

+                                    </button>

+                                    <button

+                                        className={`navButton ${duelSettings.rangeMode === "range" ? "primary" : ""}`}

+                                        onClick={() =>

+                                            setDuelSettings((prev) => ({

+                                                ...prev,

+                                                rangeMode: "range",

+                                            }))

+                                        }

+                                    >

+                                        Vybran├Ż rozsah

+                                    </button>

+                                </div>

+                                {duelSettings.rangeMode === "range" && (

+                                    <div

+                                        style={{

+                                            marginTop: "0.75rem",

+                                            display: "flex",

+                                            gap: "0.5rem",

+                                        }}

+                                    >

+                                        <input

+                                            type="number"

+                                            placeholder="Od"

+                                            value={duelSettings.rangeStart}

+                                            onChange={(e) =>

+                                                setDuelSettings((prev) => ({

+                                                    ...prev,

+                                                    rangeStart: e.target.value,

+                                                }))

+                                            }

+                                            className="reviewSearchInput"

+                                            style={{ maxWidth: "120px" }}

+                                        />

+                                        <input

+                                            type="number"

+                                            placeholder="Do"

+                                            value={duelSettings.rangeEnd}

+                                            onChange={(e) =>

+                                                setDuelSettings((prev) => ({

+                                                    ...prev,

+                                                    rangeEnd: e.target.value,

+                                                }))

+                                            }

+                                            className="reviewSearchInput"

+                                            style={{ maxWidth: "120px" }}

+                                        />

+                                    </div>

+                                )}

+                            </div>

+                            {duelError && (

+                                <div style={{ color: "var(--color-error)" }}>

+                                    {duelError}

+                                </div>

+                            )}

+                        </div>

+                    </div>

+

+                    <div

+                        className="card"

+                        style={{ padding: "1rem 1.25rem", marginTop: "1.5rem" }}

+                    >

+                        <h3 style={{ marginTop: 0 }}>Online spolu┼ż├íci</h3>

+                        {duelOutgoingMatch && (

+                            <div

+                                style={{

+                                    marginBottom: "1rem",

+                                    padding: "0.75rem",

+                                    borderRadius: "12px",

+                                    background: "var(--color-bg-secondary)",

+                                    display: "flex",

+                                    alignItems: "center",

+                                    justifyContent: "space-between",

+                                    gap: "1rem",

+                                }}

+                            >

+                                <div>

+                                    <div style={{ fontWeight: 600 }}>

+                                        ─îek├ím na odpov─Ť─Ć od{" "}

+                                        {duelOutgoingMatch.opponent_name}

+                                    </div>

+                                    <div

+                                        style={{

+                                            fontSize: "0.85rem",

+                                            color: "var(--color-text-secondary)",

+                                        }}

+                                    >

+                                        {duelOutgoingMatch.question_count} ot├ízek

+                                    </div>

+                                </div>

+                                <button

+                                    className="navButton"

+                                    onClick={cancelOutgoingDuel}

+                                >

+                                    Zru┼íit

+                                </button>

+                            </div>

+                        )}

+                        {onlineClassmates.length === 0 && (

+                            <div

+                                style={{

+                                    color: "var(--color-text-secondary)",

+                                }}

+                            >

+                                Zat├şm nikdo nen├ş online.

+                            </div>

+                        )}

+                        {onlineClassmates.map((student) => (

+                            <div

+                                key={student.id}

+                                style={{

+                                    display: "flex",

+                                    alignItems: "center",

+                                    justifyContent: "space-between",

+                                    padding: "0.75rem 0",

+                                    borderBottom:

+                                        "1px solid var(--color-border)",

+                                }}

+                            >

+                                <div>

+                                    <div style={{ fontWeight: 600 }}>

+                                        {student.username}

+                                    </div>

+                                    <div

+                                        style={{

+                                            fontSize: "0.85rem",

+                                            color: "var(--color-text-secondary)",

+                                        }}

+                                    >

+                                        Online

+                                    </div>

+                                </div>

+                                <button

+                                    className="navButton primary"

+                                    onClick={() => createDuelMatch(student)}

+                                    disabled={!!duelOutgoingMatch}

+                                >

+                                    Vyzvat

+                                </button>

+                            </div>

+                        ))}

+                    </div>

+                </div>

+            </>

+        );

+    }

+

+    if (mode === "duel_match") {

+        if (!duelActiveMatch) {

+            setMode("duel");

+            return null;

+        }

+

+        const opponent = getDuelOpponent(duelActiveMatch);

+        const progress = getDuelProgress(duelActiveMatch, duelClock, true);

+        const questionIndex = Math.min(

+            progress.index,

+            duelActiveMatch.question_count - 1,

+        );

+        const currentDuelQuestion = duelQuestionSet[questionIndex];

+        const myConfirmedAnswer = getAnswerFor(dbId, questionIndex);

+        const myLocalAnswer = duelLocalAnswers[questionIndex];

+        const mySelectedAnswer =

+            myLocalAnswer?.answerIndex ??

+            myConfirmedAnswer?.answer_index ??

+            null;

+        const opponentAnswer = opponent

+            ? getAnswerFor(opponent.id, questionIndex)

+            : null;

+        const isAnswerPhase = progress.phase === "answer";

+        const isResultPhase = progress.phase === "result";

+        const hasAnswered = !!myConfirmedAnswer || !!myLocalAnswer;

+        const { myScore, opponentScore } = computeDuelScore();

+        let duelTimeLeft = progress.timeLeft;

+        if (

+            isAnswerPhase &&

+            duelRushOverride &&

+            duelRushOverride.questionIndex === progress.index

+        ) {

+            const overrideLeft = Math.ceil(

+                (duelRushOverride.endAt - duelClock) / 1000,

+            );

+            if (overrideLeft > 0 && overrideLeft < duelTimeLeft) {

+                duelTimeLeft = overrideLeft;

+            }

+        }

+

+        if (progress.phase === "finished") {

+            return (

+                <div

+                    className="container fadeIn"

+                    style={{ minHeight: "var(--vh)" }}

+                >

+                    <div className="top-navbar" style={{ width: "100%" }}>

+                        <div className="navbar-group">

+                            <button

+                                className="menuBackButton"

+                                onClick={() => setMode(null)}

+                            >

+                                {" "}{" "}

+                                <span className="mobile-hide-text">Zp─Ťt</span>

+                            </button>

+                            <SubjectBadge subject={subject} compact />

+                        </div>

+                        <div className="navbar-group">

+                            <UserBadgeDisplay user={user} syncing={syncing} />

+                            <ThemeToggle

+                                currentTheme={theme}

+                                toggle={toggleTheme}

+                            />

+                        </div>

+                    </div>

+                    <div

+                        className="card"

+                        style={{

+                            marginTop: "2rem",

+                            padding: "2rem",

+                            textAlign: "center",

+                        }}

+                    >

+                        <h2 style={{ marginTop: 0 }}>Duel dokon─Źen</h2>

+                        <p

+                            style={{

+                                color: "var(--color-text-secondary)",

+                                marginTop: "0.5rem",

+                            }}

+                        >

+                            {opponent ? `Soupe┼Ö: ${opponent.username}` : ""}

+                        </p>

+                        <div

+                            style={{

+                                fontSize: "2rem",

+                                fontWeight: 700,

+                                marginTop: "1rem",

+                            }}

+                        >

+                            {myScore} : {opponentScore}

+                        </div>

+                        <div style={{ marginTop: "1.5rem" }}>

+                            <button

+                                className="navButton primary"

+                                onClick={() => setMode(null)}

+                            >

+                                Zp─Ťt do menu

+                            </button>

+                        </div>

+                    </div>

+                </div>

+            );

+        }

+

+        return (

+            <>

+                <CustomImageModal

+                    src={fullscreenImage}

+                    onClose={() => setFullscreenImage(null)}

+                />

+                <div

+                    className="container fadeIn"

+                    style={{ minHeight: "var(--vh)", paddingBottom: "2rem" }}

+                >

+                    <div className="top-navbar" style={{ width: "100%" }}>

+                        <div className="navbar-group">

+                            <button
+                                className="menuBackButton"
+                                onClick={leaveActiveDuel}
+                            >
+                                {"´┐Ż"}{" "}

+                                <span className="mobile-hide-text">Zp─Ťt</span>

+                            </button>

+                            <SubjectBadge subject={subject} compact />

+                        </div>

+                        <div className="navbar-group">

+                            <div

+                                className="timer"

+                                style={{

+                                    background: isAnswerPhase

+                                        ? "var(--color-bg-secondary)"

+                                        : "rgba(59, 130, 246, 0.15)",

+                                    color: "var(--color-text-main)",

+                                }}

+                            >

+                            {duelTimeLeft}s

+                            </div>

+                            <UserBadgeDisplay user={user} syncing={syncing} />

+                            <ThemeToggle

+                                currentTheme={theme}

+                                toggle={toggleTheme}

+                            />

+                        </div>

+                    </div>

+

+                    <div className="quizContentWrapper">

+                        <h1 className="title">Duel</h1>

+                        <div

+                            className="flashcardHeader"

+                            style={{ marginBottom: "1.5rem" }}

+                        >

+                            <div className="statItem">

+                                <span className="statLabel">Ot├ízka</span>

+                                <span className="statValue">

+                                    {questionIndex + 1} /{" "}

+                                    {duelActiveMatch.question_count}

+                                </span>

+                            </div>

+                            <div className="statItem">

+                                <span className="statLabel">Sk├│re</span>

+                                <span className="statValue">

+                                    {myScore} : {opponentScore}

+                                </span>

+                            </div>

+                            <div className="statItem">

+                                <span className="statLabel">Stav</span>

+                                <span className="statValue">

+                                    {isAnswerPhase

+                                        ? "Odpov─Ť─Ć"

+                                        : "Vyhodnocen├ş"}

+                                </span>

+                            </div>

+                        </div>

+

+                        {!currentDuelQuestion ? (

+                            <div

+                                className="card"

+                                style={{

+                                    padding: "2rem",

+                                    textAlign: "center",

+                                }}

+                            >

+                                Nahr├ív├ím ot├ízku...

+                            </div>

+                        ) : (

+                            <div

+                                className="card"

+                                style={{ position: "relative" }}

+                            >

+                                <QuestionCard

+                                    currentQuestion={currentDuelQuestion}

+                                    mode="duel"

+                                    isActive={true}

+                                    shouldLoadImage={true}

+                                    showResult={isResultPhase}

+                                    selectedAnswer={mySelectedAnswer}

+                                    visualSelection={null}

+                                    onSelect={(idx) =>

+                                        !hasAnswered &&

+                                        isAnswerPhase &&

+                                        submitDuelAnswer(idx)

+                                    }

+                                    onSwipe={() => {}}

+                                    onZoom={setFullscreenImage}

+                                    onReport={handleReportClick}

+                                    optionRefsForCurrent={null}

+                                    disabled={!isAnswerPhase || hasAnswered}

+                                    isKeyboardMode={false}

+                                    currentSubject={subject}

+                                    score={score}

+                                    isExiting={false}

+                                />

+                                <div

+                                    style={{

+                                        marginTop: "1rem",

+                                        display: "flex",

+                                        alignItems: "center",

+                                        justifyContent: "space-between",

+                                        color: "var(--color-text-secondary)",

+                                        fontSize: "0.9rem",

+                                    }}

+                                >

+                                    <span>

+                                        {hasAnswered

+                                            ? "Odpov─Ť─Ć odesl├ína"

+                                            : "Vyber odpov─Ť─Ć"}

+                                    </span>

+                                    <span>

+                                        {opponent

+                                            ? opponentAnswer

+                                                ? "Soupe┼Ö odpov─Ťd─Ťl"

+                                                : "─îek├ím na soupe┼Öe"

+                                            : ""}

+                                    </span>

+                                </div>

+                            </div>

+                        )}

+                    </div>

+                </div>

+            </>

+        );

+    }

+

+    let comboClass =

+        combo >= 10

+            ? "combo-high"

+            : combo >= 5

+              ? "combo-med"

+              : combo >= 3

+                ? "combo-low"

+                : "";

+    let remainingCards = 0;

+    if (mode === "smart" || mode === "mistakes")

+        remainingCards = questionSet.length;

+    else if (mode === "random" || mode === "test_practice")

+        remainingCards = questionSet.length - currentIndex;

+

+    let stackLevelClass = "";

+    if (remainingCards <= 1) stackLevelClass = "stack-level-0";

+    else if (remainingCards === 2) stackLevelClass = "stack-level-1";

+

+    return (

+        <>

+            <CustomImageModal

+                src={fullscreenImage}

+                onClose={() => setFullscreenImage(null)}

+            />

+            {(() => {

+                let activeReportQuestion = currentQuestion;

+                if (questionToReport) {

+                    const found = activeQuestionsCache.find(

+                        (q) => q.number === questionToReport,

+                    );

+                    if (found) activeReportQuestion = found;

+                }

+                const qForModal = activeReportQuestion || {};

+                return (

+                    <ReportModal

+                        isOpen={reportModalOpen}

+                        onClose={() => {

+                            setReportModalOpen(false);

+                            setQuestionToReport(null);

+                        }}

+                        theme={theme}

+                        questionText={qForModal.question}

+                        questionId={qForModal.id}

+                        subject={qForModal.subject || subject}

+                        questionNumber={qForModal.number}

+                        mode={mode}

+                        options={qForModal.options}

+                        correctIndex={qForModal.correctIndex}

+                        userAnswer={qForModal.userAnswer}

+                        username={user}

+                        userId={dbId}

+                        isExiting={!!exitDirection}

+                    />

+                );

+            })()}

+

+            <div

+                className="container fadeIn"

+                style={{ minHeight: "var(--vh)", paddingBottom: "2rem" }}

+            >

+                {showConfirmSubmit && (

+                    <ConfirmModal

+                        title={

+                            mode === "real_test"

+                                ? "Odevzdat test?"

+                                : "Odevzdat?"

+                        }

+                        message={

+                            mode === "real_test"

+                                ? "Po odevzd´┐Żn´┐Ż u´┐Ż nep´┐Żjde odpov´┐Żdi zm´┐Żnit."

+                                : "Opravdu odevzdat?"

+                        }

+                        onCancel={() => setShowConfirmSubmit(false)}

+                        onConfirm={mode === "real_test" ? () => {} : submitTest}

+                        confirmText={mode === "real_test" ? "ODEVZDAT" : "Ano"}

+                        danger={mode === "real_test"}

+                    />

+                )}

+                {showConfirmExit && (

+                    <ConfirmModal

+                        title="Ukon´┐Żit?"

+                        message="Ztracen´┐Ż odpov´┐Żdi nebudou ulo´┐Żeny."

+                        onCancel={() => setShowConfirmExit(false)}

+                        onConfirm={confirmExit}

+                        confirmText="Ukon´┐Żit"

+                    />

+                )}

+

+                {/* --- SAVE PROGRESS PROMPT --- */}

+                {showSaveProgressPrompt && (

+                    <ConfirmModal

+                        title="Ulo´┐Żit postup?"

+                        message={

+                            <div>

+                                <p>

+                                    Chce´┐Ż si ulo´┐Żit aktu´┐Żln´┐Ż postup na p´┐Ż´┐Żt´┐Ż?

+                                </p>

+                                <p

+                                    style={{

+                                        fontSize: "0.85rem",

+                                        color: "var(--color-text-secondary)",

+                                        marginTop: "0.5rem",

+                                    }}

+                                >

+                                    (Pokud zvol´┐Ż 'Neukl´┐Żdat', tento

+                                    rozpracovan´┐Ż bal´┐Ż´┐Żek se sma´┐Że.)

+                                </p>

+                            </div>

+                        }

+                        onCancel={() => handleSaveAndExit(false)} // Ne = smazat a odej´┐Żt

+                        onConfirm={() => handleSaveAndExit(true)} // Ano = nechat ulo´┐Żeno a odej´┐Żt

+                        confirmText="Ulo´┐Żit a odej´┐Żt"

+                        cancelText="Neukl´┐Żdat"

+                        danger={false}

+                    />

+                )}

+

+                {finished && (

+                    <ResultScreen

+                        mode={mode}

+                        score={score}

+                        trainingTime={trainingTime}

+                        questionSet={questionSet}

+                        maxSeenIndex={maxSeenIndex}

+                        // --- OPRAVA: P´┐ŻID´┐ŻN´┐Ż LOGIKY ONBACK ---

+                        onBack={() => {

+                            if (mode === "smart") {

+                                clearSmartSession();

+                            }

+                            setMode(null);

+                            setCombo(0);

+                        }}

+                        // ------------------------------------

+

+                        currentSubject={subject}

+                        timeLeftAtSubmit={timeLeftAtSubmit}

+                        onZoom={setFullscreenImage}

+                        user={user}

+                        syncing={syncing}

+                        onReport={handleReportClick}

+                        theme={theme}

+                        toggleTheme={toggleTheme}

+                    />

+                )}

+

+                {mode === "loading" && (

+                    <div

+                        className="fadeIn"

+                        style={{

+                            position: "fixed",

+                            top: 0,

+                            left: 0,

+                            width: "100%",

+                            height: "100%",

+                            height: "100dvh",

+                            display: "flex",

+                            alignItems: "center",

+                            justifyContent: "center",

+                            backgroundColor: "var(--color-bg-body)",

+                            zIndex: 9999,

+                            backdropFilter: "blur(5px)",

+                        }}

+                    >

+                        <div

+                            className="card"

+                            style={{

+                                padding: "2.5rem 2rem",

+                                width: "90%",

+                                maxWidth: "400px",

+                                display: "flex",

+                                flexDirection: "column",

+                                alignItems: "center",

+                                gap: "1.5rem",

+                                boxShadow:

+                                    "0 25px 50px -12px rgba(0, 0, 0, 0.25)",

+                                border: "1px solid var(--color-border)",

+                                textAlign: "center",

+                            }}

+                        >

+                            <div

+                                style={{

+                                    transform: "scale(1.2)",

+                                    marginBottom: "0.5rem",

+                                }}

+                            >

+                                <SubjectBadge subject={subject} />

+                            </div>

+

+                            <div className="custom-loader"></div>

+

+                            <div>

+                                <h2

+                                    style={{

+                                        margin: 0,

+                                        fontSize: "1.4rem",

+                                        fontWeight: "700",

+                                    }}

+                                >

+                                    {activeTest

+                                        ? "P´┐Ż´┐Żprava testu"

+                                        : "Na´┐Ż´┐Żt´┐Żm data"}

+                                </h2>

+                                <p

+                                    style={{

+                                        margin: "0.5rem 0 0",

+                                        color: "var(--color-text-secondary)",

+                                        fontSize: "0.95rem",

+                                    }}

+                                >

+                                    Kompletuji ot´┐Żzky a stahuji obr´┐Żzky...

+                                </p>

+                            </div>

+

+                            <div

+                                style={{

+                                    width: "100%",

+                                    display: "flex",

+                                    flexDirection: "column",

+                                    gap: "8px",

+                                }}

+                            >

+                                <div

+                                    style={{

+                                        width: "100%",

+                                        height: "8px",

+                                        background: "var(--color-bg-secondary)",

+                                        borderRadius: "99px",

+                                        overflow: "hidden",

+                                    }}

+                                >

+                                    <div

+                                        style={{

+                                            width: `${loadingProgress}%`,

+                                            height: "100%",

+                                            background: "var(--color-primary)",

+                                            transition: "width 0.3s ease-out",

+                                            borderRadius: "99px",

+                                        }}

+                                    ></div>

+                                </div>

+                                <span

+                                    style={{

+                                        fontSize: "0.85rem",

+                                        color: "var(--color-text-secondary)",

+                                        fontWeight: "bold",

+                                    }}

+                                >

+                                    {Math.round(loadingProgress)}%

+                                </span>

+                            </div>

+

+                            <style>{`

+                                .custom-loader {

+                                    width: 40px;

+                                    height: 40px;

+                                    border: 4px solid var(--color-bg-secondary);

+                                    border-top: 4px solid var(--color-primary);

+                                    border-radius: 50%;

+                                    animation: spin 1s linear infinite;

+                                }

+                                @keyframes spin {

+                                    0% { transform: rotate(0deg); }

+                                    100% { transform: rotate(360deg); }

+                                }

+                            `}</style>

+                        </div>

+                    </div>

+                )}

+                {!finished && mode !== "loading" && (

+                    <>

+                        <div className="top-navbar" style={{ width: "100%" }}>

+                            <div className="navbar-group">

+                                {mode === "real_test" ? (

+                                    <span

+                                        style={{

+                                            fontWeight: "bold",

+                                            color: "var(--color-error)",

+                                        }}

+                                    >

+                                        ?? TEST: NEOPOU´┐ŻT´┐ŻJ OKNO!

+                                    </span>

+                                ) : (

+                                    <button

+                                        className="menuBackButton"

+                                        onClick={tryReturnToMenu}

+                                    >

+                                        {"´┐Ż"}{" "}

+                                        <span className="mobile-hide-text">

+                                            Zp─Ťt

+                                        </span>

+                                    </button>

+                                )}

+                                <div className="mobile-hidden">

+                                    <SubjectBadge subject={subject} compact />

+                                </div>

+                            </div>

+                            <div className="navbar-group">

+                                {mode === "mock" && (

+                                    <div

+                                        className={`timer ${timeLeft <= 300 ? "timerWarning" : ""} ${timeLeft <= 60 ? "timerDanger" : ""}`}

+                                    >

+                                        {formatTime(timeLeft)}

+                                    </div>

+                                )}

+                                {(mode === "training" ||

+                                    mode === "smart" ||

+                                    mode === "mistakes") && (

+                                    <div className="timer">

+                                        {formatTime(trainingTime)}

+                                    </div>

+                                )}

+                                <UserBadgeDisplay

+                                    user={user}

+                                    syncing={syncing}

+                                    compactOnMobile={true}

+                                />

+                                <ThemeToggle

+                                    currentTheme={theme}

+                                    toggle={toggleTheme}

+                                />

+                            </div>

+                        </div>

+                        <div className="quizContentWrapper">

+                            <h1 className="title">

+                                {mode === "real_test"

+                                    ? activeTest?.title

+                                    : mode === "random"

+                                      ? "Flashcards"

+                                      : mode === "mock"

+                                        ? "Test nane´┐Żisto"

+                                        : mode === "mistakes"

+                                          ? "Opravna chyb"

+                                          : mode === "smart" ||

+                                              mode === "test_practice"

+                                            ? "Procvi´┐Żov´┐Żn´┐Ż"

+                                            : "Tr´┐Żninkov´┐Ż re´┐Żim"}

+                            </h1>

+

+                            {isFlashcardStyle(mode) ||

+                            mode === "test_practice" ? (

+                                <div

+                                    className={`flashcardHeader ${comboClass}`}

+                                >

+                                    {mode !== "test_practice" && (

+                                        <div className="statItem">

+                                            <span className="statLabel">

+                                                {mode === "random"

+                                                    ? "Zodpov´┐Żzeno"

+                                                    : "Zb´┐Żv´┐Ż"}

+                                            </span>

+                                            <span className="statValue">

+                                                {mode === "random"

+                                                    ? currentIndex

+                                                    : remainingCards}

+                                            </span>

+                                        </div>

+                                    )}

+                                    {combo >= 3 && (

+                                        <div className="comboContainer">

+                                            <div className="comboFlame">??</div>

+                                            <div className="comboCount">

+                                                {combo}x

+                                            </div>

+                                        </div>

+                                    )}

+                                    <div

+                                        className="statItem"

+                                        style={{

+                                            textAlign: "right",

+                                            marginLeft: "auto",

+                                        }}

+                                    >

+                                        <span className="statLabel">

+                                            ´┐Żsp´┐Żnost

+                                        </span>

+                                        <span className="statValue">

+                                            {mode === "test_practice" &&

+                                            activeTest

+                                                ? (() => {

+                                                      const stats =

+                                                          testPracticeStats[

+                                                              activeTest.id

+                                                          ] || [];

+                                                      if (stats.length === 0)

+                                                          return "0%";

+                                                      return (

+                                                          Math.round(

+                                                              (stats.filter(

+                                                                  Boolean,

+                                                              ).length /

+                                                                  stats.length) *

+                                                                  100,

+                                                          ) + "%"

+                                                      );

+                                                  })()

+                                                : (score.total > 0

+                                                      ? Math.round(

+                                                            (score.correct /

+                                                                score.total) *

+                                                                100,

+                                                        )

+                                                      : 0) + "%"}

+                                        </span>

+                                    </div>

+                                </div>

+                            ) : (

+                                <>

+                                    <div className="progressBarContainer">

+                                        <div

+                                            className="progressBarFill"

+                                            style={{

+                                                width: `${((currentIndex + 1) / questionSet.length) * 100}%`,

+                                            }}

+                                        ></div>

+                                    </div>

+                                    <div className="progressText">

+                                        Ot├ízka {currentIndex + 1} /{" "}

+                                        {questionSet.length}

+                                    </div>

+                                </>

+                            )}

+

+                            <div

+                                className={`card ${isFlashcardStyle(mode) || mode === "test_practice" ? `stacked-card ${stackLevelClass}` : ""} ${shake ? "shake" : ""}`}

+                                ref={cardRef}

+                                style={{

+                                    minHeight: "200px",

+                                    position: "relative",

+                                }}

+                            >

+                                {questionSet.map((q, index) => {

+                                    const isFlashcardMode =

+                                        mode === "random" ||

+                                        mode === "smart" ||

+                                        mode === "mistakes" ||

+                                        mode === "test_practice";

+

+                                    if (isFlashcardMode) {

+                                        if (

+                                            index !== currentIndex &&

+                                            index !== currentIndex + 1

+                                        )

+                                            return null;

+                                    }

+

+                                    const isCurrent = index === currentIndex;

+                                    const loadImg = isFlashcardMode

+                                        ? index === currentIndex ||

+                                          index === currentIndex + 1

+                                        : Math.abs(index - currentIndex) <= 2;

+

+                                    let animClass = "";

+                                    if (isCurrent && !isFlashcardMode) {

+                                        if (direction === "left")

+                                            animClass = "slide-in-left";

+                                        else if (direction === "right")

+                                            animClass = "slide-in-right";

+                                    }

+

+                                    return (

+                                        <div

+                                            key={

+                                                q._instanceId ||

+                                                q.id ||

+                                                q.number ||

+                                                index

+                                            }

+                                            style={{

+                                                position: isCurrent

+                                                    ? "relative"

+                                                    : "absolute",

+                                                top: 0,

+                                                left: 0,

+                                                width: "100%",

+                                                opacity: isCurrent ? 1 : 0,

+                                                zIndex: isCurrent ? 2 : -1,

+                                                pointerEvents: isCurrent

+                                                    ? "auto"

+                                                    : "none",

+                                                display: "block",

+                                            }}

+                                            className={animClass}

+                                        >

+                                            <QuestionCard

+                                                currentQuestion={q}

+                                                mode={mode}

+                                                isActive={isCurrent}

+                                                shouldLoadImage={loadImg}

+                                                showResult={

+                                                    showResult && isCurrent

+                                                }

+                                                selectedAnswer={

+                                                    isCurrent

+                                                        ? selectedAnswer

+                                                        : q.userAnswer

+                                                }

+                                                visualSelection={

+                                                    isCurrent

+                                                        ? visualSelection

+                                                        : null

+                                                }

+                                                onSelect={(i) =>

+                                                    isFlashcardStyle(mode) ||

+                                                    mode === "test_practice"

+                                                        ? clickFlashcardAnswer(

+                                                              i,

+                                                          )

+                                                        : handleAnswer(i)

+                                                }

+                                                onSwipe={handleSwipe}

+                                                onZoom={setFullscreenImage}

+                                                onReport={handleReportClick}

+                                                onContentReady={

+                                                    isCurrent

+                                                        ? setReadyQuestionId

+                                                        : undefined

+                                                }

+                                                optionRefsForCurrent={

+                                                    isCurrent

+                                                        ? optionRefsForCurrent

+                                                        : null

+                                                }

+                                                disabled={

+                                                    (isFlashcardStyle(mode) ||

+                                                        mode ===

+                                                            "test_practice") &&

+                                                    showResult

+                                                }

+                                                isKeyboardMode={isKeyboardMode}

+                                                currentSubject={subject}

+                                                score={score}

+                                                isExiting={

+                                                    isCurrent && !!exitDirection

+                                                }

+                                            />

+                                        </div>

+                                    );

+                                })}

+

+                                {(isFlashcardStyle(mode) ||

+                                    mode === "test_practice") &&

+                                    !showResult && (

+                                        <div

+                                            className="actionButtons right"

+                                            style={{ minHeight: "50px" }}

+                                        >

+                                            <button

+                                                className="navButton primary"

+                                                onClick={confirmFlashcardAnswer}

+                                            >

+                                                Potvrdit

+                                            </button>

+                                        </div>

+                                    )}

+

+                                {(isFlashcardStyle(mode) ||

+                                    mode === "test_practice") &&

+                                    showResult && (

+                                        <div

+                                            className="actionButtons right"

+                                            style={{ minHeight: "50px" }}

+                                        >

+                                            <button

+                                                className="navButton"

+                                                onClick={nextFlashcardQuestion}

+                                            >

+                                                Dal´┐Ż´┐Ż ot´┐Żzka

+                                            </button>

+                                        </div>

+                                    )}

+

+                                {!(

+                                    isFlashcardStyle(mode) ||

+                                    mode === "test_practice"

+                                ) && (

+                                    <div style={{ marginTop: "1rem" }}>

+                                        <div className="actionButtons spaced">

+                                            <button

+                                                className="navButton"

+                                                onClick={() =>

+                                                    moveToQuestion(

+                                                        Math.max(

+                                                            0,

+                                                            currentIndex - 1,

+                                                        ),

+                                                    )

+                                                }

+                                                disabled={currentIndex === 0}

+                                            >

+                                                P´┐Żedchoz´┐Ż

+                                            </button>

+                                            <button

+                                                className="navButton"

+                                                onClick={() =>

+                                                    moveToQuestion(

+                                                        currentIndex + 1,

+                                                    )

+                                                }

+                                                disabled={

+                                                    currentIndex >=

+                                                    questionSet.length - 1

+                                                }

+                                            >

+                                                Dal´┐Ż´┐Ż

+                                            </button>

+                                        </div>

+

+                                        <div className="navigatorPlaceholder">

+                                            <Navigator

+                                                questionSet={questionSet}

+                                                currentIndex={currentIndex}

+                                                setCurrentIndex={moveToQuestion}

+                                                mode={mode}

+                                                maxSeenIndex={

+                                                    mode === "real_test"

+                                                        ? questionSet.length

+                                                        : maxSeenIndex

+                                                }

+                                            />

+

+                                            {mode === "mock" && (

+                                                <div

+                                                    style={{

+                                                        marginTop: "2rem",

+                                                        width: "100%",

+                                                        display: "flex",

+                                                        justifyContent:

+                                                            "center",

+                                                    }}

+                                                >

+                                                    <button

+                                                        className="navButton primary"

+                                                        style={{

+                                                            padding:

+                                                                "10px 30px",

+                                                            fontSize: "0.95rem",

+                                                            minWidth: "150px",

+                                                        }}

+                                                        onClick={() =>

+                                                            setShowConfirmSubmit(

+                                                                true,

+                                                            )

+                                                        }

+                                                    >

+                                                        Odevzdat test

+                                                    </button>

+                                                </div>

+                                            )}

+                                        </div>

+                                    </div>

+                                )}

+                            </div>

+                        </div>

+                    </>

+                )}

+

+                {questionSet.length > 3 && (

+                    <HiddenPreloader

+                        questionSet={questionSet}

+                        currentIndex={currentIndex}

+                        subject={subject}

+                        mode={mode}

+                    />

+                )}

+

+                <div className="footer"></div>

+            </div>

+        </>

+    );

+}

+

+

+

+

+

+

+

+

diff --git a/src/components/HistoryView.jsx b/src/components/HistoryView.jsx
index 8640ae0..60291e7 100644
--- a/src/components/HistoryView.jsx
+++ b/src/components/HistoryView.jsx
@@ -1,359 +1,358 @@
-import React, { useMemo, useState, useEffect } from 'react';
-import { HistoryGraph } from './HistoryGraph';
-import { UserBadgeDisplay } from './UserBadgeDisplay';
-
-const formatFullTime = (seconds) => {
-    if (!seconds) return "0m";
-    const h = Math.floor(seconds / 3600);
-    const m = Math.floor((seconds % 3600) / 60);
-
-    const parts = [];
-    if (h > 0) parts.push(`${h}h`);
-    if (m > 0 || h === 0) parts.push(`${m}m`);
-
-    return parts.join(' ');
-};
-
-const ITEMS_PER_PAGE = 10;
-const MAX_ITEMS = 20;
-
-export const HistoryView = ({ 
-    history = [], 
-    totalTimeMap = {}, 
-    totalQuestionsMap = {}, 
-    sessionTime = 0, 
-    sessionQuestionsCount = 0, 
-    onBack, 
-    onDeleteRecord,
-    user,
-    syncing,
-    currentSubject,
-    onRefreshRequest // Funkce pro refresh z App.js
-}) => {
-    const [currentPage, setCurrentPage] = useState(0);
-    const [localHistory, setLocalHistory] = useState(history);
-    const [isLoading, setIsLoading] = useState(false);
-
-    // Synchronizace props -> local state
-    useEffect(() => {
-        setLocalHistory(history);
-    }, [history]);
-
-    // Automaticky refresh p┼Öi otev┼Öen├ş (bez tla─Ź├ştka)
-    useEffect(() => {
-        const autoRefresh = async () => {
-            if (onRefreshRequest) {
-                setIsLoading(true);
-                try {
-                    await onRefreshRequest();
-                } catch (e) {
-                    console.error("Auto-refresh failed", e);
-                } finally {
-                    setIsLoading(false);
-                }
-            }
-        };
-        autoRefresh();
-    }, []);
-
-    const filteredHistory = useMemo(() => {
-        let data = [...localHistory];
-        if (currentSubject) {
-            data = data.filter(h => h.subject === currentSubject);
-        }
-        return data.sort((a, b) => new Date(b.date) - new Date(a.date));
-    }, [localHistory, currentSubject]);
-
-    const statsHistory = useMemo(() => {
-        return filteredHistory.slice(0, MAX_ITEMS);
-    }, [filteredHistory]);
-
-    const totalPages = Math.ceil(filteredHistory.length / ITEMS_PER_PAGE);
-    const paginatedHistory = filteredHistory.slice(
-        currentPage * ITEMS_PER_PAGE,
-        (currentPage + 1) * ITEMS_PER_PAGE
-    );
-
-    const totalTime = useMemo(() => {
-        let baseTime = 0;
-        if (currentSubject) {
-            baseTime = totalTimeMap[currentSubject] || 0;
-        } else {
-            baseTime = Object.values(totalTimeMap).reduce((acc, curr) => acc + curr, 0);
-        }
-        return baseTime + sessionTime;
-    }, [totalTimeMap, currentSubject, sessionTime]);
-
-    const totalQuestions = useMemo(() => {
-        let baseQuestions = 0;
-        if (currentSubject) {
-            baseQuestions = totalQuestionsMap[currentSubject] || 0;
-        } else {
-            baseQuestions = Object.values(totalQuestionsMap).reduce((acc, curr) => acc + curr, 0);
-        }
-        return baseQuestions + sessionQuestionsCount;
-    }, [totalQuestionsMap, currentSubject, sessionQuestionsCount]);
-
-    const detailedStats = useMemo(() => {
-        if (statsHistory.length === 0) {
-            return { count: 0, average: 0, best: 0 };
-        }
-
-        let totalPercent = 0;
-        let maxPercent = 0;
-
-        statsHistory.forEach(item => {
-            const total = item.score?.total || 1;
-            const correct = item.score?.correct || 0;
-            const percent = (correct / total) * 100;
-
-            totalPercent += percent;
-            if (percent > maxPercent) maxPercent = percent;
-        });
-
-        return {
-            count: filteredHistory.length,
-            average: Math.round(totalPercent / statsHistory.length),
-            best: Math.round(maxPercent)
-        };
-    }, [filteredHistory, statsHistory]);
-
-    const getModeIcon = (mode) => {
-        switch(mode) {
-            case 'mock': return 'ÔĆ▒´ŞĆ';
-            case 'smart': return '­čžá';
-            case 'random': return '­čâĆ';
-            case 'training': return '­čÄ»';
-            case 'mistakes': return '­čŤá´ŞĆ';
-            default: return '­čôŁ';
-        }
-    };
-
-    const getModeName = (mode) => {
-        switch(mode) {
-            case 'mock': return 'Test nane─Źisto';
-            case 'smart': return 'Chytr├ę u─Źen├ş';
-            case 'random': return 'Flashcards';
-            case 'training': return 'Tr├ęnink';
-            case 'mistakes': return 'Opravna chyb';
-            default: return mode;
-        }
-    };
-
-    const getScoreColor = (successRate) => {
-        if (successRate >= 84) return '#22c55e';
-        if (successRate >= 67) return '#84cc16';
-        if (successRate >= 50) return '#eab308';
-        if (successRate >= 33) return '#f97316';
-        return '#ef4444';
-    };
-
-    const getRelativeTime = (date) => {
-        const now = new Date();
-        const diff = now - date;
-        const minutes = Math.floor(diff / 60000);
-        const hours = Math.floor(diff / 3600000);
-        const days = Math.floor(diff / 86400000);
-
-        if (minutes < 1) return 'Pr├ív─Ť te─Ć';
-        if (minutes < 60) return `P┼Öed ${minutes} min`;
-        if (hours < 24) return `P┼Öed ${hours} hod`;
-        if (days < 7) return `P┼Öed ${days} dny`;
-        return date.toLocaleDateString('cs-CZ');
-    };
-
-    return (
-        <div className="container fadeIn" style={{ minHeight: "var(--vh)", paddingBottom: "2rem" }}>
-            <div className="top-navbar">
-                <div className="navbar-group">
-                    <button className="menuBackButton" onClick={onBack}>
-                        ÔćÉ <span className="mobile-hide-text">Zp─Ťt do menu</span>
-                    </button>
-                </div>
-                <div className="navbar-group">
-                    {/* Tla─Ź├ştko pro manu├íln├ş refresh odstran─Ťno */}
-                    {/* Indik├ítor sync/loading z┼»st├ív├í pro vizu├íln├ş kontrolu */}
-                    <UserBadgeDisplay user={user} syncing={syncing || isLoading} />
-                </div>
-            </div>
-
-            <div className="quizContentWrapper historyPage" style={{ maxWidth: '800px', margin: '0 auto', width: '100%' }}>
-                <h1 className="title historyTitle">
-                    Historie v├Żsledk┼» {currentSubject ? `(${currentSubject})` : ''}
-                </h1>
-
-                <div className="historyStatsGrid">
-                    <div className="historyStatCard">
-                        <div className="historyStatIcon">ÔĆ│</div>
-                        <div className="historyStatContent">
-                            <span className="historyStatValue" style={{ color: 'var(--color-primary-light)' }}>
-                                {formatFullTime(totalTime)}
-                            </span>
-                            <span className="historyStatLabel">Celkov├Ż ─Źas</span>
-                        </div>
-                    </div>
-
-                    <div className="historyStatCard">
-                        <div className="historyStatIcon">Ôťů</div>
-                        <div className="historyStatContent">
-                            <span className="historyStatValue" style={{ color: 'var(--color-success)' }}>
-                                {totalQuestions}
-                            </span>
-                            <span className="historyStatLabel">Ot├ízek</span>
-                        </div>
-                    </div>
-
-                    <div className="historyStatCard">
-                        <div className="historyStatIcon">­čôŁ</div>
-                        <div className="historyStatContent">
-                            <span className="historyStatValue">
-                                {detailedStats.count}
-                            </span>
-                            <span className="historyStatLabel">Test┼»</span>
-                        </div>
-                    </div>
-
-                    <div className="historyStatCard">
-                        <div className="historyStatIcon">­čôŐ</div>
-                        <div className="historyStatContent">
-                            <span
-                                className="historyStatValue"
-                                style={{
-                                    color: detailedStats.average >= 75
-                                        ? 'var(--color-success)'
-                                        : detailedStats.average >= 50
-                                            ? 'var(--color-warning)'
-                                            : 'var(--color-error)'
-                                }}
-                            >
-                                {detailedStats.average}%
-                            </span>
-                            <span className="historyStatLabel">Pr┼»m─Ťr</span>
-                        </div>
-                    </div>
-
-                    <div className="historyStatCard historyStatCardHighlight">
-                        <div className="historyStatIcon">­čĆć</div>
-                        <div className="historyStatContent">
-                            <span className="historyStatValue" style={{ color: '#fbbf24' }}>
-                                {detailedStats.best}%
-                            </span>
-                            <span className="historyStatLabel">Nejlep┼í├ş</span>
-                        </div>
-                    </div>
-                </div>
-
-                <div className="card historyChartCard">
-                    <h3 className="historyChartTitle">V├Żvoj ├║sp─Ť┼ínosti</h3>
-                    <div className="historyChartCanvas">
-                        <HistoryGraph data={statsHistory} />
-                    </div>
-                </div>
-
-                <div className="historyListHeader">
-                    <h3 className="historyListTitle">Historie aktivit</h3>
-                    {totalPages > 1 && (
-                        <span className="historyPageInfo">
-                            {currentPage * ITEMS_PER_PAGE + 1} ÔÇô {Math.min((currentPage + 1) * ITEMS_PER_PAGE, filteredHistory.length)} z {filteredHistory.length}
-                        </span>
-                    )}
-                </div>
-
-                {filteredHistory.length === 0 ? (
-                    <div className="historyEmpty">
-                        <div className="historyEmptyIcon">­čôş</div>
-                        <p>{currentSubject 
-                            ? `Zat├şm ┼ż├ídn├í historie pro ${currentSubject}.`
-                            : "Zat├şm ┼ż├ídn├í historie. Hur├í do u─Źen├ş!"}</p>
-                    </div>
-                ) : (
-                    <>
-                        <div className="historyList">
-                            {paginatedHistory.map((item, index) => {
-                                const date = new Date(item.date);
-                                const successRate = item.score?.total > 0 
-                                    ? Math.round((item.score.correct / item.score.total) * 100) 
-                                    : 0;
-                                const scoreColor = getScoreColor(successRate);
-
-                                return (
-                                    <div 
-                                        key={item.id} 
-                                        className="historyItem"
-                                        style={{ animationDelay: `${index * 0.03}s`, '--score-color': scoreColor }}
-                                    >
-                                        <div className="historyItemLeft">
-                                            <div className="historyItemIcon" style={{ 
-                                                background: `linear-gradient(135deg, ${scoreColor}20, ${scoreColor}10)`,
-                                                borderColor: `${scoreColor}40`
-                                            }}>
-                                                {getModeIcon(item.mode)}
-                                            </div>
-                                            <div className="historyItemInfo">
-                                                <div className="historyItemMode">
-                                                    {getModeName(item.mode)}
-                                                    {!currentSubject && item.subject && (
-                                                        <span className="historyItemSubject">{item.subject}</span>
-                                                    )}
-                                                </div>
-                                                <div className="historyItemDate">
-                                                    {getRelativeTime(date)}
-                                                </div>
-                                            </div>
-                                        </div>
-
-                                        <div className="historyItemRight">
-                                            <div className="historyItemScore">
-                                                <span className="historyItemPercent" style={{ color: scoreColor }}>
-                                                    {successRate}%
-                                                </span>
-                                                <span className="historyItemFraction">
-                                                    {item.score?.correct}/{item.score?.total}
-                                                </span>
-                                            </div>
-                                            <button 
-                                                className="historyDeleteBtn"
-                                                onClick={() => onDeleteRecord(item.id)}
-                                                title="Smazat z├íznam"
-                                            >
-                                                ­čŚĹ´ŞĆ
-                                            </button>
-                                        </div>
-                                    </div>
-                                );
-                            })}
-                        </div>
-
-                        {totalPages > 1 && (
-                            <div className="historyPagination">
-                                <button 
-                                    className="historyPaginationBtn"
-                                    onClick={() => setCurrentPage(p => p - 1)}
-                                    disabled={currentPage === 0}
-                                >
-                                    ÔćÉ Nov─Ťj┼í├ş
-                                </button>
-                                <div className="historyPaginationDots">
-                                    {Array.from({ length: totalPages }, (_, i) => (
-                                        <button
-                                            key={i}
-                                            className={`historyPaginationDot ${currentPage === i ? 'active' : ''}`}
-                                            onClick={() => setCurrentPage(i)}
-                                        />
-                                    ))}
-                                </div>
-                                <button 
-                                    className="historyPaginationBtn"
-                                    onClick={() => setCurrentPage(p => p + 1)}
-                                    disabled={currentPage === totalPages - 1}
-                                >
-                                    Star┼í├ş Ôćĺ
-                                </button>
-                            </div>
-                        )}
-                    </>
-                )}
-            </div>
-        </div>
-    );
-};
+import React, { useMemo, useState, useEffect } from 'react';

+import { HistoryGraph } from './HistoryGraph';

+import { UserBadgeDisplay } from './UserBadgeDisplay';

+import { SubjectBadge } from './SubjectBadge';

+

+const formatFullTime = (seconds) => {

+    if (!seconds) return "0m";

+    const h = Math.floor(seconds / 3600);

+    const m = Math.floor((seconds % 3600) / 60);

+

+    const parts = [];

+    if (h > 0) parts.push(`${h}h`);

+    if (m > 0 || h === 0) parts.push(`${m}m`);

+

+    return parts.join(' ');

+};

+

+const ITEMS_PER_PAGE = 10;

+const MAX_ITEMS = 20;

+

+export const HistoryView = ({ 

+    history = [], 

+    totalTimeMap = {}, 

+    totalQuestionsMap = {}, 

+    sessionTime = 0, 

+    sessionQuestionsCount = 0, 

+    onBack, 

+    onDeleteRecord,

+    user,

+    syncing,

+    currentSubject,

+    onRefreshRequest // Funkce pro refresh z App.js

+}) => {

+    const [currentPage, setCurrentPage] = useState(0);

+    const [localHistory, setLocalHistory] = useState(history);

+    const [isLoading, setIsLoading] = useState(false);

+

+    // Synchronizace props -> local state

+    useEffect(() => {

+        setLocalHistory(history);

+    }, [history]);

+

+    // Automaticky refresh p´┐Żi otev´┐Żen´┐Ż (bez tla´┐Ż´┐Żtka)

+    useEffect(() => {

+        const autoRefresh = async () => {

+            if (onRefreshRequest) {

+                setIsLoading(true);

+                try {

+                    await onRefreshRequest();

+                } catch (e) {

+                    console.error("Auto-refresh failed", e);

+                } finally {

+                    setIsLoading(false);

+                }

+            }

+        };

+        autoRefresh();

+    }, []);

+

+    const filteredHistory = useMemo(() => {

+        let data = [...localHistory];

+        if (currentSubject) {

+            data = data.filter(h => h.subject === currentSubject);

+        }

+        return data.sort((a, b) => new Date(b.date) - new Date(a.date));

+    }, [localHistory, currentSubject]);

+

+    const statsHistory = useMemo(() => {

+        return filteredHistory.slice(0, MAX_ITEMS);

+    }, [filteredHistory]);

+

+    const totalPages = Math.ceil(filteredHistory.length / ITEMS_PER_PAGE);

+    const paginatedHistory = filteredHistory.slice(

+        currentPage * ITEMS_PER_PAGE,

+        (currentPage + 1) * ITEMS_PER_PAGE

+    );

+

+    const totalTime = useMemo(() => {

+        let baseTime = 0;

+        if (currentSubject) {

+            baseTime = totalTimeMap[currentSubject] || 0;

+        } else {

+            baseTime = Object.values(totalTimeMap).reduce((acc, curr) => acc + curr, 0);

+        }

+        return baseTime + sessionTime;

+    }, [totalTimeMap, currentSubject, sessionTime]);

+

+    const totalQuestions = useMemo(() => {

+        let baseQuestions = 0;

+        if (currentSubject) {

+            baseQuestions = totalQuestionsMap[currentSubject] || 0;

+        } else {

+            baseQuestions = Object.values(totalQuestionsMap).reduce((acc, curr) => acc + curr, 0);

+        }

+        return baseQuestions + sessionQuestionsCount;

+    }, [totalQuestionsMap, currentSubject, sessionQuestionsCount]);

+

+    const detailedStats = useMemo(() => {

+        if (statsHistory.length === 0) {

+            return { count: 0, average: 0, best: 0 };

+        }

+

+        let totalPercent = 0;

+        let maxPercent = 0;

+

+        statsHistory.forEach(item => {

+            const total = item.score?.total || 1;

+            const correct = item.score?.correct || 0;

+            const percent = (correct / total) * 100;

+

+            totalPercent += percent;

+            if (percent > maxPercent) maxPercent = percent;

+        });

+

+        return {

+            count: filteredHistory.length,

+            average: Math.round(totalPercent / statsHistory.length),

+            best: Math.round(maxPercent)

+        };

+    }, [filteredHistory, statsHistory]);

+

+    const getModeIcon = (mode) => {

+        switch(mode) {

+            case 'mock': return '??';

+            case 'smart': return '??';

+            case 'random': return '??';

+            case 'training': return '??';

+            case 'mistakes': return '???';

+            default: return '??';

+        }

+    };

+

+    const getModeName = (mode) => {

+        switch(mode) {

+            case 'mock': return 'Test naneuisto';

+            case 'smart': return 'Chytrh uren'';

+            case 'random': return 'Flashcards';

+            case 'training': return 'Trrnink';

+            case 'mistakes': return 'Opravna chyb';

+            default: return mode;

+        }

+    };

+

+    const getScoreColor = (successRate) => {

+        if (successRate >= 84) return '#22c55e';

+        if (successRate >= 67) return '#84cc16';

+        if (successRate >= 50) return '#eab308';

+        if (successRate >= 33) return '#f97316';

+        return '#ef4444';

+    };

+

+    const getRelativeTime = (date) => {

+        const now = new Date();

+        const diff = now - date;

+        const minutes = Math.floor(diff / 60000);

+        const hours = Math.floor(diff / 3600000);

+        const days = Math.floor(diff / 86400000);

+

+        if (minutes < 1) return 'PrÔö╝ve te{';

+        if (minutes < 60) return `Peed ${minutes} min`;

+        if (hours < 24) return `Peed ${hours} hod`;

+        if (days < 7) return `Peed ${days} dny`;

+        return date.toLocaleDateString('cs-CZ');

+    };

+

+    return (

+        <div className="container fadeIn" style={{ minHeight: "var(--vh)", paddingBottom: "2rem" }}>

+            <div className="top-navbar">

+                <div className="navbar-group">

+                    <button className="menuBackButton" onClick={onBack}>

+                        t <span className="mobile-hide-text">Zp´┐Żt do menu</span>

+                    </button>

+                    <SubjectBadge subject={currentSubject ? currentSubject.toUpperCase() : currentSubject} compact />
+                </div>

+                <div className="navbar-group">

+                    {/* Tladgtko pro manurlnu refresh odstrannno */}

+                    {/* Indik´┐Żtor sync/loading z´┐Żst´┐Żv´┐Ż pro vizu´┐Żln´┐Ż kontrolu */}

+                    <UserBadgeDisplay user={user} syncing={syncing || isLoading} />

+                </div>

+            </div>

+

+            <div className="quizContentWrapper historyPage" style={{ maxWidth: '800px', margin: '0 auto', width: '100%' }}>

+

+                <div className="historyStatsGrid">

+                    <div className="historyStatCard">

+                        <div className="historyStatIcon">?</div>

+                        <div className="historyStatContent">

+                            <span className="historyStatValue" style={{ color: 'var(--color-primary-light)' }}>

+                                {formatFullTime(totalTime)}

+                            </span>

+                            <span className="historyStatLabel">Celkov´┐Ż ´┐Żas</span>

+                        </div>

+                    </div>

+

+                    <div className="historyStatCard">

+                        <div className="historyStatIcon">?</div>

+                        <div className="historyStatContent">

+                            <span className="historyStatValue" style={{ color: 'var(--color-success)' }}>

+                                {totalQuestions}

+                            </span>

+                            <span className="historyStatLabel">Ot´┐Żzek</span>

+                        </div>

+                    </div>

+

+                    <div className="historyStatCard">

+                        <div className="historyStatIcon">??</div>

+                        <div className="historyStatContent">

+                            <span className="historyStatValue">

+                                {detailedStats.count}

+                            </span>

+                            <span className="historyStatLabel">Test´┐Ż</span>

+                        </div>

+                    </div>

+

+                    <div className="historyStatCard">

+                        <div className="historyStatIcon">??</div>

+                        <div className="historyStatContent">

+                            <span

+                                className="historyStatValue"

+                                style={{

+                                    color: detailedStats.average >= 75

+                                        ? 'var(--color-success)'

+                                        : detailedStats.average >= 50

+                                            ? 'var(--color-warning)'

+                                            : 'var(--color-error)'

+                                }}

+                            >

+                                {detailedStats.average}%

+                            </span>

+                            <span className="historyStatLabel">Pr´┐Żm´┐Żr</span>

+                        </div>

+                    </div>

+

+                    <div className="historyStatCard historyStatCardHighlight">

+                        <div className="historyStatIcon">??</div>

+                        <div className="historyStatContent">

+                            <span className="historyStatValue" style={{ color: '#fbbf24' }}>

+                                {detailedStats.best}%

+                            </span>

+                            <span className="historyStatLabel">Nejlep´┐Ż´┐Ż</span>

+                        </div>

+                    </div>

+                </div>

+

+                <div className="card historyChartCard">

+                    <h3 className="historyChartTitle">V´┐Żvoj ´┐Żsp´┐Żnosti</h3>

+                    <div className="historyChartCanvas">

+                        <HistoryGraph data={statsHistory} />

+                    </div>

+                </div>

+

+                <div className="historyListHeader">

+                    <h3 className="historyListTitle">Historie aktivit</h3>

+                    {totalPages > 1 && (

+                        <span className="historyPageInfo">

+                            {currentPage * ITEMS_PER_PAGE + 1} ´┐Ż {Math.min((currentPage + 1) * ITEMS_PER_PAGE, filteredHistory.length)} z {filteredHistory.length}

+                        </span>

+                    )}

+                </div>

+

+                {filteredHistory.length === 0 ? (

+                    <div className="historyEmpty">

+                        <div className="historyEmptyIcon">??</div>

+                        <p>{currentSubject 

+                            ? `Zattm bjdnt historie pro ${currentSubject}.`

+                            : "ZatÔöťm  Ôö╝dn├ş historie. Hurp do ucenr!"}</p>

+                    </div>

+                ) : (

+                    <>

+                        <div className="historyList">

+                            {paginatedHistory.map((item, index) => {

+                                const date = new Date(item.date);

+                                const successRate = item.score?.total > 0 

+                                    ? Math.round((item.score.correct / item.score.total) * 100) 

+                                    : 0;

+                                const scoreColor = getScoreColor(successRate);

+

+                                return (

+                                    <div 

+                                        key={item.id} 

+                                        className="historyItem"

+                                        style={{ animationDelay: `${index * 0.03}s`, '--score-color': scoreColor }}

+                                    >

+                                        <div className="historyItemLeft">

+                                            <div className="historyItemIcon" style={{ 

+                                                background: `linear-gradient(135deg, ${scoreColor}20, ${scoreColor}10)`,

+                                                borderColor: `${scoreColor}40`

+                                            }}>

+                                                {getModeIcon(item.mode)}

+                                            </div>

+                                            <div className="historyItemInfo">

+                                                <div className="historyItemMode">

+                                                    {getModeName(item.mode)}

+                                                    {!currentSubject && item.subject && (

+                                                        <span className="historyItemSubject">{item.subject}</span>

+                                                    )}

+                                                </div>

+                                                <div className="historyItemDate">

+                                                    {getRelativeTime(date)}

+                                                </div>

+                                            </div>

+                                        </div>

+

+                                        <div className="historyItemRight">

+                                            <div className="historyItemScore">

+                                                <span className="historyItemPercent" style={{ color: scoreColor }}>

+                                                    {successRate}%

+                                                </span>

+                                                <span className="historyItemFraction">

+                                                    {item.score?.correct}/{item.score?.total}

+                                                </span>

+                                            </div>

+                                            <button 

+                                                className="historyDeleteBtn"

+                                                onClick={() => onDeleteRecord(item.id)}

+                                                title="Smazat zoznam"

+                                            >

+                                                ???

+                                            </button>

+                                        </div>

+                                    </div>

+                                );

+                            })}

+                        </div>

+

+                        {totalPages > 1 && (

+                            <div className="historyPagination">

+                                <button 

+                                    className="historyPaginationBtn"

+                                    onClick={() => setCurrentPage(p => p - 1)}

+                                    disabled={currentPage === 0}

+                                >

+                                    ´┐Ż Nov´┐Żj´┐Ż´┐Ż

+                                </button>

+                                <div className="historyPaginationDots">

+                                    {Array.from({ length: totalPages }, (_, i) => (

+                                        <button

+                                            key={i}

+                                            className={`historyPaginationDot ${currentPage === i ? 'active' : ''}`}

+                                            onClick={() => setCurrentPage(i)}

+                                        />

+                                    ))}

+                                </div>

+                                <button 

+                                    className="historyPaginationBtn"

+                                    onClick={() => setCurrentPage(p => p + 1)}

+                                    disabled={currentPage === totalPages - 1}

+                                >

+                                    Star´┐Ż´┐Ż ´┐Ż

+                                </button>

+                            </div>

+                        )}

+                    </>

+                )}

+            </div>

+        </div>

+    );

+};

diff --git a/src/components/RealTestMode.jsx b/src/components/RealTestMode.jsx
index 1f225b8..6a75310 100644
--- a/src/components/RealTestMode.jsx
+++ b/src/components/RealTestMode.jsx
@@ -23,18 +23,18 @@ export function RealTestMode({
     onReport,
     onTestCompleted,
 }) {
-    // ID ┼Ö├ídku v datab├ízi
+    // ID Ôö╝├ľdku v databazi
     const [resultRowId, setResultRowId] = useState(null);
     const sessionStartedRef = useRef(false);
 
-    // --- V├ŁPO─îET Z├üKLADN├ŹHO LIMITU ---
+    // --- VÔöťPOOET Z KLADNAHO LIMITU ---
     const getNominalDuration = () => test.time_limit * 60;
 
     const [questionSet, setQuestionSet] = useState(initialQuestions);
     const [currentIndex, setCurrentIndex] = useState(0);
     const [readyQuestionId, setReadyQuestionId] = useState(null);
 
-    // Defaultn─Ť nastav├şme pln├Ż ─Źas, ale useEffect n├ş┼że ho m┼»┼że zkr├ítit pokud jde o resume
+    // DefaultnÔöÇ nastavvme plnl Ôöťas, ale useEffect nce ho m┼╝ee zkrÔö╝tit pokud jde o resume
     const [timeLeft, setTimeLeft] = useState(getNominalDuration());
 
     const [showConfirmSubmit, setShowConfirmSubmit] = useState(false);
@@ -60,8 +60,8 @@ export function RealTestMode({
             sessionStartedRef.current = true;
 
             try {
-                // Hled├íme existuj├şc├ş 'running' session
-                // D┼«LE┼ŻIT├ë: Na─Ź├şt├íme i sloupec 'answers', abychom je mohli obnovit
+                // HledÔöťme existujjc┼č 'running' session
+                // DÔö╝LEEITI: Na NtÔöÇme i sloupec 'answers', abychom je mohli obnovit
                 const { data: existingData } = await supabase
                     .from("test_results")
                     .select("id, created_at, answers")
@@ -72,20 +72,20 @@ export function RealTestMode({
 
                 if (existingData) {
                     console.log(
-                        "­čöä N├ívrat do rozpracovan├ęho testu:",
+                        "?? N vrat do rozpracovanvho testu:",
                         existingData.id,
                     );
                     setResultRowId(existingData.id);
 
-                    // --- A) OBNOVEN├Ź ODPOV─ÜD├Ź ---
+                    // --- A) OBNOVENÔöť ODPOVVD├ť ---
                     if (
                         existingData.answers &&
                         Array.isArray(existingData.answers)
                     ) {
                         setQuestionSet((prevSet) => {
                             return prevSet.map((q) => {
-                                // Najdeme, zda pro tuto ot├ízku existuje ulo┼żen├í odpov─Ť─Ć
-                                // Hled├íme podle ─Ź├şsla ot├ízky (qNum)
+                                // Najdeme, zda pro tuto otÔöťzku existuje ulooene odpovpo
+                                // HledÔöťme podle  ÔöÇsla ot zky (qNum)
                                 const savedAnswer = existingData.answers.find(
                                     (a) => a.qNum === q.number,
                                 );
@@ -100,7 +100,7 @@ export function RealTestMode({
                         });
                     }
 
-                    // --- B) SYNCHRONIZACE ─îASU ---
+                    // --- B) SYNCHRONIZACE ÔöÇASU ---
                     const dbStartTime = new Date(
                         existingData.created_at,
                     ).getTime();
@@ -125,8 +125,8 @@ export function RealTestMode({
                     remaining = Math.max(0, remaining);
                     setTimeLeft(remaining);
                 } else {
-                    // Nov├Ż test
-                    console.log("­čćĽ Zakl├íd├ím nov├Ż test...");
+                    // NovÔöť test
+                    console.log("?? ZaklkdÔöťm nov  test...");
                     const { data, error } = await supabase
                         .from("test_results")
                         .insert([
@@ -164,14 +164,14 @@ export function RealTestMode({
                     }
                 }
             } catch (err) {
-                console.error("Chyba p┼Öi startu session:", err);
+                console.error("Chyba pÔö╝i startu session:", err);
             }
         };
 
         startSession();
     }, []);
 
-    // Udr┼żov├ín├ş referenc├ş
+    // UdrÔö╝ovvn├ş reference
     useEffect(() => {
         questionSetRef.current = questionSet;
     }, [questionSet]);
@@ -213,11 +213,11 @@ export function RealTestMode({
         };
     }, [currentIndex, questionSet.length]);
 
-    // --- FUNKCE PRO PR┼«B─Ü┼ŻN├ë UKL├üD├üN├Ź (PROGRESS SAVING) ---
+    // --- FUNKCE PRO PRÔö╝B╠ÄN├ť UKL├źDUNL (PROGRESS SAVING) ---
     const saveProgressToDb = async (updatedQuestionSet) => {
         if (!resultRowId) return;
 
-        // Vytvo┼Ö├şme pole odpov─Ťd├ş ve form├ítu pro DB
+        // VytvoÔö╝├ľme pole odpovodÔöÇ ve formftu pro DB
         const answersToSave = updatedQuestionSet.map((q) => ({
             qNum: q.number,
             user: q.userAnswer,
@@ -225,14 +225,14 @@ export function RealTestMode({
         }));
 
         try {
-            // Updating pouze 'answers', status nech├ív├íme 'running'
+            // Updating pouze 'answers', status nechÔöťvvme 'running'
             await supabase
                 .from("test_results")
                 .update({ answers: answersToSave })
                 .eq("id", resultRowId);
         } catch (err) {
-            console.error("Chyba p┼Öi pr┼»b─Ť┼żn├ęm ukl├íd├ín├ş:", err);
-            // Zde ned├ív├íme alert, a┼ą to u┼żivatele neru┼í├ş p┼Öi ka┼żd├ęm kliknut├ş
+            console.error("Chyba pÔö╝i prrb┬╗nÔöÇm ukl─Öd nk:", err);
+            // Zde nedÔöťvvme alert, a  to uoivatele nerune pÔö╝i kapd├ľm kliknutm
         }
     };
 
@@ -271,7 +271,7 @@ export function RealTestMode({
                     .insert([payload]);
                 error = iErr;
             }
-            if (error) alert("Chyba p┼Öi ukl├íd├ín├ş: " + error.message);
+            if (error) alert("Chyba pÔö╝i uklld├şnÔöť: " + error.message);
         } catch (err) {
             console.error(err);
         }
@@ -373,11 +373,11 @@ export function RealTestMode({
         };
     }, [finalResult, test.time_limit, test.close_at]);
 
-    // --- KLIKNUT├Ź NA ODPOV─Ü─Ä + PR┼«B─Ü┼ŻN├ë ULO┼ŻEN├Ź ---
+    // --- KLIKNUTÔöť NA ODPOVVÔöÇ + PR B╠ÄN┬ź ULO┼╗EN├ź ---
     const handleAnswer = (answerIndex) => {
         if (finalResult) return;
 
-        // 1. Aktualizace lok├íln├şho stavu
+        // 1. Aktualizace lokÔöťlnnho stavu
         setQuestionSet((prev) => {
             const newSet = [...prev];
             newSet[currentIndex] = {
@@ -385,7 +385,7 @@ export function RealTestMode({
                 userAnswer: answerIndex,
             };
 
-            // 2. Pr┼»b─Ť┼żn├ę ulo┼żen├ş do DB (fire and forget - ne─Źek├íme na await)
+            // 2. PrÔö╝bbn┼Ą ulo─Öenl do DB (fire and forget - neeek-me na await)
             saveProgressToDb(newSet);
 
             return newSet;
@@ -529,7 +529,7 @@ export function RealTestMode({
                                 fontSize: "0.9rem",
                             }}
                         >
-                            ­čôŁ TEST PROB├ŹH├ü
+                            ?? TEST PROBOHÔöť
                         </span>
                         <div className="mobile-hidden">
                             <SubjectBadge subject={test.subject} compact />
@@ -562,7 +562,7 @@ export function RealTestMode({
                         ></div>
                     </div>
                     <div className="progressText">
-                        Ot├ízka {currentIndex + 1} / {questionSet.length}
+                        OtÔöťzka {currentIndex + 1} / {questionSet.length}
                     </div>
                     <div className="card" ref={cardRef}>
                         <div
@@ -610,7 +610,7 @@ export function RealTestMode({
                                     currentIndex === 0 || finalResult !== null
                                 }
                             >
-                                P┼Öedchoz├ş
+                                PÔö╝edchozz
                             </button>
                             {currentIndex < questionSet.length - 1 ? (
                                 <button
@@ -620,7 +620,7 @@ export function RealTestMode({
                                     }
                                     disabled={finalResult !== null}
                                 >
-                                    Dal┼í├ş
+                                    DalÔö╝├ş
                                 </button>
                             ) : (
                                 <button
@@ -631,7 +631,7 @@ export function RealTestMode({
                                     }}
                                     disabled={true}
                                 >
-                                    Dal┼í├ş
+                                    DalÔö╝├ş
                                 </button>
                             )}
                         </div>
@@ -682,11 +682,11 @@ export function RealTestMode({
             />
             {showAutoSubmitModal && (
                 <ConfirmModal
-                    title="─îas vypr┼íel"
-                    message="─îasov├Ż limit pro tento test vypr┼íel. Va┼íe odpov─Ťdi byly automaticky ulo┼żeny."
+                    title="ÔöÇas vyprrel"
+                    message="ÔöÇasovv limit pro tento test vyprpel. Va e odpovddi byly automaticky uloyeny."
                     onCancel={() => setShowAutoSubmitModal(false)}
                     onConfirm={() => setShowAutoSubmitModal(false)}
-                    confirmText="Zobrazit v├Żsledky"
+                    confirmText="Zobrazit vÔöťsledky"
                     danger={false}
                     hideButtons={true}
                 />
@@ -694,7 +694,7 @@ export function RealTestMode({
             {showConfirmSubmit && (
                 <ConfirmModal
                     title="Odevzdat test?"
-                    message="Opravdu chcete test ukon─Źit a odevzdat? Tuto akci nelze vr├ítit."
+                    message="Opravdu chcete test ukonÔöÇit a odevzdat? Tuto akci nelze vrrtit."
                     onCancel={() => setShowConfirmSubmit(false)}
                     onConfirm={() => submitTest()}
                     confirmText="ODEVZDAT"
diff --git a/src/components/ScheduledTestsList.jsx b/src/components/ScheduledTestsList.jsx
index 4c3edfa..e079b86 100644
--- a/src/components/ScheduledTestsList.jsx
+++ b/src/components/ScheduledTestsList.jsx
@@ -4,7 +4,7 @@ import { SubjectBadge } from "./SubjectBadge";
 import { UserBadgeDisplay } from "./UserBadgeDisplay";
 import { ThemeToggle } from "./ThemeToggle";
 
-// --- POMOCN├ü KOMPONENTA PRO ODPO─îET ---
+// --- POMOCNÔöť KOMPONENTA PRO ODPOOET ---
 function CountdownTimer({ targetDate, onTimerEnd }) {
     const [timeLeft, setTimeLeft] = useState("");
 
@@ -15,7 +15,7 @@ function CountdownTimer({ targetDate, onTimerEnd }) {
 
             if (difference <= 0) {
                 clearInterval(interval);
-                setTimeLeft("te─Ć");
+                setTimeLeft("teÔöÇ");
                 if (onTimerEnd) onTimerEnd();
             } else {
                 const days = Math.floor(difference / (1000 * 60 * 60 * 24));
@@ -27,13 +27,13 @@ function CountdownTimer({ targetDate, onTimerEnd }) {
                     setTimeLeft(`za ${days}d ${hours}h`);
                 } else {
                     const pad = (n) => n.toString().padStart(2, "0");
-                    // UPRAVEN├ü LOGIKA FORM├üTOV├üN├Ź
+                    // UPRAVENÔöť LOGIKA FORMMTOVONÔöť
                     if (hours > 0) {
                         setTimeLeft(
                             `za ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`,
                         );
                     } else {
-                        // Pokud je 0 hodin, uk├í┼żeme jen MM:SS
+                        // Pokud je 0 hodin, ukÔöťeme jen MM:SS
                         setTimeLeft(
                             `za ${pad(minutes)}:${pad(seconds)}`,
                         );
@@ -48,7 +48,7 @@ function CountdownTimer({ targetDate, onTimerEnd }) {
     return <span>{timeLeft}</span>;
 }
 
-// --- HLAVN├Ź KOMPONENTA ---
+// --- HLAVNÔöť KOMPONENTA ---
 export function ScheduledTestsList({
     scheduledTests,
     onBack,
@@ -66,13 +66,13 @@ export function ScheduledTestsList({
 }) {
     const [userResults, setUserResults] = useState([]);
 
-    // --- 1. NA─îTEN├Ź STAV┼« TEST┼« ---
+    // --- 1. NAÔöÇTENN STAVA TESTE ---
     useEffect(() => {
         if (!userId) return;
 
         const fetchUserResults = async () => {
             console.log(
-                "­čöŹ [ScheduledTestsList] Hled├ím v├Żsledky pro UserID:",
+                "?? [ScheduledTestsList] Hledem vmsledky pro UserID:",
                 userId,
             );
 
@@ -85,10 +85,10 @@ export function ScheduledTestsList({
                 .order("created_at", { ascending: false });
 
             if (data) {
-                console.log("­čôŽ [ScheduledTestsList] Sta┼żen├í data z DB:", data);
+                console.log("?? [ScheduledTestsList] Staten┼╝ data z DB:", data);
                 setUserResults(data);
             }
-            if (error) console.error("ÔŁî Chyba DB:", error);
+            if (error) console.error("? Chyba DB:", error);
         };
 
         fetchUserResults();
@@ -105,7 +105,7 @@ export function ScheduledTestsList({
                     filter: `user_id=eq.${userId}`,
                 },
                 (payload) => {
-                    console.log("ÔÜí Zm─Ťna v DB, aktualizuji...", payload);
+                    console.log("? ZmZna v DB, aktualizuji...", payload);
                     fetchUserResults();
                 },
             )
@@ -114,7 +114,7 @@ export function ScheduledTestsList({
         return () => supabase.removeChannel(sub);
     }, [userId]);
 
-    // --- SE┼śAZEN├Ź: Nehotov├ę naho┼Öe, hotov├ę dole ---
+    // --- SEÔö╝AZENN: Nehotovo nahoae, hotovo dole ---
     const sortedTests = [...scheduledTests].sort((a, b) => {
         const getTestStatus = (testId) => {
             const currentTestIdStr = String(testId);
@@ -170,9 +170,9 @@ export function ScheduledTestsList({
                                 marginRight: "0.2rem",
                             }}
                         >
-                            ÔćÉ
+                            ├ö
                         </span>
-                        <span className="mobile-hide-text">Zp─Ťt</span>
+                        <span className="mobile-hide-text">ZpÔöÇt</span>
                     </button>
                     <div className="mobile-hidden">
                         <SubjectBadge subject={subject} compact />
@@ -197,7 +197,7 @@ export function ScheduledTestsList({
                             transition: "all 0.2s",
                         }}
                     >
-                        ­čöä
+                        ??
                     </button>
                     <UserBadgeDisplay
                         user={user}
@@ -208,18 +208,6 @@ export function ScheduledTestsList({
             </div>
 
             <div className="quizContentWrapper">
-                <div style={{ textAlign: "center", marginBottom: "2.5rem" }}>
-                    <h1 className="title" style={{ marginBottom: "0.5rem" }}>
-                        Napl├ínovan├ę testy
-                    </h1>
-                    <p
-                        className="subtitle"
-                        style={{ maxWidth: "600px", margin: "0 auto" }}
-                    >
-                        Zde najde┼í p┼Öehled v┼íech p├şsemek vypsan├Żch u─Źitelem.
-                    </p>
-                </div>
-
                 {sortedTests.length === 0 ? (
                     <div
                         style={{
@@ -243,7 +231,7 @@ export function ScheduledTestsList({
                                 opacity: 0.8,
                             }}
                         >
-                            ­čôş
+                            ??
                         </div>
                         <div
                             style={{
@@ -253,7 +241,7 @@ export function ScheduledTestsList({
                                 color: "var(--color-text-main)",
                             }}
                         >
-                            Zat├şm ┼ż├ídn├ę testy
+                            Zat´┐Żm ´┐Ż´┐Żdn´┐Ż testy
                         </div>
                     </div>
                 ) : (
@@ -278,7 +266,7 @@ export function ScheduledTestsList({
                                 hasDates && now > new Date(test.close_at);
 
                             // =========================================================
-                            // ­čŤĹ DEBUG LOGIKA STAVU
+                            // ?? DEBUG LOGIKA STAVU
                             // =========================================================
                             const currentTestIdStr = String(test.id);
                             const myAllResults = userResults.filter(
@@ -299,7 +287,7 @@ export function ScheduledTestsList({
                                     completedTestIds.includes(test.id);
                             }
 
-                            // Statistiky procvi─Źov├ín├ş
+                            // Statistiky procvipov=nm
                             const stats = testPracticeStats[test.id] || [];
                             let successRate = null;
                             if (stats.length > 0) {
@@ -329,8 +317,8 @@ export function ScheduledTestsList({
                                 color: "#94a3b8",
                                 bg: "rgba(148, 163, 184, 0.15)",
                                 border: "rgba(148, 163, 184, 0.3)",
-                                icon: "­čöĺ",
-                                text: "Uzav┼Öeno",
+                                icon: "??",
+                                text: "Uzavpeno",
                             };
 
                             if (isRunning) {
@@ -339,8 +327,8 @@ export function ScheduledTestsList({
                                     color: "#3b82f6",
                                     bg: "rgba(59, 130, 246, 0.15)",
                                     border: "rgba(59, 130, 246, 0.3)",
-                                    icon: "ÔťŹ´ŞĆ",
-                                    text: "Rozpracov├íno",
+                                    icon: "??",
+                                    text: "Rozpracov6no",
                                 };
                             } else if (isCompleted) {
                                 // PRIORITA 2
@@ -348,19 +336,19 @@ export function ScheduledTestsList({
                                     color: "#22c55e",
                                     bg: "rgba(34, 197, 94, 0.15)",
                                     border: "rgba(34, 197, 94, 0.3)",
-                                    icon: "Ôťů",
-                                    text: `Dokon─Źeno${badgeScoreText}`,
+                                    icon: "?",
+                                    text: `Dokon,eno${badgeScoreText}`,
                                 };
                             } else if (isOpen) {
-                                // PRIORITA 3 - TEST JE OTEV┼śEN├Ł
+                                // PRIORITA 3 - TEST JE OTEV´┐ŻEN´┐Ż
                                 statusConfig = {
                                     color: "#3b82f6",
                                     bg: "rgba(59, 130, 246, 0.15)",
                                     border: "rgba(59, 130, 246, 0.3)",
-                                    icon: "­čÜÇ",
+                                    icon: "??",
                                     text: (
                                         <span style={{ display: 'flex', gap: '0.3rem', alignItems: 'center' }}>
-                                            <span>Kon─Ź├ş</span>
+                                            <span>Kon´┐Ż´┐Ż</span>
                                             <CountdownTimer
                                                 targetDate={test.close_at}
                                                 onTimerEnd={onRefresh}
@@ -369,12 +357,12 @@ export function ScheduledTestsList({
                                     ),
                                 };
                             } else if (isUpcoming) {
-                                // PRIORITA 4 - TEST SE TEPRVE OTEV┼śE
+                                // PRIORITA 4 - TEST SE TEPRVE OTEV´┐ŻE
                                 statusConfig = {
                                     color: "#f59e0b",
                                     bg: "rgba(245, 158, 11, 0.15)",
                                     border: "rgba(245, 158, 11, 0.3)",
-                                    icon: "ÔĆ│",
+                                    icon: "?",
                                     text: (
                                         <CountdownTimer
                                             targetDate={test.open_at}
@@ -455,15 +443,15 @@ export function ScheduledTestsList({
                                                     fontWeight: "500",
                                                 }}
                                             >
-                                                <span title="Po─Źet ot├ízek">
-                                                    ÔŁô {test.question_count}
-                                                    &nbsp;ot├ízek
+                                                <span title="Po´┐Żet ot´┐Żzek">
+                                                    ? {test.question_count}
+                                                    &nbsp;ot´┐Żzek
                                                 </span>
                                                 <span style={{ opacity: 0.3 }}>
                                                     |
                                                 </span>
-                                                <span title="─îasov├Ż limit">
-                                                    ÔĆ▒´ŞĆ {test.time_limit}
+                                                <span title="aasovc limit">
+                                                    ?? {test.time_limit}
                                                     &nbsp;min
                                                 </span>
                                             </div>
@@ -531,7 +519,7 @@ export function ScheduledTestsList({
                                                                 "0.3rem",
                                                         }}
                                                     >
-                                                        Otev┼Öen├ş
+                                                        Otev´┐Żen´┐Ż
                                                     </div>
                                                     <div
                                                         style={{
@@ -577,7 +565,7 @@ export function ScheduledTestsList({
                                                                 "0.3rem",
                                                         }}
                                                     >
-                                                        Uzav┼Öen├ş
+                                                        Uzav´┐Żen´┐Ż
                                                     </div>
                                                     <div
                                                         style={{
@@ -617,8 +605,8 @@ export function ScheduledTestsList({
                                                     color: "var(--color-text-secondary)",
                                                 }}
                                             >
-                                                Term├şn testu bude up┼Öesn─Ťn
-                                                u─Źitelem.
+                                                Term´┐Żn testu bude up´┐Żesn´┐Żn
+                                                utitelem.
                                             </div>
                                         )}
 
@@ -640,8 +628,8 @@ export function ScheduledTestsList({
                                                     color: "var(--color-text-secondary)",
                                                 }}
                                             >
-                                                ­čÄ» Tvoje ├║sp─Ť┼ínost v
-                                                procvi─Źov├ín├ş:
+                                                ?? Tvoje "sp8nost v
+                                                procviRovins:
                                             </span>
                                             {successRate !== null ? (
                                                 <span
@@ -667,7 +655,7 @@ export function ScheduledTestsList({
                                                         fontStyle: "italic",
                                                     }}
                                                 >
-                                                    Zat├şm neprocvi─Źov├íno
+                                                    Zat´┐Żm neprocvi´┐Żov´┐Żno
                                                 </span>
                                             )}
                                         </div>
@@ -681,7 +669,7 @@ export function ScheduledTestsList({
                                                 width: "100%",
                                             }}
                                         >
-                                            {/* --- TLA─î├ŹTKA --- */}
+                                            {/* --- TLA´┐Ż´┐ŻTKA --- */}
                                             {isRunning ||
                                             (isOpen && !isCompleted) ? (
                                                 <button
@@ -735,8 +723,8 @@ export function ScheduledTestsList({
                                                         }}
                                                     >
                                                         {isRunning
-                                                            ? "ÔľÂ´ŞĆ Pokra─Źovat v testu"
-                                                            : "­čÜÇ Spustit test"}
+                                                            ? "?? Pokra´┐Żovat v testu"
+                                                            : "?? Spustit test"}
                                                     </span>
                                                 </button>
                                             ) : (
@@ -782,7 +770,7 @@ export function ScheduledTestsList({
                                                                 "nowrap",
                                                         }}
                                                     >
-                                                        ­čžá Procvi─Źit ot├ízky
+                                                        ?? ProcviTit ot.zky
                                                     </span>
                                                 </button>
                                             )}
diff --git a/src/hooks/useUserProfile.js b/src/hooks/useUserProfile.js
index a586f19..1fdad5c 100644
--- a/src/hooks/useUserProfile.js
+++ b/src/hooks/useUserProfile.js
@@ -3,21 +3,21 @@ import { supabase } from '../supabaseClient';
 import { clearImageCache, clearLocalQuestionData } from '../utils/dataManager';
 
 export function useUserProfile() {
-    // --- STAV U┼ŻIVATELE A DAT ---
+    // --- STAV UÔö╝IVATELE A DAT ---
     const [user, setUser] = useState(null);
     const [dbId, setDbId] = useState(null);
     const [loading, setLoading] = useState(false);
     const [syncing, setSyncing] = useState(false);
 
-    // Data u┼żivatele
+    // Data uÔö╝ivatele
     const [mistakes, setMistakes] = useState({});
     const [history, setHistory] = useState([]);
     const [testPracticeStats, setTestPracticeStats] = useState({});
     const [totalTimeMap, setTotalTimeMap] = useState({});
     const [totalQuestionsMap, setTotalQuestionsMap] = useState({});
 
-    // Kompletn├ş profilov├í data (pro Smart session atd.)
-    // Inicializujeme jako pr├ízdn├Ż objekt, aby se dalo d─Ťlat ...prev
+    // KompletnÔöť profilovv data (pro Smart session atd.)
+    // Inicializujeme jako prÔöťzdnn objekt, aby se dalo d lat ...prev
     const [profileData, setProfileData] = useState({});
 
     // Session Management
@@ -25,11 +25,11 @@ export function useUserProfile() {
     const [mySessionId, setMySessionId] = useState(null);
     const mySessionIdRef = useRef(null);
 
-    // --- 1. REF PRO GARANCI MINIM├üLN├ŹHO ─îASU ---
+    // --- 1. REF PRO GARANCI MINIMÔöťLNNHO OASU ---
     const minSyncTimeRef = useRef(0);
     const stopSyncTimeoutRef = useRef(null);
 
-    // Clean-up p┼Öi odmontov├ín├ş komponenty
+    // Clean-up pÔö╝i odmontovvn├ş komponenty
     useEffect(() => {
         return () => {
             if (stopSyncTimeoutRef.current) {
@@ -38,18 +38,18 @@ export function useUserProfile() {
         };
     }, []);
 
-    // Pomocn├í funkce pro start synchronizace (vizu├íl)
+    // PomocnÔöť funkce pro start synchronizace (vizuul)
     const startVisualSync = () => {
         if (stopSyncTimeoutRef.current) {
             clearTimeout(stopSyncTimeoutRef.current);
             stopSyncTimeoutRef.current = null;
         }
-        // Ikona sv├şt├ş minim├íln─Ť 500ms od te─Ć
+        // Ikona svÔöťtt minimiln├ş 500ms od ted
         minSyncTimeRef.current = Date.now() + 500;
         setSyncing(true);
     };
 
-    // Pomocn├í funkce pro konec synchronizace (vizu├íl)
+    // PomocnÔöť funkce pro konec synchronizace (vizuul)
     const stopVisualSync = () => {
         const now = Date.now();
         const timeRemaining = minSyncTimeRef.current - now;
@@ -71,7 +71,7 @@ export function useUserProfile() {
             const newSessionId = crypto.randomUUID();
             setMySessionId(newSessionId);
             mySessionIdRef.current = newSessionId;
-            // Aktualizujeme session v DB bez triggerov├ín├ş loading stavu
+            // Aktualizujeme session v DB bez triggerovÔöťnn loading stavu
             await supabase.from("profiles").update({ active_session_id: newSessionId }).eq("id", dbId);
         };
         initSession();
@@ -83,9 +83,9 @@ export function useUserProfile() {
             filter: `id=eq.${dbId}` 
         }, (payload) => {
             const remoteSessionId = payload.new.active_session_id;
-            // Pokud p┼Öi┼íla zm─Ťna session ID a nen├ş to ta na┼íe (a nen├ş null = logout), blokujeme
+            // Pokud pÔö╝iila zmzna session ID a nenn to ta naae (a nena null = logout), blokujeme
             if (remoteSessionId && mySessionIdRef.current && remoteSessionId !== mySessionIdRef.current) {
-                console.warn("Detekov├ína jin├í aktivn├ş session. Blokuji p┼Ö├şstup.");
+                console.warn("DetekovÔöťna jinn aktivnv session. Blokuji pi stup.");
                 setIsSessionBlocked(true);
             }
         }).subscribe();
@@ -95,25 +95,25 @@ export function useUserProfile() {
         };
     }, [user, dbId]);
 
-    // --- P┼śEVZET├Ź SESSION ---
+    // --- PÔö╝EVZETT SESSION ---
     const takeOverSession = async () => {
         if (!dbId) return;
         setLoading(true);
         try {
             const newSessionId = crypto.randomUUID();
             setMySessionId(newSessionId);
-            mySessionIdRef.current = newSessionId; // D┼»le┼żit├ę nastavit ref p┼Öed vol├ín├şm DB
+            mySessionIdRef.current = newSessionId; // DÔö╝leeiti nastavit ref pfed vol nom DB
 
             await supabase.from("profiles").update({ active_session_id: newSessionId }).eq("id", dbId);
             setIsSessionBlocked(false);
         } catch (err) {
-            console.error("Chyba p┼Öevzet├ş session:", err);
+            console.error("Chyba pÔö╝evzett session:", err);
         } finally {
             setLoading(false);
         }
     };
 
-    // --- P┼śIHL├ü┼áEN├Ź & DATA ---
+    // --- PÔö╝IHLLÔöťEN├í & DATA ---
     const login = async (enteredCode) => {
         setLoading(true);
         try {
@@ -123,7 +123,7 @@ export function useUserProfile() {
                 .eq("code", enteredCode)
                 .maybeSingle();
 
-            if (codeError || !codeData) throw new Error("Neplatn├Ż p┼Ö├şstupov├Ż k├│d."); 
+            if (codeError || !codeData) throw new Error("NeplatnÔöť ppÔö╝stupovp kÔöťd."); 
 
             const identifiedUser = codeData.used_by || enteredCode;
 
@@ -149,22 +149,22 @@ export function useUserProfile() {
                 fetchedProfile = newData;
             }
 
-            // Nastaven├ş stav┼»
+            // NastavenÔöť stavv
             setDbId(fetchedProfile.id); 
             setMistakes(fetchedProfile.mistakes || {}); 
             setHistory(fetchedProfile.history || []); 
             setTotalTimeMap(fetchedProfile.subject_times || {}); 
             setTotalQuestionsMap(fetchedProfile.question_counts || {}); 
             setTestPracticeStats(fetchedProfile.test_practice_stats || {}); 
-            setProfileData(fetchedProfile || {}); // D┼»le┼żit├ę pro Smart Session (zaji┼ít─Ťno, ┼że nen├ş null)
+            setProfileData(fetchedProfile || {}); // DÔö╝leeiti pro Smart Session (zajiatino, ┼Ąe nen┼╝ null)
             setUser(fetchedProfile.username);
 
             localStorage.setItem("quizio_user_code", enteredCode);
             setIsSessionBlocked(false);
 
         } catch (err) { 
-            console.error("Chyba p┼Öihl├í┼íen├ş:", err);
-            alert("Chyba p┼Öihl├í┼íen├ş: " + (err.message || "Nezn├ím├í chyba")); 
+            console.error("Chyba pÔö╝ihllenÔö╝:", err);
+            alert("Chyba pÔö╝ihllenÔö╝: " + (err.message || "Nezn"me chyba")); 
         } finally { 
             setLoading(false); 
         }
@@ -183,53 +183,53 @@ export function useUserProfile() {
         setIsSessionBlocked(false);
         setMistakes({});
         setHistory([]);
-        setProfileData({}); // Reset na pr├ízdn├Ż objekt, ne null
+        setProfileData({}); // Reset na prÔöťzdnn objekt, ne null
     };
 
-    // --- UKL├üD├üN├Ź DAT (Upraveno pro Deep Merge smart_session) ---
+    // --- UKLÔöťDDN├╝ DAT (Upraveno pro Deep Merge smart_session) ---
     const saveData = async (updates) => {
         if (!dbId || isSessionBlocked) return;
 
         startVisualSync();
 
-        // 1. Optimistick├Ż update lok├íln├şch stav┼» (pro okam┼żitou odezvu UI)
+        // 1. OptimistickÔöť update lokklnlch stavt (pro okamoitou odezvu UI)
         if (updates.mistakes) setMistakes(updates.mistakes);
         if (updates.history) setHistory(updates.history);
         if (updates.test_practice_stats) setTestPracticeStats(updates.test_practice_stats);
         if (updates.subject_times) setTotalTimeMap(updates.subject_times);
         if (updates.question_counts) setTotalQuestionsMap(updates.question_counts);
 
-        // 2. Aktualizace celkov├ęho profilu (nap┼Ö. smart_session)
-        // ZDE JE KL├Ź─îOV├ü ZM─ÜNA: Deep Merge pro smart_session
+        // 2. Aktualizace celkovÔöťho profilu (napp. smart_session)
+        // ZDE JE KLÔöť┼╣OVO ZM NA: Deep Merge pro smart_session
         setProfileData(prev => {
-            // Pokud aktualizujeme smart_session, mus├şme ud─Ťlat merge s p┼Öedchoz├şm stavem uvnit┼Ö smart_session,
-            // aby se nep┼Öepsaly ostatn├ş p┼Öedm─Ťty.
+            // Pokud aktualizujeme smart_session, musÔöťme uddlat merge s p edchozhm stavem uvnitv smart_session,
+            // aby se nepÔö╝epsaly ostatnn p edmety.
             if (updates.smart_session) {
-                // updates.smart_session u┼ż obvykle z App.js chod├ş slou─Źen├ę (tam d─Ťl├íme ...existingSessions),
-                // ale pro jistotu zde spol├ęh├íme na to, ┼że updates obsahuje fin├íln├ş podobu objektu smart_session,
-                // kterou chceme ulo┼żit.
+                // updates.smart_session uÔö╝ obvykle z App.js chodd slouoen┼╣ (tam dal me ...existingSessions),
+                // ale pro jistotu zde spolÔöťhhme na to, ,e updates obsahuje finflnÔöť podobu objektu smart_session,
+                // kterou chceme uloÔö╝it.
                 // V App.js: const updatedSessions = { ...existingSessions, [subject]: sessionData };
-                // Tak┼że zde sta─Ź├ş prost├Ż merge na ├║rovni rootu.
+                // TakÔö╝e zde staaÔöÇ prosto merge na  rovni rootu.
                 return {
                     ...prev,
                     ...updates
                 };
             }
-            // Pro ostatn├ş updates (mistakes atd.) sta─Ź├ş m─Ťlk├Ż merge
+            // Pro ostatnÔöť updates (mistakes atd.) staaÔöÇ m┼člkÔöÇ merge
             return { ...prev, ...updates };
         });
 
         try {
             await supabase.from("profiles").update(updates).eq("id", dbId);
         } catch (err) {
-            console.error("Chyba p┼Öi ukl├íd├ín├ş:", err);
-            // Zde by ┼ílo implementovat rollback stavu, pokud by to bylo kritick├ę
+            console.error("Chyba pÔö╝i uklld├şnÔöť:", err);
+            // Zde by Ôö╝lo implementovat rollback stavu, pokud by to bylo kritickk
         } finally {
             stopVisualSync();
         }
     };
 
-    // Obnoven├ş dat z DB
+    // ObnovenÔöť dat z DB
     const refreshData = async () => {
         if (!dbId) return;
         startVisualSync();
@@ -249,7 +249,7 @@ export function useUserProfile() {
                 setProfileData(fetchedProfile || {}); // Aktualizace smart_session atd.
             }
         } catch (err) {
-             console.error("Chyba p┼Öi refreshData:", err);
+             console.error("Chyba pÔö╝i refreshData:", err);
         } finally {
             stopVisualSync();
         }
@@ -264,7 +264,7 @@ export function useUserProfile() {
     return {
         user, dbId, loading, syncing, isSessionBlocked,
         mistakes, history, testPracticeStats, totalTimeMap, totalQuestionsMap,
-        profileData, // Exportujeme i cel├í data pro logiku Smart Session
+        profileData, // Exportujeme i celÔöť data pro logiku Smart Session
         login, logout, takeOverSession, saveData, refreshData, triggerFakeSync,
         setMistakes, setHistory, setTotalTimeMap, setTotalQuestionsMap
     };
diff --git a/src/utils/formatting.js b/src/utils/formatting.js
index 8798e1a..f08597a 100644
--- a/src/utils/formatting.js
+++ b/src/utils/formatting.js
@@ -37,19 +37,19 @@ export const removeAccents = (str) => {
 export const getSmartRegex = (search) => {
   if (!search) return null;
   const map = {
-      a: "[a├í]",
-      e: "[e├ę─Ť]",
-      i: "[i├ş]",
-      o: "[o├│]",
-      u: "[u├║┼»]",
-      y: "[y├Ż]",
-      c: "[c─Ź]",
-      d: "[d─Ć]",
-      n: "[n┼ł]",
-      r: "[r┼Ö]",
-      s: "[s┼í]",
-      t: "[t┼ą]",
-      z: "[z┼ż]",
+      a: "[aÔöť]",
+      e: "[eÔöť─Ö]",
+      i: "[iÔöť]",
+      o: "[oÔöť]",
+      u: "[uÔöťÔĽĹ]",
+      y: "[yÔöť]",
+      c: "[cÔöÇ]",
+      d: "[dÔöÇ]",
+      n: "[nÔö╝]",
+      r: "[rÔö╝]",
+      s: "[sÔö╝]",
+      t: "[tÔö╝]",
+      z: "[zÔö╝]",
   };
   const escaped = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
   const pattern = escaped
